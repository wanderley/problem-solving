<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Leetcode: 1948. Delete Duplicate Folders in System</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="style.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<!--  --><nav><span class="nav-header">Problem Solving</span><span class="nav-items"><a href="index.html">Home</a><span></nav><div id="content" class="content">
<h1 class="title">Leetcode: 1948. Delete Duplicate Folders in System</h1>
<ul class="org-ul">
<li><a href="mistake_incorrect_evaluation_of_solution_s_viability.html#ID-DA951820-DBB5-4A7F-9401-DF5860EFAB8A">Mistake: Incorrect evaluation of solution's viability</a>: Coded a more complex and <i>wrong</i> solution using hashes to avoid time limit when the simple solution was enough.</li>
</ul>

<p>
<a href="can_we_simplify_the_problem_which_keeping_it_the_same.html#ID-F19C9539-EE46-41EE-8DEF-24C3076C6DC2">Can we simplify the problem while keeping it the same?</a>  Imagine that we can assign an <b>id</b> for each subtree where different subtrees have different numbers and equivalent subtrees have the same number.  The problem becomes filtering all subtrees with duplicated id.  For this problem, the id can be a serialization of the subtree like one generated by a pre-order traversing of the tree.  Time complexity is \(O(n)\) where \(n\) is the number of nodes in the tree.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> typing <span style="font-weight: bold;">import</span> List


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">deleteDuplicateFolder</span>(<span style="font-weight: bold;">self</span>, paths: List[List[<span style="font-weight: bold;">str</span>]]) -&gt; List[List[<span style="font-weight: bold;">str</span>]]:
        <span style="font-weight: bold; font-style: italic;">root</span> = {}
        <span style="font-weight: bold;">for</span> path <span style="font-weight: bold;">in</span> <span style="font-weight: bold; font-style: italic;">paths</span>:
            node = root
            <span style="font-weight: bold;">for</span> p <span style="font-weight: bold;">in</span> <span style="font-weight: bold; font-style: italic;">path</span>:
                node = node.setdefault(p, {})

        <span style="font-weight: bold; font-style: italic;">code</span> = {}

        <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">encode</span>(node):
            <span style="font-weight: bold;">if</span> <span style="font-weight: bold;">not</span> <span style="font-weight: bold; font-style: italic;">node</span>:
                <span style="font-weight: bold;">return</span> <span style="font-style: italic;">"null"</span>
            code[<span style="font-weight: bold;">id</span>(node)] = <span style="font-style: italic;">","</span>.join(
                f<span style="font-style: italic;">"(</span>{child}<span style="font-style: italic;">,</span>{encode(node[child])}<span style="font-style: italic;">)"</span> <span style="font-weight: bold;">for</span> child <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">sorted</span>(node)
            )
            <span style="font-weight: bold;">return</span> code[<span style="font-weight: bold;">id</span>(node)]

        encode(root)
        <span style="font-weight: bold; font-style: italic;">freq</span> = Counter(code.values())
        <span style="font-weight: bold; font-style: italic;">ans</span> = []

        <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">dfs</span>(node, path):
            <span style="font-weight: bold;">if</span> <span style="font-weight: bold;">not</span> node:
                ans.append(path[::])
                <span style="font-weight: bold;">return</span>
            <span style="font-weight: bold;">if</span> freq[code[<span style="font-weight: bold;">id</span>(node)]] &gt; 1:
                <span style="font-weight: bold;">return</span>
            ans.append(path[::])
            <span style="font-weight: bold;">for</span> child <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">sorted</span>(node):
                path.append(child)
                dfs(node[child], path)
                path.pop()

        dfs(root, [])
        <span style="font-weight: bold;">return</span> ans[1:]


<span style="font-weight: bold;">assert</span> Solution().deleteDuplicateFolder(
    [[<span style="font-style: italic;">"a"</span>], [<span style="font-style: italic;">"c"</span>], [<span style="font-style: italic;">"d"</span>], [<span style="font-style: italic;">"a"</span>, <span style="font-style: italic;">"b"</span>], [<span style="font-style: italic;">"c"</span>, <span style="font-style: italic;">"b"</span>], [<span style="font-style: italic;">"d"</span>, <span style="font-style: italic;">"a"</span>]]
) == [[<span style="font-style: italic;">"d"</span>], [<span style="font-style: italic;">"d"</span>, <span style="font-style: italic;">"a"</span>]]
<span style="font-weight: bold;">assert</span> Solution().deleteDuplicateFolder(
    [
        [<span style="font-style: italic;">"a"</span>],
        [<span style="font-style: italic;">"c"</span>],
        [<span style="font-style: italic;">"a"</span>, <span style="font-style: italic;">"b"</span>],
        [<span style="font-style: italic;">"c"</span>, <span style="font-style: italic;">"b"</span>],
        [<span style="font-style: italic;">"a"</span>, <span style="font-style: italic;">"b"</span>, <span style="font-style: italic;">"x"</span>],
        [<span style="font-style: italic;">"a"</span>, <span style="font-style: italic;">"b"</span>, <span style="font-style: italic;">"x"</span>, <span style="font-style: italic;">"y"</span>],
        [<span style="font-style: italic;">"w"</span>],
        [<span style="font-style: italic;">"w"</span>, <span style="font-style: italic;">"y"</span>],
    ]
) == [[<span style="font-style: italic;">"a"</span>], [<span style="font-style: italic;">"a"</span>, <span style="font-style: italic;">"b"</span>], [<span style="font-style: italic;">"c"</span>], [<span style="font-style: italic;">"c"</span>, <span style="font-style: italic;">"b"</span>]]
<span style="font-weight: bold;">assert</span> Solution().deleteDuplicateFolder([[<span style="font-style: italic;">"a"</span>, <span style="font-style: italic;">"b"</span>], [<span style="font-style: italic;">"c"</span>, <span style="font-style: italic;">"d"</span>], [<span style="font-style: italic;">"c"</span>], [<span style="font-style: italic;">"a"</span>]]) == [
    [<span style="font-style: italic;">"a"</span>],
    [<span style="font-style: italic;">"a"</span>, <span style="font-style: italic;">"b"</span>],
    [<span style="font-style: italic;">"c"</span>],
    [<span style="font-style: italic;">"c"</span>, <span style="font-style: italic;">"d"</span>],
]
</pre>
</div>
</div>
</body>
</html>
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Leetcode: 1632. Rank Transform of a Matrix</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="style.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<!--  --><nav><span class="nav-header">Problem Solving</span><span class="nav-items"><a href="index.html">Home</a><span></nav><div id="content" class="content">
<h1 class="title">Leetcode: 1632. Rank Transform of a Matrix</h1>
<ul class="org-ul">
<li><a href="mistake_did_not_try_hard_to_solve_alternative_problem.html#ID-AC9291C6-4C72-4143-80F2-0D414EF7B681">Mistake: Did not try hard to solve alternative problem</a>.  I considered the graph formed by rows and cols, but I didn't think about having one graph for each value in the grid.</li>

<li><a href="mistake_incorrect_evaluation_of_solution_s_viability.html#ID-DA951820-DBB5-4A7F-9401-DF5860EFAB8A">Mistake: Incorrect evaluation of solution's viability</a>.  My first implementation had vertices as cells and edges between cells with the same value that share the same column and/or row.  The complexity of the solution ended up to be \(O((n \times m)^2)\).</li>

<li><a href="blackbox_you_solved_a_similar_problem.html#ID-37AF9679-42D1-4A85-9927-2A590268AD87">Blackbox: You solved a similar problem</a> where you had to process the cells in increase order of values.</li>

<li><a href="is_there_an_alternative_problem_easier_to_solve.html#ID-64E7E55B-09A9-4022-AB5E-1D25FC64EAC9">Is there an alternative problem easier to solve?</a>  Suppose that we have all cells sorted by value.  The smaller one should have the smallest value in the input.  In order to discover the value of the cell, we have to know the max value used in its column and row (stored in two arrays).  We still have to discover what are the cells (with same value) that have to be updated at the same time.</li>

<li><a href="can_we_formulate_the_problem_using_graphs.html#ID-DA1E3A63-73BB-475E-B087-128602B13450">Can we formulate the problem using graphs?</a>  For each different cell value \(k\), we will create an <a href="bipartite_graph.html#ID-F1D5D810-3FDF-45C3-BAF1-68584BD77DB3">Bipartite Graph</a> \(g_k\) where vertices of \(g_k\) are rows and columns and there is an edge between two vertices \(i\) (row) and \(j\) (column) if there is \(matrix[i][j]=k\).  In this graph, we can use <a href="union_find.html#ID-23A4E36E-24D3-40F8-AA20-32C0DB1E36F6">Union-Find</a> to find the components of the graph and therefore discovering the cells that have to be updated together.</li>

<li>Time and space complexity is \(O(n \times m)\).</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> typing <span style="font-weight: bold;">import</span> List
<span style="font-weight: bold;">from</span> collections <span style="font-weight: bold;">import</span> defaultdict


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">UnionFind</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>):
        <span style="font-weight: bold;">self</span>.p = {}

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">find</span>(<span style="font-weight: bold;">self</span>, u):
        <span style="font-weight: bold;">if</span> <span style="font-weight: bold;">self</span>.p[u] != <span style="font-weight: bold; font-style: italic;">u</span>:
            <span style="font-weight: bold;">self</span>.p[<span style="font-weight: bold; font-style: italic;">u</span>] = <span style="font-weight: bold;">self</span>.find(<span style="font-weight: bold;">self</span>.p[u])
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">self</span>.p[u]

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">union</span>(<span style="font-weight: bold;">self</span>, u, v):
        <span style="font-weight: bold;">self</span>.p.setdefault(u, u)
        <span style="font-weight: bold;">self</span>.p.setdefault(v, v)
        <span style="font-weight: bold;">self</span>.<span style="font-weight: bold; font-style: italic;">p</span>[<span style="font-weight: bold;">self</span>.find(u)] = <span style="font-weight: bold;">self</span>.find(v)


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">matrixRankTransform</span>(<span style="font-weight: bold;">self</span>, matrix: List[List[<span style="font-weight: bold;">int</span>]]) -&gt; List[List[<span style="font-weight: bold;">int</span>]]:
        <span style="font-weight: bold; font-style: italic;">N</span> = <span style="font-weight: bold;">len</span>(matrix)
        <span style="font-weight: bold; font-style: italic;">M</span> = <span style="font-weight: bold;">len</span>(matrix[0])

        <span style="font-weight: bold; font-style: italic;">uf</span> = defaultdict(UnionFind)
        <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N):
            <span style="font-weight: bold;">for</span> j <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(M):
                uf[matrix[i][j]].union(i, ~j)

        <span style="font-weight: bold; font-style: italic;">components</span> = defaultdict(<span style="font-weight: bold;">lambda</span>: defaultdict(<span style="font-weight: bold;">list</span>))
        <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N):
            <span style="font-weight: bold;">for</span> j <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(M):
                value = matrix[i][j]
                <span style="font-weight: bold; font-style: italic;">u</span> = uf[value].find(i)
                components[value][u].append((i, j))

        <span style="font-weight: bold; font-style: italic;">ar</span> = [1 <span style="font-weight: bold;">for</span> _ <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N)]
        <span style="font-weight: bold; font-style: italic;">ac</span> = [1 <span style="font-weight: bold;">for</span> _ <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(M)]
        <span style="font-weight: bold; font-style: italic;">ans</span> = [[<span style="font-weight: bold; text-decoration: underline;">None</span>] * M <span style="font-weight: bold;">for</span> _ <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N)]
        <span style="font-weight: bold;">for</span> c <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">sorted</span>(components):
            <span style="font-weight: bold;">for</span> cells <span style="font-weight: bold;">in</span> components[c].values():
                <span style="font-weight: bold; font-style: italic;">m</span> = <span style="font-weight: bold;">max</span>(<span style="font-weight: bold;">max</span>(ar[ni], ac[nj]) <span style="font-weight: bold;">for</span> ni, nj <span style="font-weight: bold;">in</span> cells)
                <span style="font-weight: bold;">for</span> ni, nj <span style="font-weight: bold;">in</span> <span style="font-weight: bold; font-style: italic;">cells</span>:
                    ar[<span style="font-weight: bold; font-style: italic;">ni</span>] = m + 1
                    <span style="font-weight: bold; font-style: italic;">ac</span>[<span style="font-weight: bold; font-style: italic;">nj</span>] = m + 1
                    ans[ni][<span style="font-weight: bold; font-style: italic;">nj</span>] = m
        <span style="font-weight: bold;">return</span> ans


<span style="font-weight: bold;">assert</span> Solution().matrixRankTransform([[1, 2], [3, 4]]) == [[1, 2], [2, 3]]
<span style="font-weight: bold;">assert</span> Solution().matrixRankTransform([[7, 7], [7, 7]]) == [[1, 1], [1, 1]]
<span style="font-weight: bold;">assert</span> Solution().matrixRankTransform(
    [[20, -21, 14], [-19, 4, 19], [22, -47, 24], [-19, 4, 19]]
) == [[4, 2, 3], [1, 3, 4], [5, 1, 6], [1, 3, 4]]
</pre>
</div>
</div>
</body>
</html>
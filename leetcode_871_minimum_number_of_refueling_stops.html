<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Leetcode: 871. Minimum Number of Refueling Stops</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="style.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<!--  --><nav><span class="nav-header">Problem Solving</span><span class="nav-items"><a href="index.html">Home</a><span></nav><div id="content" class="content">
<h1 class="title">Leetcode: 871. Minimum Number of Refueling Stops</h1>
<ul class="org-ul">
<li><a href="mistake_did_not_slow_down_to_make_sure_that_each_part_of_the_problem_was_solved_correctly.html#ID-E6B9ECE9-E7F6-4273-90DB-226664B11C0A">Mistake: Did not slow down to make sure that each part of the problem was solved correctly</a>.  I found the recurrence with time complexity of \(O(n^2 \times k)\) and didn't not carefully extract the memorization to make it \(O(n \times k)\).</li>

<li><a href="pattern_find_shortest_path_on_directed_acyclic_graph.html#ID-A32AAFD2-5569-4417-8085-04005F85A435">Pattern: Find shortest path on directed acyclic graph</a>.</li>

<li><a href="is_there_an_alternative_problem_easier_to_solve.html#ID-64E7E55B-09A9-4022-AB5E-1D25FC64EAC9">Is there an alternative problem easier to solve?</a>  Compute \(m[k][i]\) which represents the minimum fuel required to go from station \(i\) to \(target\) stopping in other \(k\) stations ahead.  If \(stations[i][0] + m[k][i] <= startFuel\), then \(k\) is an answer to the original problem.  The original recurrence is \(m[k][i] = max(0, min_{i < j \leq n}(m[k-1][j] + stations[j][0] - stations[i][0] - stations[i][1] for j in range(i + 1, N))\) which consumes \(O(n^2 \times k)\) to be computed, but the \(min\) part can be extracted and answered in \(O(1)\).  Therefore, the time and space complexity of the solution is \(O(n \times k)\).</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> typing <span style="font-weight: bold;">import</span> List


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">minRefuelStops</span>(
        <span style="font-weight: bold;">self</span>, target: <span style="font-weight: bold;">int</span>, startFuel: <span style="font-weight: bold;">int</span>, stations: List[List[<span style="font-weight: bold;">int</span>]]
    ) -&gt; <span style="font-weight: bold;">int</span>:
        <span style="font-weight: bold;">if</span> target &lt;= <span style="font-weight: bold; font-style: italic;">startFuel</span>:
            <span style="font-weight: bold;">return</span> 0
        N = <span style="font-weight: bold;">len</span>(stations)
        <span style="font-weight: bold; font-style: italic;">m</span> = [[<span style="font-weight: bold;">float</span>(<span style="font-style: italic;">"inf"</span>)] * N <span style="font-weight: bold;">for</span> _ <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N)]
        <span style="font-weight: bold; font-style: italic;">b</span> = [[<span style="font-weight: bold;">float</span>(<span style="font-style: italic;">"inf"</span>)] * N <span style="font-weight: bold;">for</span> _ <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N)]
        <span style="font-weight: bold;">for</span> k <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N):
            <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N - 1, -1, -1):
                <span style="font-weight: bold;">if</span> k == 0:
                    m[k][<span style="font-weight: bold; font-style: italic;">i</span>] = <span style="font-weight: bold;">max</span>(0, target - stations[i][0] - stations[i][1])
                    b[k][<span style="font-weight: bold; font-style: italic;">i</span>] = <span style="font-weight: bold;">min</span>(
                        b[k][i + 1] <span style="font-weight: bold;">if</span> i + 1 &lt; N <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">float</span>(<span style="font-style: italic;">"inf"</span>),
                        m[k][i] + stations[i][0],
                    )
                <span style="font-weight: bold;">elif</span> i + 1 == N:
                    b[k][<span style="font-weight: bold; font-style: italic;">i</span>] = <span style="font-weight: bold;">float</span>(<span style="font-style: italic;">"inf"</span>)
                <span style="font-weight: bold;">else</span>:
                    m[k][<span style="font-weight: bold; font-style: italic;">i</span>] = b[k - 1][i + 1]
                    m[k][<span style="font-weight: bold; font-style: italic;">i</span>] += -stations[i][0] - stations[i][1]
                    m[k][<span style="font-weight: bold; font-style: italic;">i</span>] = <span style="font-weight: bold;">max</span>(0, m[k][i])
                    b[k][<span style="font-weight: bold; font-style: italic;">i</span>] = <span style="font-weight: bold;">min</span>(b[k][i + 1], m[k][i] + stations[i][0])
                <span style="font-weight: bold;">if</span> stations[i][0] + m[k][i] &lt;= startFuel:
                    <span style="font-weight: bold;">return</span> k + 1
        <span style="font-weight: bold;">return</span> -1


<span style="font-weight: bold;">assert</span> Solution().minRefuelStops(1, startFuel=1, stations=[])
<span style="font-weight: bold;">assert</span> Solution().minRefuelStops(100, startFuel=1, stations=[[10, 100]])
<span style="font-weight: bold;">assert</span> Solution().minRefuelStops(
    100, startFuel=10, stations=[[10, 60], [20, 30], [30, 30], [60, 40]]
)
</pre>
</div>

<ul class="org-ul">
<li><a href="can_you_break_down_the_problem_in_small_and_easily_to_solve_parts.html#ID-69D68202-BF1A-4D72-A0EC-DDCBAF112500">Can we break-down the problem in small and easily to solve parts?</a>  Compute the max distance that it is possible to reach with 0 stops (ie. \(startFuel\)).  Compute the max distance with 1 stop, it will be \(startFuel+stations[0][1]\) iff \(startFuel \geq stations[0][1]\).  Time complexity is \(O(n ^ 2)\) and space is \(O(n)\).</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> typing <span style="font-weight: bold;">import</span> List


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">minRefuelStops</span>(
        <span style="font-weight: bold;">self</span>, target: <span style="font-weight: bold;">int</span>, startFuel: <span style="font-weight: bold;">int</span>, stations: List[List[<span style="font-weight: bold;">int</span>]]
    ) -&gt; <span style="font-weight: bold;">int</span>:
        N = <span style="font-weight: bold;">len</span>(stations)
        <span style="font-weight: bold; font-style: italic;">dp</span> = [0] * (N + 1)
        <span style="font-weight: bold; font-style: italic;">dp</span>[0] = startFuel
        <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N):
            <span style="font-weight: bold;">for</span> k <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(i, -1, -1):
                <span style="font-weight: bold;">if</span> dp[k] &gt;= stations[i][0]:
                    <span style="font-weight: bold; font-style: italic;">dp</span>[k + 1] = <span style="font-weight: bold;">max</span>(dp[k + 1], dp[k] + stations[i][1])
        <span style="font-weight: bold;">for</span> k <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N + 1):
            <span style="font-weight: bold;">if</span> dp[k] &gt;= target:
                <span style="font-weight: bold;">return</span> k
        <span style="font-weight: bold;">return</span> -1
</pre>
</div>

<ul class="org-ul">
<li><a href="can_you_break_down_the_problem_in_small_and_easily_to_solve_parts.html#ID-69D68202-BF1A-4D72-A0EC-DDCBAF112500">Can we break-down the problem in small and easily to solve parts?</a>  Similar to the idea above, but keep the station that you passed by in a heap and use the one with max fuel if you need it.  Time complexity is \(O(n \log n)\) and space is \(O(n)\).</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">minRefuelStops</span>(<span style="font-weight: bold;">self</span>, target: <span style="font-weight: bold;">int</span>, startFuel: <span style="font-weight: bold;">int</span>, stations: List[List[<span style="font-weight: bold;">int</span>]]) -&gt; <span style="font-weight: bold;">int</span>:
        stations = stations + [[target, 0]]
        <span style="font-weight: bold; font-style: italic;">N</span> = <span style="font-weight: bold;">len</span>(stations)

        <span style="font-weight: bold; font-style: italic;">last</span> = <span style="font-weight: bold; font-style: italic;">ans</span> = 0
        <span style="font-weight: bold; font-style: italic;">tank</span> = startFuel
        <span style="font-weight: bold; font-style: italic;">pq</span> = []
        <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N):
            <span style="font-weight: bold; font-style: italic;">dist</span> = stations[i][0] - last
            <span style="font-weight: bold; font-style: italic;">tank</span> -= dist
            <span style="font-weight: bold;">while</span> pq <span style="font-weight: bold;">and</span> tank &lt; 0:
                <span style="font-weight: bold; font-style: italic;">tank</span> += -heappop(pq)
                <span style="font-weight: bold; font-style: italic;">ans</span> += 1
            <span style="font-weight: bold;">if</span> tank &lt; 0:
                <span style="font-weight: bold;">return</span> -1
            <span style="font-weight: bold; font-style: italic;">last</span> = stations[i][0]
            heappush(pq, -stations[i][1])
        <span style="font-weight: bold;">return</span> ans
</pre>
</div>
</div>
</body>
</html>
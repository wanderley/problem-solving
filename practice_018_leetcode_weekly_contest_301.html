<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Practice #018: Leetcode Weekly Contest 301</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="style.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<!--  --><nav><span class="nav-header">Problem Solving</span><span class="nav-items"><a href="index.html">Home</a><span></nav><div id="content" class="content">
<h1 class="title">Practice #018: Leetcode Weekly Contest 301</h1>
<ul class="org-ul">
<li>Time Spent: 1 hour 30 minutes</li>
<li>Time Allotted: 1 hour 30 minutes</li>
<li>Completed: July 9, 2022 9:00 PM</li>
<li>Score: 1/4</li>
</ul>

<div id="outline-container-org6e5b324" class="outline-2">
<h2 id="org6e5b324">Leetcode: 2335. Minimum Amount of Time to Fill Cups</h2>
<div class="outline-text-2" id="text-org6e5b324">
<p>
<a href="https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/">Problem Statement</a>
</p>

<p>
The greedy approach is to always remove water from the cups with most water.  That way, we make sure that we make the most usage of each second.  This approach can be implemented in many ways, but I decided sort the elements after each seconds.  Time complexity is \(O(\lceil\frac{\sum amount[i]}{2}\rceil)\) and space is $O(1).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> functools <span style="font-weight: bold;">import</span> cache
<span style="font-weight: bold;">from</span> typing <span style="font-weight: bold;">import</span> List


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">fillCups</span>(<span style="font-weight: bold;">self</span>, amount: List[<span style="font-weight: bold;">int</span>]) -&gt; <span style="font-weight: bold;">int</span>:
        t = 0
        <span style="font-weight: bold; font-style: italic;">amount</span> = <span style="font-weight: bold;">list</span>(<span style="font-weight: bold;">reversed</span>(<span style="font-weight: bold;">sorted</span>(amount)))
        <span style="font-weight: bold;">while</span> <span style="font-weight: bold;">sum</span>(amount) &gt; 0:
            <span style="font-weight: bold; font-style: italic;">c</span> = 0
            <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(3):
                <span style="font-weight: bold;">if</span> amount[i] &gt; 0 <span style="font-weight: bold;">and</span> c &lt; 2:
                    <span style="font-weight: bold; font-style: italic;">amount</span>[<span style="font-weight: bold; font-style: italic;">i</span>] -= 1
                    <span style="font-weight: bold; font-style: italic;">c</span> += 1
            <span style="font-weight: bold;">if</span> c &gt; 0:
                <span style="font-weight: bold; font-style: italic;">t</span> += 1
            <span style="font-weight: bold; font-style: italic;">amount</span> = <span style="font-weight: bold;">list</span>(<span style="font-weight: bold;">reversed</span>(<span style="font-weight: bold;">sorted</span>(amount)))
        <span style="font-weight: bold;">return</span> t


<span style="font-weight: bold;">assert</span> Solution().fillCups([1, 4, 2]) == 4
<span style="font-weight: bold;">assert</span> Solution().fillCups([5, 4, 4]) == 7
<span style="font-weight: bold;">assert</span> Solution().fillCups([5, 0, 0]) == 5
</pre>
</div>
</div>
</div>

<div id="outline-container-org0a58071" class="outline-2">
<h2 id="org0a58071">Leetcode: 2336. Smallest Number in Infinite Set</h2>
<div class="outline-text-2" id="text-org0a58071">
<p>
<a href="https://leetcode.com/problems/smallest-number-in-infinite-set/">Problem Statement</a>
</p>

<p>
We need two data-structures: a priority queue to answer the pop efficiently and a set to avoid duplicated numbers in the queue.  Time complexity is \(O(\log n)\) for each operation and space complexity is \(O(n)\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">SmallestInfiniteSet</span>:

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>):
        <span style="font-weight: bold;">self</span>.pq = []
        <span style="font-weight: bold;">self</span>.<span style="font-weight: bold; font-style: italic;">nums</span> = <span style="font-weight: bold;">set</span>()
        <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(1, 1000 + 1):
            heappush(<span style="font-weight: bold;">self</span>.pq, i)
            <span style="font-weight: bold;">self</span>.nums.add(i)

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">popSmallest</span>(<span style="font-weight: bold;">self</span>) -&gt; <span style="font-weight: bold;">int</span>:
        num = heappop(<span style="font-weight: bold;">self</span>.pq)
        <span style="font-weight: bold;">self</span>.nums.remove(num)
        <span style="font-weight: bold;">return</span> num

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">addBack</span>(<span style="font-weight: bold;">self</span>, num: <span style="font-weight: bold;">int</span>) -&gt; <span style="font-weight: bold; text-decoration: underline;">None</span>:
        <span style="font-weight: bold;">if</span> num <span style="font-weight: bold;">not</span> <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">self</span>.nums:
            heappush(<span style="font-weight: bold;">self</span>.pq, num)
            <span style="font-weight: bold;">self</span>.nums.add(num)


<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Your SmallestInfiniteSet object will be instantiated and called as such:</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">obj = SmallestInfiniteSet()</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">param_1 = obj.popSmallest()</span>
<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">obj.addBack(num)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org79bf4ec" class="outline-2">
<h2 id="org79bf4ec">Leetcode: 2337. Move Pieces to Obtain a String</h2>
<div class="outline-text-2" id="text-org79bf4ec">
<p>
<a href="https://leetcode.com/problems/move-pieces-to-obtain-a-string/">Problem Statement</a>
</p>

<p>
Retrospective: Spent most of the time trying to find a process to move the letter around, instead of discovering the invariant that they should keep in order to be valid.
</p>

<p>
<a href="can_you_derive_an_invariant_based_on_the_smallest_possible_examples.html#ID-BA632D61-93B6-47AB-B11A-7E9EBE3FC71D">Can we derive an invariant based on the smallest possible examples?</a>  Be \(i\) and \(j\) indexes on \(start\) and \(target\) where \(start[i]\) and \(target[i]\) aren't <code>_</code>, since positions with <code>_</code> can be ignored as they either are equal or should have a letter moved over.  If \(start[i] \neq target[j]\), then we can return \(False\) since they have letters in different places.  So, \(start[i] = target[j]\).  If \(start[i]="L"\) and \(i<j\), there is no way to move "L" to the right and the strings don't match.  If \(start[i]="R"\) and \(j>i\), there is no way to move "R" to the left and the strings don't match.  Otherwise, it is possible to move the letters to the right direction and we can move the next index.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">canChange</span>(<span style="font-weight: bold;">self</span>, start: <span style="font-weight: bold;">str</span>, target: <span style="font-weight: bold;">str</span>) -&gt; <span style="font-weight: bold;">bool</span>:
        n = <span style="font-weight: bold;">len</span>(start)
        <span style="font-weight: bold; font-style: italic;">i</span> = 0
        <span style="font-weight: bold; font-style: italic;">j</span> = 0

        <span style="font-weight: bold;">while</span> i &lt; n <span style="font-weight: bold;">and</span> j &lt; n:
            <span style="font-weight: bold;">while</span> i &lt; n <span style="font-weight: bold;">and</span> start[i] == <span style="font-style: italic;">"_"</span>:
                i += 1
            <span style="font-weight: bold;">while</span> j &lt; n <span style="font-weight: bold;">and</span> target[j] == <span style="font-style: italic;">"_"</span>:
                j += 1

            <span style="font-weight: bold;">if</span> i == n <span style="font-weight: bold;">or</span> j == n:
                <span style="font-weight: bold;">return</span> i == j

            <span style="font-weight: bold;">if</span> start[i] != target[j]:
                <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">False</span>

            <span style="font-weight: bold;">if</span> (i &lt; j <span style="font-weight: bold;">and</span> start[i] == <span style="font-style: italic;">"L"</span>) <span style="font-weight: bold;">or</span> (i &gt; j <span style="font-weight: bold;">and</span> start[i] == <span style="font-style: italic;">"R"</span>):
                <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">False</span>

            i += 1
            j += 1

        <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">True</span>


<span style="font-weight: bold;">assert</span> Solution().canChange(<span style="font-style: italic;">"_L__R__R_"</span>, <span style="font-style: italic;">"L______RR"</span>) == <span style="font-weight: bold; text-decoration: underline;">True</span>
<span style="font-weight: bold;">assert</span> Solution().canChange(<span style="font-style: italic;">"R_L_"</span>, <span style="font-style: italic;">"__LR"</span>) == <span style="font-weight: bold; text-decoration: underline;">False</span>
<span style="font-weight: bold;">assert</span> Solution().canChange(<span style="font-style: italic;">"_R"</span>, <span style="font-style: italic;">"R_"</span>) == <span style="font-weight: bold; text-decoration: underline;">False</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org96f1c37" class="outline-2">
<h2 id="org96f1c37">Leetcode: 2338. Count the Number of Ideal Arrays</h2>
<div class="outline-text-2" id="text-org96f1c37">
<p>
<a href="https://leetcode.com/problems/count-the-number-of-ideal-arrays/">Problem Statement</a>
</p>

<p>
Retrospective: I was too focus on finding the answer by iterating over the valid arrays that I didn't even consider that I could count them using a formula.
</p>

<p>
<a href="is_there_an_alternative_problem_easier_to_solve.html#ID-64E7E55B-09A9-4022-AB5E-1D25FC64EAC9">Is there an alternative problem easier to solve?</a>  Count the number of arrays with distinct numbers under the same rules:
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">dfs</span>(i, cur):
    <span style="font-weight: bold;">if</span> i == n:
        <span style="font-weight: bold;">return</span> 1
    <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">sum</span>(dfs(j <span style="font-weight: bold;">for</span> j <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(cur + cur, m + 1, cur)))
</pre>
</div>

<p>
Be \(m\) the maximum value that we can have in the array of length \(n\).  There are \(O(n \times m)\) nodes in the search-space.  It seems that the time complexity is \(O(n \times m^2)\), but actually it is less than that.  When \(cur=1\), there are \(m\) values for \(j\).  When \(cur=2\), there are \(m/2\) values for \(j\).  When \(cur=k\), there are \(\lfloor m / k \rfloor\) values for \(j\).  So, the number of \(j\)'s iterations is \(m+m/2+m/3+...+1=O(m \log m)\).  Therefore, the time complexity is \(O(n \times m + m \log m)\) and space is \(O(n \times m)\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> math <span style="font-weight: bold;">import</span> floor, sqrt, log

<span style="font-weight: bold;">return</span> [(<span style="font-style: italic;">"m"</span>, <span style="font-style: italic;">"sum"</span>, <span style="font-style: italic;">"$m \times \log m$"</span>)] + [
    (k, <span style="font-weight: bold;">sum</span>(floor(k / p) <span style="font-weight: bold;">for</span> p <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(1, k + 1)), floor(k * (log(k)/log(2))))
    <span style="font-weight: bold;">for</span> k <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(1_000, 10_000 + 1, 1_000)
]
</pre>
</div>

<p>
<a href="how_can_we_extend_the_solution_to_the_alternative_problem_to_solve_the_original_problem.html#ID-A668AA75-F0F2-4730-A9FA-E07CEE0C2634">How can we extend the solution to the alternative problem to solve the original problem?</a>  In the previous problem, \(i\) represents the number of distinct elements ending on \(cur\).  If we don't add any other element, we have \(\binom{n-1}{i-1}\) possible arrays (i.e. number of ways to divide \(n\) consecutive elements in \(i\) groups).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> math <span style="font-weight: bold;">import</span> comb
<span style="font-weight: bold;">from</span> functools <span style="font-weight: bold;">import</span> cache


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">idealArrays</span>(<span style="font-weight: bold;">self</span>, n: <span style="font-weight: bold;">int</span>, maxValue: <span style="font-weight: bold;">int</span>) -&gt; <span style="font-weight: bold;">int</span>:
        M = 10**9 + 7

        <span style="font-weight: bold; text-decoration: underline;">@cache</span>
        <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">dfs</span>(i, cur):
            <span style="font-weight: bold; font-style: italic;">res</span> = comb(n - 1, i - 1)
            <span style="font-weight: bold;">if</span> i == n:
                <span style="font-weight: bold;">return</span> res
            <span style="font-weight: bold;">for</span> j <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(cur + cur, maxValue + 1, cur):
                res += dfs(i + 1, j)
                res = res % M
            <span style="font-weight: bold;">return</span> res % M

        <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">sum</span>(dfs(1, cur) <span style="font-weight: bold;">for</span> cur <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(1, maxValue + 1)) % M


<span style="font-weight: bold;">assert</span> Solution().idealArrays(2, 5) == 10
<span style="font-weight: bold;">assert</span> Solution().idealArrays(5, 3) == 11
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
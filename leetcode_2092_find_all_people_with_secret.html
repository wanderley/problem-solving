<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Leetcode: 2092. Find All People With Secret</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="style.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<!--  --><nav><a href="index.html">Problem Solving</a></nav><div id="content" class="content">
<h1 class="title">Leetcode: 2092. Find All People With Secret</h1>
<ul class="org-ul">
<li><a href="mistake_incorrect_evaluation_of_solution_s_viability.html#ID-DA951820-DBB5-4A7F-9401-DF5860EFAB8A">Mistake: Incorrect evaluation of solution's viability</a>.  I computed the connections to person <code>0</code>, by looking to the edges that starts on person <code>0</code> component.  The problem is that it will become \(O(n^2)\) in the worst case and not \(O(m)\).</li>

<li><a href="pattern_build_graph_online.html#ID-49FB2683-60E5-4B10-B2B7-1D0B951EA1E0">Pattern: Build graph online</a>.  For each meeting time, we add all edges using <a href="union_find.html#ID-23A4E36E-24D3-40F8-AA20-32C0DB1E36F6">Union-Find</a> from the meetings to the graph and after that we remove all those edges which its vertices aren't connected to the vertex 0.</li>

<li><a href="how_can_we_extend_the_solution_for_i_to_i_1.html#ID-45B9F3C8-D007-4980-95EF-4361906245A8">How can we extend the solution for \(i\) to \(i+1\)?</a>  We are going to build the solution by time.  Group all meetings by their times.  From the earlier to the later meeting, connect the vertices (people) that met at that time.  On the end, reset the connected components other the one that has people <code>0</code> on it.  Time complexity is \(O(m)\) and space is \(O(n)\).</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> typing <span style="font-weight: bold;">import</span> List


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">findAllPeople</span>(
        <span style="font-weight: bold;">self</span>, n: <span style="font-weight: bold;">int</span>, meetings: List[List[<span style="font-weight: bold;">int</span>]], firstPerson: <span style="font-weight: bold;">int</span>
    ) -&gt; <span style="font-weight: bold; font-style: italic;">List</span>[<span style="font-weight: bold;">int</span>]:
        p = [i <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(n)]

        <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">find</span>(u):
            <span style="font-weight: bold;">if</span> p[u] != <span style="font-weight: bold; font-style: italic;">u</span>:
                p[<span style="font-weight: bold; font-style: italic;">u</span>] = find(p[u])
            <span style="font-weight: bold;">return</span> p[u]

        <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">union</span>(u, v):
            <span style="font-weight: bold; font-style: italic;">p</span>[find(u)] = p[find(v)]

        union(0, firstPerson)

        <span style="font-weight: bold; font-style: italic;">m</span> = {<span style="font-weight: bold; font-style: italic;">t</span>: [] <span style="font-weight: bold;">for</span> _, _, t <span style="font-weight: bold;">in</span> meetings}
        <span style="font-weight: bold;">for</span> u, v, t <span style="font-weight: bold;">in</span> meetings:
            m[t].append((u, v))

        <span style="font-weight: bold;">for</span> t <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">sorted</span>(m):
            vs = <span style="font-weight: bold;">set</span>()
            <span style="font-weight: bold;">for</span> u, v <span style="font-weight: bold;">in</span> <span style="font-weight: bold; font-style: italic;">m</span>[t]:
                union(u, v)
                vs.add(u)
                vs.add(v)
            <span style="font-weight: bold;">for</span> u <span style="font-weight: bold;">in</span> vs:
                <span style="font-weight: bold;">if</span> find(u) != find(0):
                    <span style="font-weight: bold; font-style: italic;">p</span>[<span style="font-weight: bold; font-style: italic;">u</span>] = u

        <span style="font-weight: bold;">return</span> [u <span style="font-weight: bold;">for</span> u <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(n) <span style="font-weight: bold;">if</span> find(u) == find(0)]


<span style="font-weight: bold;">assert</span> Solution().findAllPeople(6, [[1, 2, 5], [2, 3, 8], [1, 5, 10]], 1) == [
    0,
    1,
    2,
    3,
    5,
]
<span style="font-weight: bold;">assert</span> Solution().findAllPeople(4, [[3, 1, 3], [1, 2, 2], [0, 3, 3]], 3) == [0, 1, 3]
<span style="font-weight: bold;">assert</span> Solution().findAllPeople(5, [[3, 4, 2], [1, 2, 1], [2, 3, 1]], 1) == [
    0,
    1,
    2,
    3,
    4,
]
</pre>
</div>
</div>
</body>
</html>
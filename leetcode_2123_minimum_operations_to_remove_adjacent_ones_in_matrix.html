<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Leetcode: 2123. Minimum Operations to Remove Adjacent Ones in Matrix</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="style.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<!--  --><nav><span class="nav-header">Problem Solving</span><span class="nav-items"><a href="index.html">Home</a><span></nav><div id="content" class="content">
<h1 class="title">Leetcode: 2123. Minimum Operations to Remove Adjacent Ones in Matrix</h1>

<div id="outline-container-org2908ebb" class="outline-2">
<h2 id="org2908ebb">Understand the problem</h2>
<div class="outline-text-2" id="text-org2908ebb">
<p>
Find the minimum number of 1-cells in the grid to switch such that no other two horizontal or vertical 1-cells are adjacent.  Suppose that the grid (i.e <a href="2d_matrix.html#ID-2AC58B7A-4948-4E84-AA80-020E985D36E0">2D Matrix</a>) is colored like a chess board.  Two 1-cells can be connected only if they are in square with distinct colors.  So cells can be divided in two groups where there is no connections between cells on the same group.  Modeling as a graph problem, we can construct a graph \(G=(U, V, E)\), where \(U\) are the cells on white squares (i.e \(i \mod 2 = j \mod 2\) where \((i, j)\) is the coordinate of the cell), and \(V\) are the cells on black squares.  And the problem becomes <a href="pattern_find_minimum_vertex_cover_in_a_bipartite_graph.html#ID-E9AE0EFB-E12B-4AAB-82A5-6D9902F4741F">Pattern: Find minimum vertex cover in a bipartite graph</a>.
</p>
</div>

<div id="outline-container-orgb660b7e" class="outline-3">
<h3 id="orgb660b7e">Useful prompts</h3>
<div class="outline-text-3" id="text-orgb660b7e">
<ul class="org-ul">
<li><a href="can_we_formulate_the_problem_using_graphs.html#ID-DA1E3A63-73BB-475E-B087-128602B13450">Can we formulate the problem using graphs?</a></li>

<li><a href="can_we_formulate_the_problem_as_a_classical_problem.html#ID-1CFF662A-6F16-43CE-BB07-EA12BA382690">Can we formulate the problem as a classical problem?</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgb528c2b" class="outline-2">
<h2 id="orgb528c2b">Devise a plan</h2>
<div class="outline-text-2" id="text-orgb528c2b">
<p>
Represent the given grid as a graph and execute the algorithm to find <a href="bipartite_minimum_vertex_cover.html#ID-C65F99DB-3808-4E4F-9952-FBB343E9AB9F">Bipartite Minimum Vertex Cover</a>.
</p>
</div>

<div id="outline-container-org3d840ad" class="outline-3">
<h3 id="org3d840ad">Carry out the plan</h3>
<div class="outline-text-3" id="text-org3d840ad">
<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> typing <span style="font-weight: bold;">import</span> List


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">minimumOperations</span>(<span style="font-weight: bold;">self</span>, grid: List[List[<span style="font-weight: bold;">int</span>]]) -&gt; <span style="font-weight: bold;">int</span>:
        N = <span style="font-weight: bold;">len</span>(grid)
        <span style="font-weight: bold; font-style: italic;">M</span> = <span style="font-weight: bold;">len</span>(grid[0])

        <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">neighbours</span>(i, j):
            <span style="font-weight: bold;">for</span> di, dj <span style="font-weight: bold;">in</span> [[+0, +1], [+0, -1], [+1, +0], [-1, +0]]:
                <span style="font-weight: bold;">if</span> 0 &lt;= di + i &lt; N <span style="font-weight: bold;">and</span> 0 &lt;= dj + j &lt; M <span style="font-weight: bold;">and</span> grid[di + i][dj + j] == 1:
                    <span style="font-weight: bold;">yield</span> (di + i, dj + j)

        <span style="font-weight: bold; font-style: italic;">mt</span> = {}

        <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">dfs</span>(node, seen):
            <span style="font-weight: bold;">if</span> node <span style="font-weight: bold;">in</span> seen:
                <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">False</span>
            seen.add(node)
            <span style="font-weight: bold;">for</span> child <span style="font-weight: bold;">in</span> neighbours(*node):
                <span style="font-weight: bold;">if</span> child <span style="font-weight: bold;">not</span> <span style="font-weight: bold;">in</span> mt <span style="font-weight: bold;">or</span> dfs(mt[child], seen):
                    <span style="font-weight: bold; font-style: italic;">mt</span>[<span style="font-weight: bold; font-style: italic;">child</span>] = node
                    <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">True</span>
            <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">False</span>

        <span style="font-weight: bold; font-style: italic;">ans</span> = 0
        <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N):
            <span style="font-weight: bold;">for</span> j <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(M):
                <span style="font-weight: bold;">if</span> grid[i][j] == 1:
                    <span style="font-weight: bold;">if</span> dfs((i, j), <span style="font-weight: bold;">set</span>()):
                        <span style="font-weight: bold; font-style: italic;">ans</span> += 1

        <span style="font-weight: bold;">return</span> ans // 2


<span style="font-weight: bold;">assert</span> Solution().minimumOperations([[1, 1, 0], [0, 1, 1], [1, 1, 1]]) == 3
<span style="font-weight: bold;">assert</span> Solution().minimumOperations([[0, 1], [1, 0]]) == 0
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org523ddb9" class="outline-2">
<h2 id="org523ddb9">Common mistakes</h2>
<div class="outline-text-2" id="text-org523ddb9">
<ul class="org-ul">
<li><a href="mistake_failed_to_recognize_a_classic_problem_in_the_reduced_problem.html#ID-B3BCF738-D1F0-4705-89B2-10B66DCE8977">Mistake: Failed to recognize a classic problem in the reduced problem</a>.</li>
</ul>
</div>
</div>
</div>
</body>
</html>
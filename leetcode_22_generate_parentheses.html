<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Leetcode: 22. Generate Parentheses</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="style.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<!--  --><nav><span class="nav-header">Problem Solving</span><span class="nav-items"><a href="index.html">Home</a><span></nav><div id="content" class="content">
<h1 class="title">Leetcode: 22. Generate Parentheses</h1>
<p>
<a href="https://leetcode.com/problems/generate-parentheses/">Problem Statement</a>: Given an integer \(n\), return all well-formed parentheses string formed with \(n\) pair of parentheses.
</p>

<div id="outline-container-org72a8aad" class="outline-2">
<h2 id="org72a8aad"><a href="constructive.html#ID-F7D1B315-77B8-4556-B665-AFFD00550C1E">Constructive</a>: one parentheses at time</h2>
<div class="outline-text-2" id="text-org72a8aad">
<p>
The naive approach consist on generating all possible string (\(2^{2 \times n}=4^n\)) and filter only the ones that are well-formed.  To do better than that, we have to understand what makes a candidate ill-formed.  Let's see some examples of possible candidates for \(n=1\): <code>((</code>, <code>()</code>, <code>)(</code>, <code>))</code>.  If we compute the sum by the number of open parentheses subtracted by the number of close parentheses, we have that the <code>((</code> sums to 2 and <code>))</code> sums to -2.  The other two candidates have sum of 0, but only <code>()</code> is well-formed.  This example is enough to show that we can't compute this sum after all parentheses are in-place, but we have to filter out <code>)(</code>.  Observe that if the number of close parentheses is greater than the number of parentheses in a position \(i\), then the candidate will always be ill-formed no matter what come later (the only way to close the extra close parentheses is by an open one that come first).  So, we have to check for two conditions to construct a well-formed string: (1) the number of sum of parentheses is never negative during construction and (2) after the last parentheses the sum must be 0.
</p>

<ul class="org-ul">
<li>Time and space complexity: \(O(4^n \times n)\).</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">solve</span>(n):

    <span style="font-weight: bold; font-style: italic;">ans</span> = []

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">build</span>(s, op):
        <span style="font-weight: bold;">if</span> op &lt; 0:
            <span style="font-weight: bold;">return</span>
        <span style="font-weight: bold;">if</span> <span style="font-weight: bold;">len</span>(s) == 2 * n:
            <span style="font-weight: bold;">if</span> op == 0:
                ans.append(s)
            <span style="font-weight: bold;">return</span>
        build(s + <span style="font-style: italic;">"("</span>, op + 1)
        build(s + <span style="font-style: italic;">")"</span>, op - 1)

    build(<span style="font-style: italic;">""</span>, 0)
    <span style="font-weight: bold;">return</span> ans


<span style="font-weight: bold;">assert</span> <span style="font-weight: bold;">set</span>(solve(3)) == <span style="font-weight: bold;">set</span>([<span style="font-style: italic;">"((()))"</span>, <span style="font-style: italic;">"(()())"</span>, <span style="font-style: italic;">"(())()"</span>, <span style="font-style: italic;">"()(())"</span>, <span style="font-style: italic;">"()()()"</span>])
<span style="font-weight: bold;">assert</span> <span style="font-weight: bold;">set</span>(solve(1)) == <span style="font-weight: bold;">set</span>([<span style="font-style: italic;">"()"</span>])


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">generateParenthesis</span>(<span style="font-weight: bold;">self</span>, n: <span style="font-weight: bold;">int</span>) -&gt; List[<span style="font-weight: bold;">str</span>]:
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">list</span>(solve(n))
</pre>
</div>
</div>
</div>

<div id="outline-container-orga422acd" class="outline-2">
<h2 id="orga422acd">Combining well-formed expressions</h2>
<div class="outline-text-2" id="text-orga422acd">
<p>
A well-formed parentheses string can be represented by its parts: \(s=\texttt{(}p\texttt{)}q\), where \(0\leq|p|,|q|<|s|\) and \(|p|+|q|+2=|s|\).  As \(s\) is well-formed, follows that \(p\) and \(q\) are also well-formed.  Note that a well-formed string can't start with a close parentheses.  So, it starts with an open parentheses that can either close on the end of the string (\(|q|=0\)) or somewhere in the middle of \(s\) (\(|q|>0\)).  In both cases, \(|p|=|s|-|q|\).  The generation of well-formed strings works using this property, because all that we are saying is: (1) fix the first pair of parentheses and (2) fill it's gaps with all possible well-formed strings.
</p>

<ul class="org-ul">
<li>Time and space complexity: \(O(4^n \times n)\).</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> functools <span style="font-weight: bold;">import</span> cache


<span style="font-weight: bold; text-decoration: underline;">@cache</span>
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">solve</span>(n):
    <span style="font-weight: bold;">if</span> n == 0:
        <span style="font-weight: bold;">return</span> [<span style="font-style: italic;">""</span>]
    ans = []
    <span style="font-weight: bold;">for</span> l <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(n):
        <span style="font-weight: bold;">for</span> x <span style="font-weight: bold;">in</span> solve(l):
            <span style="font-weight: bold;">for</span> y <span style="font-weight: bold;">in</span> solve(n - l - 1):
                ans.append(f<span style="font-style: italic;">"(</span>{x}<span style="font-style: italic;">)</span>{y}<span style="font-style: italic;">"</span>)
    <span style="font-weight: bold;">return</span> ans


<span style="font-weight: bold;">assert</span> <span style="font-weight: bold;">set</span>(solve(3)) == <span style="font-weight: bold;">set</span>([<span style="font-style: italic;">"((()))"</span>, <span style="font-style: italic;">"(()())"</span>, <span style="font-style: italic;">"(())()"</span>, <span style="font-style: italic;">"()(())"</span>, <span style="font-style: italic;">"()()()"</span>])
<span style="font-weight: bold;">assert</span> <span style="font-weight: bold;">set</span>(solve(1)) == <span style="font-weight: bold;">set</span>([<span style="font-style: italic;">"()"</span>])


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">generateParenthesis</span>(<span style="font-weight: bold;">self</span>, n: <span style="font-weight: bold;">int</span>) -&gt; List[<span style="font-weight: bold;">str</span>]:
        <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">list</span>(solve(n))
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
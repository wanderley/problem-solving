<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Leetcode: 1987. Number of Unique Good Subsequences</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="style.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<!--  --><nav><span class="nav-header">Problem Solving</span><span class="nav-items"><a href="index.html">Home</a><span></nav><div id="content" class="content">
<h1 class="title">Leetcode: 1987. Number of Unique Good Subsequences</h1>
<ul class="org-ul">
<li><a href="mistake_bug_caused_by_incorrect_assumption.html#ID-298CCCF3-C9A7-4FEC-BE7B-17CF0F67332C">Mistake: Bug caused by incorrect assumption</a>.  I re-wrote part of the code, but didn't check if I had to update the other part of the code.</li>
</ul>

<p>
<a href="can_you_derive_an_invariant_based_on_the_smallest_possible_examples.html#ID-BA632D61-93B6-47AB-B11A-7E9EBE3FC71D">Can we derive an invariant based on the smallest possible examples?</a>  First, I generated all unique substrings of the string "1001" to see if a pattern emerge:
</p>

<pre class="example" id="orged2a730">
1
xxx1
2
xx0x
xx01
2
x00x
x001
5
1xx1
1x0x
1x01
100x
1001
</pre>

<p>
Let's compute \(dp[i]\) which is the number of unique subsequences starting on \(i\).  Let's do it from <b>left to right</b>.  Therefore, \(dp[N - 1]=1\).  Be \(i, j\) indexes where \(i < j\), \(binary[i]=binary[j]\) and \(binary[i] \neq binary[k]\) for \(i < k < j\).  Suppose that \(binary[i]=1\).  Note that we can extend by one all unique subsequence starting with 1 (i.e. \(binary[i]\)) and they will all be unique.  Besides that, we can also extend all subsequences starting with 0 (i.e. \(binary[i+1], binary[i+2], .., binary[j-1]\)) by one and they will all be unique.  So, in this case, \(dp[i]=dp[i+1]+dp[i+2]+...+dp[j]\).  We can't compute this sum, since \(O(n^2)\) will not make the cut.  Note that if there are no zeros between \(i\) and \(j\), \(dp[i]=dp[j]\).  This means that \(dp[i+1]=dp[i+2]=...=dp[j-1]\), since they are computed similarly to the way we compute \(dp\) for ones.  Therefore, \(dp[i]=dp[i+1] \times (j - i) + dp[j]\).  To compute \(dp\) efficiently, we can keep track of the last one and last zero and use it to compute \(dp\).  Time and space is \(O(n)\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">numberOfUniqueGoodSubsequences</span>(<span style="font-weight: bold;">self</span>, binary: <span style="font-weight: bold;">str</span>) -&gt; <span style="font-weight: bold;">int</span>:
        MOD = 10**9 + 7
        <span style="font-weight: bold; font-style: italic;">N</span> = <span style="font-weight: bold;">len</span>(binary)

        <span style="font-weight: bold; font-style: italic;">dp</span> = [0] * N
        <span style="font-weight: bold; font-style: italic;">dp</span>[N - 1] = 1
        <span style="font-weight: bold; font-style: italic;">last</span> = {}
        <span style="font-weight: bold; font-style: italic;">last</span>[<span style="font-style: italic;">"1"</span>], <span style="font-weight: bold; font-style: italic;">last</span>[<span style="font-style: italic;">"0"</span>] = (N - 1, <span style="font-weight: bold; text-decoration: underline;">None</span>) <span style="font-weight: bold;">if</span> binary[-1] == <span style="font-style: italic;">"1"</span> <span style="font-weight: bold;">else</span> (<span style="font-weight: bold; text-decoration: underline;">None</span>, N - 1)

        <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N - 2, -1, -1):
            b = binary[i]
            <span style="font-weight: bold;">if</span> last[b] <span style="font-weight: bold;">is</span> <span style="font-weight: bold; text-decoration: underline;">None</span>:
                dp[<span style="font-weight: bold; font-style: italic;">i</span>] = N - i
            <span style="font-weight: bold;">else</span>:
                <span style="font-weight: bold;">if</span> last[b] - i == 1:
                    dp[<span style="font-weight: bold; font-style: italic;">i</span>] = dp[i + 1]
                <span style="font-weight: bold;">else</span>:
                    dp[<span style="font-weight: bold; font-style: italic;">i</span>] = (dp[last[b]] + dp[i + 1] * (last[b] - i - 1)) % MOD
            last[<span style="font-weight: bold; font-style: italic;">b</span>] = i

        extra = 1 <span style="font-weight: bold;">if</span> <span style="font-style: italic;">"0"</span> <span style="font-weight: bold;">in</span> binary <span style="font-weight: bold;">else</span> 0
        <span style="font-weight: bold;">return</span> (<span style="font-weight: bold;">sum</span>(dp[i] <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N) <span style="font-weight: bold;">if</span> binary[i] == <span style="font-style: italic;">"1"</span>) + extra) % MOD


<span style="font-weight: bold;">assert</span> Solution().numberOfUniqueGoodSubsequences(<span style="font-style: italic;">"001"</span>) == 2
<span style="font-weight: bold;">assert</span> Solution().numberOfUniqueGoodSubsequences(<span style="font-style: italic;">"11"</span>) == 2
<span style="font-weight: bold;">assert</span> Solution().numberOfUniqueGoodSubsequences(<span style="font-style: italic;">"101"</span>) == 5
</pre>
</div>

<p>
<a href="how_can_we_extend_the_solution_for_i_to_i_1.html#ID-45B9F3C8-D007-4980-95EF-4361906245A8">How can we extend the solution for \(i\) to \(i+1\)?</a>  Other way to solve the problem is counting the unique subsequences from <b>left to right</b> which means that extend the unique subsequences that ended with 1 and 0 so far.  Be \(e0\) and \(e1\) the number of unique subsequences that end with zero and one respectively.  If the current number is 0, we will have all subsequences that ended with zero plus all subsequences that ended with one but now ending on zero.  So, \(e0 = e0 + e1\).  If the current number is 1, we will have the same but we have to re-add <code>1</code> to the count.  So, \(e1 = e0 + e1 + 1\).  Time complexity is \(O(n)\) and space is \(O(1)\).
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">numberOfUniqueGoodSubsequences</span>(<span style="font-weight: bold;">self</span>, binary: <span style="font-weight: bold;">str</span>) -&gt; <span style="font-weight: bold;">int</span>:
        MOD = 10**9 + 7

        <span style="font-weight: bold; font-style: italic;">count_zero</span> = <span style="font-weight: bold; text-decoration: underline;">False</span>
        <span style="font-weight: bold; font-style: italic;">e1</span> = 0
        <span style="font-weight: bold; font-style: italic;">e0</span> = 0
        <span style="font-weight: bold;">for</span> b <span style="font-weight: bold;">in</span> binary:
            <span style="font-weight: bold;">if</span> b == <span style="font-style: italic;">"0"</span>:
                e0 = (e0 + e1) % MOD
                count_zero = <span style="font-weight: bold; text-decoration: underline;">True</span>
            <span style="font-weight: bold;">else</span>:
                e1 = (e1 + e0 + 1) % MOD

        <span style="font-weight: bold;">return</span> (e1 + e0 + (1 <span style="font-weight: bold;">if</span> count_zero <span style="font-weight: bold;">else</span> 0)) % MOD


<span style="font-weight: bold;">assert</span> Solution().numberOfUniqueGoodSubsequences(<span style="font-style: italic;">"001"</span>) == 2
<span style="font-weight: bold;">assert</span> Solution().numberOfUniqueGoodSubsequences(<span style="font-style: italic;">"11"</span>) == 2
<span style="font-weight: bold;">assert</span> Solution().numberOfUniqueGoodSubsequences(<span style="font-style: italic;">"101"</span>) == 5
</pre>
</div>
</div>
</body>
</html>
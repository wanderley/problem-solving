<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Leetcode: 4. Median of Two Sorted Arrays</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="style.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<!--  --><nav><a href="index.html">Problem Solving</a></nav><div id="content" class="content">
<h1 class="title">Leetcode: 4. Median of Two Sorted Arrays</h1>

<div id="outline-container-orgf10efc4" class="outline-2">
<h2 id="orgf10efc4">Brute Force</h2>
<div class="outline-text-2" id="text-orgf10efc4">
<p>
<a href="merge_two_sorted_arrays.html#ID-1C032394-9D5B-4A8C-8ACE-21ED5B0B4838">Merge Two Sorted Arrays</a> and then compute the median from the resulting array.
</p>

<ul class="org-ul">
<li>Time complexity: \(O(|a| + |b|)\)</li>
<li>Space complexity: \(O(|a| + |b|)\)</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">def</span> <span style="font-weight: bold;">merge_sorted_arrays</span>(a, b):
    <span style="font-weight: bold; font-style: italic;">ans</span> = []
    <span style="font-weight: bold; font-style: italic;">i</span>, <span style="font-weight: bold; font-style: italic;">j</span> = 0, 0
    <span style="font-weight: bold;">while</span> i &lt; <span style="font-weight: bold;">len</span>(a) <span style="font-weight: bold;">and</span> j &lt; <span style="font-weight: bold;">len</span>(b):
        <span style="font-weight: bold;">if</span> a[i] &lt; <span style="font-weight: bold; font-style: italic;">b</span>[j]:
            ans.append(a[i])
            i += 1
        <span style="font-weight: bold;">else</span>:
            ans.append(b[j])
            j += 1
    <span style="font-weight: bold;">if</span> i &lt; <span style="font-weight: bold;">len</span>(a):
        <span style="font-weight: bold; font-style: italic;">ans</span> = ans + a[i:]
    <span style="font-weight: bold;">if</span> j &lt; <span style="font-weight: bold;">len</span>(b):
        <span style="font-weight: bold; font-style: italic;">ans</span> = ans + b[<span style="font-weight: bold; font-style: italic;">j</span>:]
    <span style="font-weight: bold;">return</span> ans

<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">naive</span>(a, b):
    m = merge_sorted_arrays(a, b)
    <span style="font-weight: bold; font-style: italic;">n</span> = <span style="font-weight: bold;">len</span>(m)
    <span style="font-weight: bold;">if</span> n % 2 == 1:
        <span style="font-weight: bold;">return</span> m[n // 2]
    <span style="font-weight: bold;">return</span> (m[n // 2 - 1] + m[n // 2]) / 2

<span style="font-weight: bold;">assert</span> naive([1, 2], [3, 4]) == 2.5
<span style="font-weight: bold;">assert</span> naive([], [1, 2, 3]) == 2
<span style="font-weight: bold;">assert</span> naive([1, 3, 5, 7], [2, 4, 6, 8]) == 4.5
</pre>
</div>
</div>
</div>

<div id="outline-container-org5bd731c" class="outline-2">
<h2 id="org5bd731c">Two binary-searches</h2>
<div class="outline-text-2" id="text-org5bd731c">
<p>
Be \(u(x)\) the count of numbers in \(b\) that are less or equal than \(x\).  With that, we could compute for each position \(i\) in \(a\) the size of the left partition which contains the values \(a[0..i]\) and \(b[0..u(a[i])]\).  The solution for the problem is to find such the position in \(a\), if it exists, that cuts the array \(a+b\) on the half.  When it isn't possible, we know that all elements of \(a\) should be part of the left partition and the problem becomes finding the index on \(b\) that cuts the whole array in the half.  The following algorithm uses one <a href="binary_search.html#ID-1217FC3D-A9F9-49EC-BA5D-A68E50338DBD">Binary-search</a> to find the position \(i\) where \(i=\lfloor\(|a|+|b|\) / 2\rfloor\), and for each candidate it uses other <a href="binary_search.html#ID-1217FC3D-A9F9-49EC-BA5D-A68E50338DBD">Binary-search</a> to compute \(u(a[i])\).
</p>

<ul class="org-ul">
<li>Time complexity: \(O(log(|a|) \times log(|b|))\)</li>
<li>Space complexity: \(O(1)\)</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> typing <span style="font-weight: bold;">import</span> List


<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">solve</span>(a, b):
    <span style="font-weight: bold; font-style: italic;">na</span>, <span style="font-weight: bold; font-style: italic;">nb</span> = <span style="font-weight: bold;">len</span>(a), <span style="font-weight: bold;">len</span>(b)
    <span style="font-weight: bold; font-style: italic;">n</span> = na + nb

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">upper_bound_index</span>(x):
        <span style="font-weight: bold; font-style: italic;">s</span>, <span style="font-weight: bold; font-style: italic;">e</span> = 0, nb - 1
        <span style="font-weight: bold;">while</span> s &lt;= <span style="font-weight: bold; font-style: italic;">e</span>:
            m = s + (e - s) // 2
            <span style="font-weight: bold;">if</span> b[m] &lt;= <span style="font-weight: bold; font-style: italic;">x</span>:
                s = m + 1
            <span style="font-weight: bold;">else</span>:
                e = m - 1
        <span style="font-weight: bold;">return</span> s

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">get</span>(i):
        <span style="font-style: italic;">"""Return the value of element at position i on the sorted a + b"""</span>
        <span style="font-weight: bold; font-style: italic;">s</span>, <span style="font-weight: bold; font-style: italic;">e</span> = 0, na - 1
        <span style="font-weight: bold;">while</span> s &lt;= <span style="font-weight: bold; font-style: italic;">e</span>:
            m = s + (e - s) // 2
            <span style="font-weight: bold; font-style: italic;">cb</span> = upper_bound_index(a[m])
            <span style="font-weight: bold;">if</span> m + cb == i:
                <span style="font-weight: bold;">return</span> a[m]
            <span style="font-weight: bold;">elif</span> m + cb &lt; i:
                s = m + 1
            <span style="font-weight: bold;">elif</span> m + cb &gt; i:
                e = m - 1
        <span style="font-weight: bold;">if</span> s == na:
            <span style="font-weight: bold;">return</span> b[i - na]
        <span style="font-weight: bold;">if</span> s + upper_bound_index(a[s]) == i:
            <span style="font-weight: bold;">return</span> a[s]
        <span style="font-weight: bold;">return</span> b[i - s]

    <span style="font-weight: bold;">if</span> n % 2 == 1:
        <span style="font-weight: bold;">return</span> get(n // 2)
    <span style="font-weight: bold;">return</span> (get(n // 2 - 1) + get(n // 2)) / 2


<span style="font-weight: bold;">assert</span> solve([1, 3, 5, 7], [2, 4, 6, 8]) == 4.5
<span style="font-weight: bold;">assert</span> solve([], [1, 2, 3]) == 2
<span style="font-weight: bold;">assert</span> solve([1, 2, 3], []) == 2
<span style="font-weight: bold;">assert</span> solve([1, 3], [2]) == 2
<span style="font-weight: bold;">assert</span> solve([1, 2], [3, 4]) == 2.5


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">findMedianSortedArrays</span>(<span style="font-weight: bold;">self</span>, nums1: List[<span style="font-weight: bold;">int</span>], nums2: List[<span style="font-weight: bold;">int</span>]) -&gt; <span style="font-weight: bold;">float</span>:
        <span style="font-weight: bold;">return</span> solve(nums1, nums2)


<span style="font-weight: bold;">assert</span> Solution().findMedianSortedArrays([1, 3], [2]) == 2
</pre>
</div>
</div>
</div>

<div id="outline-container-orgae0f30a" class="outline-2">
<h2 id="orgae0f30a"><span class="todo TODO">TODO</span> Write algorithm \(O(log(|a|+|b|))\)</h2>
<div class="outline-text-2" id="text-orgae0f30a">
<p>
The above <code>upper_bound_index</code> function is not necessary, since if \(a[x + k / 2 - 1] < b[y + k / 2 - 1]\) where \(k\) is an index in the merged sorted arrays, and \(x\) and \(y\) are indexes on \(a\) and \(b\) respectively, then we know that \(a[0..(x + k / 2 - 1)]\) are in the left partition.  Otherwise, we know that \(b[y..(y + k / 2 - 1)]\) are in the left partition.  In both cases, we discovered \(k/2\) elements of the left partition.  We can continue the process until there is no more elements in the left partition to find what gives us the searched element.  (<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2496/Concise-JAVA-solution-based-on-Binary-Search">Reference Implementation</a>)
</p>
</div>
</div>

<div id="outline-container-org192600f" class="outline-2">
<h2 id="org192600f">Resources</h2>
<div class="outline-text-2" id="text-org192600f">
<ul class="org-ul">
<li><a href="https://www.youtube.com/watch?v=LPFhl65R7ww">Tushar Roy's Binary Search : Median of two sorted arrays of different sizes</a></li>
</ul>
</div>
</div>


<div id="outline-container-orgf18e96f" class="outline-2">
<h2 id="orgf18e96f">Cited by 1</h2>
<div class="outline-text-2" id="text-orgf18e96f">
<ul class="org-ul">
<li><a href="array.html#ID-21C2B5E5-78D0-4A47-B69E-7B1FBA6A69A1">Array</a></li>
</ul>
</div>
</div>
</div>
</body>
</html>
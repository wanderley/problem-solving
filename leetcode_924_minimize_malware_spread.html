<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Leetcode: 924. Minimize Malware Spread</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="style.css">
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<!--  --><nav><span class="nav-header">Problem Solving</span><span class="nav-items"><a href="index.html">Home</a><span></nav><div id="content" class="content">
<h1 class="title">Leetcode: 924. Minimize Malware Spread</h1>
<ul class="org-ul">
<li><a href="blackbox_this_is_a_variation_of_a_classic_problem.html#ID-EEDBE877-7C4A-4D0B-BA6B-EFDF9288B78C">Blackbox: This is a variation of a classic problem</a>: find bridges on graphs.  But it turned out that my intuition was wrong.  After reading the problem again, I noticed that we have to find the connected components instead.</li>

<li><a href="pattern_find_optimal_component_in_graph.html#ID-693ED7C4-4F2D-4AD1-8326-AB6C2D6D9BE6">Pattern: Find optimal component in graph</a>.  The answer is the component using <a href="depth_first_search.html#ID-212DBFC3-FE3C-493E-86A6-42FF3F82CD53">Depth-first search</a> or <a href="union_find.html#ID-23A4E36E-24D3-40F8-AA20-32C0DB1E36F6">Union-Find</a> with maximum number of vertices that doesn't not contain other initial vertex, otherwise it is the initial vertex with smallest index.  Time complexity is \(O(n^2)\) with space \(O(n)\).</li>

<li><a href="can_we_formulate_the_problem_as_a_classical_problem.html#ID-1CFF662A-6F16-43CE-BB07-EA12BA382690">Can we formulate the problem as a classical problem?</a>  Find <a href="connected_components_in_a_graph.html#ID-367C887D-3517-4AC8-8219-293AC0E77E07">Connected Components in a Graph</a> and pick the one that contains only one initial vertices and has maximum size or the smaller initial vertices id.  Time complexity is \(O(n^2)\) and space is \(O(n)\).</li>
</ul>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> typing <span style="font-weight: bold;">import</span> List


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">minMalwareSpread</span>(<span style="font-weight: bold;">self</span>, graph: List[List[<span style="font-weight: bold;">int</span>]], initial: List[<span style="font-weight: bold;">int</span>]) -&gt; <span style="font-weight: bold;">int</span>:
        N = <span style="font-weight: bold;">len</span>(graph)
        <span style="font-weight: bold; font-style: italic;">vis</span> = [<span style="font-weight: bold; text-decoration: underline;">None</span>] * N
        <span style="font-weight: bold; font-style: italic;">comp_size</span> = [0] * N
        <span style="font-weight: bold; font-style: italic;">initial</span> = <span style="font-weight: bold;">set</span>(initial)

        <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">dfs</span>(u, p):
            <span style="font-weight: bold;">for</span> v <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N):
                <span style="font-weight: bold;">if</span> graph[u][v] == 1 <span style="font-weight: bold;">and</span> vis[v] <span style="font-weight: bold;">is</span> <span style="font-weight: bold; text-decoration: underline;">None</span>:
                    vis[v] = p
                    <span style="font-weight: bold; font-style: italic;">comp_size</span>[p] += 1
                    dfs(v, p)

        <span style="font-weight: bold;">for</span> u <span style="font-weight: bold;">in</span> <span style="font-weight: bold; font-style: italic;">initial</span>:
            <span style="font-weight: bold;">if</span> vis[u] <span style="font-weight: bold;">is</span> <span style="font-weight: bold; text-decoration: underline;">None</span>:
                vis[u] = u
                <span style="font-weight: bold; font-style: italic;">comp_size</span>[u] += 1
                dfs(u, u)

        <span style="font-weight: bold; font-style: italic;">comp_initial</span> = [0] * N
        <span style="font-weight: bold;">for</span> u <span style="font-weight: bold;">in</span> <span style="font-weight: bold; font-style: italic;">initial</span>:
            comp_initial[vis[u]] += 1

        <span style="font-weight: bold; font-style: italic;">ans</span> = <span style="font-weight: bold; text-decoration: underline;">None</span>
        <span style="font-weight: bold;">for</span> u <span style="font-weight: bold;">in</span> <span style="font-weight: bold; font-style: italic;">initial</span>:
            improve = 0 <span style="font-weight: bold;">if</span> comp_initial[vis[u]] &gt; 1 <span style="font-weight: bold;">else</span> comp_size[vis[u]]
            <span style="font-weight: bold;">if</span> ans <span style="font-weight: bold;">is</span> <span style="font-weight: bold; text-decoration: underline;">None</span> <span style="font-weight: bold;">or</span> ans[1] &lt; improve <span style="font-weight: bold;">or</span> (ans[1] == improve <span style="font-weight: bold;">and</span> ans[0] &gt; u):
                ans = (u, improve)

        <span style="font-weight: bold;">return</span> ans[0] <span style="font-weight: bold;">if</span> ans <span style="font-weight: bold;">else</span> 0


<span style="font-weight: bold;">assert</span> Solution().minMalwareSpread([[1, 1, 0], [1, 1, 0], [0, 0, 1]], [0, 1]) == 0
<span style="font-weight: bold;">assert</span> Solution().minMalwareSpread([[1, 0, 0], [0, 1, 0], [0, 0, 1]], [0, 2]) == 0
<span style="font-weight: bold;">assert</span> Solution().minMalwareSpread([[1, 1, 1], [1, 1, 1], [1, 1, 1]], [1, 2]) == 1
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span style="font-weight: bold;">from</span> typing <span style="font-weight: bold;">import</span> List


<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Solution</span>:
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">minMalwareSpread</span>(<span style="font-weight: bold;">self</span>, graph: List[List[<span style="font-weight: bold;">int</span>]], initial: List[<span style="font-weight: bold;">int</span>]) -&gt; <span style="font-weight: bold;">int</span>:
        N = <span style="font-weight: bold;">len</span>(graph)
        initial.sort()

        <span style="font-weight: bold; font-style: italic;">p</span> = [i <span style="font-weight: bold;">for</span> i <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N)]

        <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">find</span>(u):
            <span style="font-weight: bold;">if</span> p[u] != <span style="font-weight: bold; font-style: italic;">u</span>:
                p[<span style="font-weight: bold; font-style: italic;">u</span>] = find(p[u])
            <span style="font-weight: bold;">return</span> p[u]

        <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">union</span>(u, v):
            <span style="font-weight: bold; font-style: italic;">p</span>[find(u)] = p[find(v)]

        <span style="font-weight: bold; font-style: italic;">ans</span> = <span style="font-weight: bold; text-decoration: underline;">None</span>
        <span style="font-weight: bold;">for</span> u <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N):
            <span style="font-weight: bold;">for</span> v <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(u + 1, N):
                <span style="font-weight: bold;">if</span> graph[u][v]:
                    union(u, v)

        <span style="font-weight: bold; font-style: italic;">s</span> = [0] * N
        <span style="font-weight: bold;">for</span> u <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(N):
            <span style="font-weight: bold; font-style: italic;">s</span>[find(u)] += 1

        <span style="font-weight: bold; font-style: italic;">ans</span> = <span style="font-weight: bold; text-decoration: underline;">None</span>
        <span style="font-weight: bold;">for</span> u <span style="font-weight: bold;">in</span> initial:
            <span style="font-weight: bold;">if</span> <span style="font-weight: bold;">all</span>(p[find(u)] != p[find(v)] <span style="font-weight: bold;">for</span> v <span style="font-weight: bold;">in</span> initial <span style="font-weight: bold;">if</span> u != v):
                <span style="font-weight: bold;">if</span> ans <span style="font-weight: bold;">is</span> <span style="font-weight: bold; text-decoration: underline;">None</span> <span style="font-weight: bold;">or</span> s[find(ans)] &lt; s[find(u)]:
                    ans = u
        <span style="font-weight: bold;">return</span> ans <span style="font-weight: bold;">if</span> ans <span style="font-weight: bold;">is</span> <span style="font-weight: bold;">not</span> <span style="font-weight: bold; text-decoration: underline;">None</span> <span style="font-weight: bold;">else</span> initial[0]
</pre>
</div>
</div>
</body>
</html>
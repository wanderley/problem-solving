:PROPERTIES:
:ID:       CCE8B891-5B15-4840-ACCA-7BB744804150
:END:
#+TITLE: Practice #022: Leetcode Hard Problems

* Leetcode: 42. Trapping Rain Water
:PROPERTIES:
:ID:       08B1CF58-22CC-4634-B230-96D578138B73
:WA: 1
:END:
:LOGBOOK:
CLOCK: [2022-07-11 Mon 21:56]--[2022-07-11 Mon 22:41] =>  0:45
:END:
[[https://leetcode.com/problems/trapping-rain-water/][Problem Statement]]

[[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  There is nothing to do if we have just one or two walls.  With three walls $h_1, h_2$ and $h_3$, there is no water trapped if $h_1<h_2<h_3$ or $h_1>h_2>h_3$, but there is water trapped if $h_1>h_2$ and $h_3>h_2$.  In the last case, we can compute the amount of water trapped $(\min(h_3,h_1) - h_2) \times (i_3 - i_1 - 1)$.  After that, we can remove $a_2$, add $a_3$ and continue the process with the next height.  We can use [[id:E4CFDB04-DCFD-47E3-9ED2-0DC6446420B5][Monotonic Stack]] to keep track of the heights and solve the problem in time and space $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def trap(self, height: List[int]) -> int:
          N = len(height)
          stack = []
          ans = 0
          print()
          for i in range(N):
              while len(stack) > 0 and height[stack[-1]] < height[i]:
                  j = stack.pop()
                  if len(stack) > 0:
                      cur = (min(height[stack[-1]], height[i]) - height[j]) * (
                          i - stack[-1] - 1
                      )
                      ans += cur
              stack.append(i)
          return ans


  assert Solution().trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6
  assert Solution().trap([4, 2, 0, 3, 2, 5]) == 9
#+end_src

* Leetcode: 68. Text Justification
:PROPERTIES:
:ID:       7CACB161-1117-4C63-AF27-9537365BECC4
:WA: 0
:END:
:LOGBOOK:
CLOCK: [2022-07-12 Tue 10:42]--[2022-07-12 Tue 11:11] =>  0:29
:END:
[[https://leetcode.com/problems/text-justification/][Problem Statement]]

[[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  The smaller parts are (1) split the list on the words on each line, (2) justify one line and (3) left-justify one line.  Time and space complexity is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
          def justify(line):
              if len(line) == 1:
                  return line[0] + (" " * (maxWidth - len(line[0])))

              s = sum(map(len, line))
              ans = ""
              g = len(line) - 1
              e = (maxWidth - s) // g
              x = maxWidth - s - e * g
              for i, w in enumerate(line):
                  if i > 0:
                      ans += " " * e
                      ans += " " if x > 0 else ""
                      x -= 1
                  ans += w
              return ans

          def align_left(line):
              l = " ".join(line)
              l = l + (" " * (maxWidth - len(l)))
              return l

          lines = []
          line = []
          line_len = 0
          for w in words:
              new_line_len = line_len + (1 if line_len > 0 else 0) + len(w)
              if new_line_len > maxWidth:
                  lines.append(line)
                  line = []
                  line_len = 0
                  new_line_len = len(w)

              line.append(w)
              line_len = new_line_len

          if len(line) > 0:
              lines.append(line)

          return list(map(justify, lines[0:-1])) + [align_left(lines[-1])]


  assert Solution().fullJustify(
      ["This", "is", "an", "example", "of", "text", "justification."], 16
  ) == ["This    is    an", "example  of text", "justification.  "]
  assert Solution().fullJustify(
      ["What", "must", "be", "acknowledgment", "shall", "be"], 16
  ) == ["What   must   be", "acknowledgment  ", "shall be        "]
  assert Solution().fullJustify(
      [
          "Science",
          "is",
          "what",
          "we",
          "understand",
          "well",
          "enough",
          "to",
          "explain",
          "to",
          "a",
          "computer.",
          "Art",
          "is",
          "everything",
          "else",
          "we",
          "do",
      ],
      20,
  ) == [
      "Science  is  what we",
      "understand      well",
      "enough to explain to",
      "a  computer.  Art is",
      "everything  else  we",
      "do                  ",
  ]
#+end_src

* Leetcode: 588. Design In-Memory File System
:PROPERTIES:
:ID:       A65AAAF2-0F96-47F8-9A90-8F40324C00D3
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-12 Tue 11:19]--[2022-07-12 Tue 12:00] =>  0:41
:END:
[[https://leetcode.com/problems/design-in-memory-file-system/][Problem Statement]]

Use [[id:5BC30FCA-3402-4DA7-89D9-7661FEBDA3A7][Trie]] to represent the directory and file paths.  Time complexity is $O(p)$ to find a node (for ~mkdir~, ~write~ and ~read~) where $p$ is the length of the path, $O(p + P)$ for ~ls~ where the $P$ is the sum of length of all nodes in a sub-path.

#+begin_src python
  import string

  class FileSystem:

      def __init__(self):
          self.root = {"directory": True, "/": {}}

      def ls(self, path: str) -> List[str]:
          node = self._get_node(path)
          if "file" in node:
              return [path.split("/")[-1]]

          node = node["/"]
          ans = []

          def dfs(node, name):
              if "file" in node or "directory" in node:
                  ans.append(name)
              for c in string.ascii_lowercase:
                  if c in node:
                      dfs(node[c], name + c)

          dfs(node, "")
          return ans

      def mkdir(self, path: str) -> None:
          node = self._get_node(path)
          node["directory"] = True
          node["/"] = {}

      def addContentToFile(self, filePath: str, content: str) -> None:
          node = self._get_node(filePath)
          node["file"] = True
          node["content"] = node.get("content", "") + content

      def readContentFromFile(self, filePath: str) -> str:
          return self._get_node(filePath).get("content", "")

      def _get_node(self, path):
          if path == "/":
              return self.root
          node = self.root
          for c in path:
              if c not in node:
                  node[c] = {}
              if c == "/":
                  node["directory"] = True
              node = node[c]
          return node


  # Your FileSystem object will be instantiated and called as such:
  # obj = FileSystem()
  # param_1 = obj.ls(path)
  # obj.mkdir(path)
  # obj.addContentToFile(filePath,content)
  # param_4 = obj.readContentFromFile(filePath)
#+end_src

* Leetcode: 273. Integer to English Words
:PROPERTIES:
:ID:       D1635740-9FA0-4CE2-8DA3-6813C8752564
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-12 Tue 14:30]--[2022-07-12 Tue 15:28] =>  0:58
:END:
[[https://leetcode.com/problems/integer-to-english-words/][Problem Statement]]

[[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  This is not a question about efficiently, but if you can organize the solution in a handleable way.

#+begin_src python
  class Solution:
      def numberToWords(self, num: int) -> str:
          if num == 0:
              return "Zero"

          up_to_19 = {
              0: "Zero",
              1: "One",
              2: "Two",
              3: "Three",
              4: "Four",
              5: "Five",
              6: "Six",
              7: "Seven",
              8: "Eight",
              9: "Nine",
              10: "Ten",
              11: "Eleven",
              12: "Twelve",
              13: "Thirteen",
              14: "Fourteen",
              15: "Fifteen",
              16: "Sixteen",
              17: "Seventeen",
              18: "Eighteen",
              19: "Nineteen",
          }

          ty = {
              2: "Twenty",
              3: "Thirty",
              4: "Forty",
              5: "Fifty",
              6: "Sixty",
              7: "Seventy",
              8: "Eighty",
              9: "Ninety",
          }

          def w3d(a, b, c):
              num = a * 100 + b * 10 + c
              ans = ""
              if num == 0:
                  return ""
              elif num < 20:
                  ans += up_to_19[num]
              elif num < 100:
                  ans += ty[b]
                  res = w3d(0, 0, c)
                  if res != "":
                      ans += " " + res
              else:
                  ans += up_to_19[a] + " Hundred"
                  res = w3d(0, b, c)
                  if res != "":
                      ans += " " + res
              return ans

          g = ["", " Thousand ", " Million ", " Billion "]
          digits = list(map(int, str(num)))
          while len(digits) % 3 != 0:
              digits = [0] + digits
          k = 0
          N = len(digits)
          ans = ""
          for i in range(N - 3, -1, -3):
              a = digits[i]
              b = digits[i + 1]
              c = digits[i + 2]
              if a * 100 + b * 10 + c > 0:
                  cur = w3d(a, b, c)
                  ans = w3d(a, b, c) + g[k] + ans
              k += 1

          return ans.strip().replace("  ", " ")


  assert Solution().numberToWords(123) == "One Hundred Twenty Three"
  assert Solution().numberToWords(12345) == "Twelve Thousand Three Hundred Forty Five"
  assert (
      Solution().numberToWords(1234567)
      == "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
  )
#+end_src

* Leetcode: 716. Max Stack
:PROPERTIES:
:ID:       8BC92BDE-2E5B-47AB-A3DF-FE3866E3E424
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-12 Tue 16:17]--[2022-07-12 Tue 17:03] =>  0:46
:END:
[[https://leetcode.com/problems/max-stack/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]]
- [[id:3D263A82-52AE-4C90-830D-C533ABAFFF3E][Mistake: Missing required invariants]]

The source is in [[id:A0500087-56D9-4D34-936F-E8E3912C4761][Max Stack]] since it might be useful in other problems.  It was implemented with a stack to efficiently reply to ~pop~ and ~top~, a heap for ~peekMax~ and ~popMax~.  While ~top~ is $O(1)$, all other operations are $O(\log n)$.

* Leetcode: 1948. Delete Duplicate Folders in System
:PROPERTIES:
:ID:       4488F27D-F20C-46A4-AD00-771BEBB8CCD8
:WA:       4
:END:
:LOGBOOK:
CLOCK: [2022-07-13 Wed 10:20]--[2022-07-13 Wed 10:59] =>  0:39
CLOCK: [2022-07-13 Wed 08:49]--[2022-07-13 Wed 08:55] =>  0:06
CLOCK: [2022-07-12 Tue 22:00]--[2022-07-12 Tue 23:07] =>  1:07
CLOCK: [2022-07-12 Tue 17:53]--[2022-07-12 Tue 18:30] =>  0:37
:END:
[[https://leetcode.com/problems/delete-duplicate-folders-in-system/][Problem Statement]]

- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]]: Coded a more complex and /wrong/ solution using hashes to avoid time limit when the simple solution was enough.

[[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  Imagine that we can assign an *id* for each subtree where different subtrees have different numbers and equivalent subtrees have the same number.  The problem becomes filtering all subtrees with duplicated id.  For this problem, the id can be a serialization of the subtree like one generated by a pre-order traversing of the tree.  Time complexity is $O(n)$ where $n$ is the number of nodes in the tree.

#+begin_src python
  from typing import List


  class Solution:
      def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
          root = {}
          for p in paths:
              node = root
              for d in p:
                  node.setdefault(d, {})
                  node = node[d]

          groups = {}

          def serialize(root):
              ans = []
              for node in sorted(root):
                  ans.append((node, serialize(root[node])))
              ans = tuple(ans)

              groups.setdefault(ans, [])
              groups[ans].append(root)
              root["__s__"] = ans

              return ans

          serialize(root)

          ans = []

          def dfs(root, path):
              if len(groups[root["__s__"]]) > 1 and len(root) > 1:
                  return

              ans.append(path[:])
              for node in root:
                  if node == "__s__":
                      continue
                  path.append(node)
                  dfs(root[node], path)
                  path.pop()

          dfs(root, [])

          return ans[1:]


  assert Solution().deleteDuplicateFolder(
      [["a"], ["c"], ["d"], ["a", "b"], ["c", "b"], ["d", "a"]]
  ) == [["d"], ["d", "a"]]
  assert Solution().deleteDuplicateFolder(
      [
          ["a"],
          ["c"],
          ["a", "b"],
          ["c", "b"],
          ["a", "b", "x"],
          ["a", "b", "x", "y"],
          ["w"],
          ["w", "y"],
      ]
  ) == [["a"], ["a", "b"], ["c"], ["c", "b"]]
  assert Solution().deleteDuplicateFolder([["a", "b"], ["c", "d"], ["c"], ["a"]]) == [
      ["a"],
      ["a", "b"],
      ["c"],
      ["c", "d"],
  ]
#+end_src

* Leetcode: 23. Merge k Sorted Lists
:PROPERTIES:
:ID:       02D2E665-4FC5-45C7-A1BF-E7CE82E67B05
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-13 Wed 11:23]--[2022-07-13 Wed 11:36] =>  0:13
:END:
[[https://leetcode.com/problems/merge-k-sorted-lists/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]]: Had to fix my code multiple times since the input and output didn't match the problem's expectations.

#+begin_src python
  # Definition for singly-linked list.
  # class ListNode:
  #     def __init__(self, val=0, next=None):
  #         self.val = val
  #         self.next = next
  class Solution:
      def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
          pq = []
          for i, l in enumerate(lists):
              if l:
                  heappush(pq, (l.val, i))

          ans = None
          last = None
          while len(pq) > 0:
              v, i = heappop(pq)
              if ans is None:
                  ans = lists[i]
                  last = lists[i]
              else:
                  last.next = lists[i]
                  last = lists[i]

              if lists[i].next:
                  heappush(pq, (lists[i].next.val, i))
                  lists[i] = lists[i].next
          return ans

#+end_src

* Leetcode: 1293. Shortest Path in a Grid with Obstacles Elimination
:PROPERTIES:
:ID:       4416AFE9-6BB7-4AF8-9F85-68BAE35D4717
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-13 Wed 11:51]--[2022-07-13 Wed 12:14] =>  0:23
:END:
[[https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/][Problem Statement]]

- [[id:8E8E98F9-335A-4279-B523-549FD9025A0C][Mistake: Picked the wrong data structure]]:  A priority queue was unnecessary to solve the problem.

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Yes.  The problem becomes do a [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] starting from node $(0, 0)$ and ending on $(n-1, m-1)$.  Time and space complexity is $O(N \times M \times K)$.

#+begin_src python
  from typing import List


  class Solution:
      def shortestPath(self, grid: List[List[int]], k: int) -> int:
          N = len(grid)
          M = len(grid[0])

          queue = []
          vis = [[[False] * (k + 1) for _ in range(M)] for _ in range(N)]

          queue.append((0, 1 if grid[0][0] == 1 else 0, 0, 0))
          for d, c, i, j in queue:
              if c > k:
                  continue
              if vis[i][j][c]:
                  continue
              vis[i][j][c] = True

              if i == N - 1 and j == M - 1:
                  return d

              for di, dj in [[+0, +1], [+0, -1], [+1, +0], [-1, +0]]:
                  nd = d + 1
                  nc = c + (1 if grid[i][j] == 1 else 0)
                  if 0 <= di + i < N and 0 <= dj + j < M and nc <= k:
                      queue.append((nd, nc, di + i, dj + j))

          return -1


  assert (
      Solution().shortestPath([[0, 0, 0], [1, 1, 0], [0, 0, 0], [0, 1, 1], [0, 0, 0]], 1)
      == 6
  )
  assert Solution().shortestPath([[0, 1, 1], [1, 1, 1], [1, 0, 0]], 1) == -1
#+end_src

* Leetcode: 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix
:PROPERTIES:
:ID:       76B022D8-9C12-4415-AFDD-837067EC49DD
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-13 Wed 14:04]--[2022-07-13 Wed 14:29] =>  0:25
:END:
[[https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]]: Missed that I could also flip cells with 0.

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Each possible configuration of the binary matrix is a node in the graph, and two node are adjacent with a flip in one will generate the other.  The problem becomes do a [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] from the initial node to the node representing a zero matrix.  Time and space complexity is $O(n \times m \times 2^{n \times m})$.

#+begin_src python
  from typing import List


  class Solution:
      def minFlips(self, mat: List[List[int]]) -> int:
          N = len(mat)
          M = len(mat[0])

          def id(i, j):
              return 1 << (i * M + j)

          initial = 0
          for i in range(N):
              for j in range(M):
                  if mat[i][j] == 1:
                      initial = initial | id(i, j)

          seen = set()
          queue = [(0, initial)]

          for steps, state in queue:
              if state == 0:
                  return steps
              if state in seen:
                  continue
              seen.add(state)

              for i in range(N):
                  for j in range(M):
                      nstate = state
                      for di, dj in [[+0, +0], [+0, +1], [+0, -1], [+1, +0], [-1, +0]]:
                          if 0 <= di + i < N and 0 <= dj + j < M:
                              if nstate & id(di + i, dj + j) != 0:
                                  nstate = nstate & ~id(di + i, dj + j)
                              else:
                                  nstate = nstate | id(di + i, dj + j)
                      queue.append((steps + 1, nstate))
          return -1


  assert Solution().minFlips([[0, 0], [0, 1]]) == 3
  assert Solution().minFlips([[0]]) == 0
  assert Solution().minFlips([[1, 0, 0], [1, 0, 0]]) == -1
#+end_src

* Leetcode: 2123. Minimum Operations to Remove Adjacent Ones in Matrix
:PROPERTIES:
:ID:       DACEB904-5675-42F2-89E7-733320BE0751
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-13 Wed 18:45]--[2022-07-13 Wed 19:14] =>  0:29
CLOCK: [2022-07-13 Wed 17:30]--[2022-07-13 Wed 18:33] =>  1:03
CLOCK: [2022-07-13 Wed 15:31]--[2022-07-13 Wed 16:50] =>  1:19
:END:
[[https://leetcode.com/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/][Problem Statement]]

- [[id:B3BCF738-D1F0-4705-89B2-10B66DCE8977][Mistake: Failed to recognize a classic problem in the reduced problem]].

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  The 1-cells are vertices and an edge exists if two adjacent cells (left, right, top and down) are 1-cells.  This graph is a [[id:F1D5D810-3FDF-45C3-BAF1-68584BD77DB3][Bipartite Graph]] and the problem becomes finding the [[id:A293CEDD-F976-4FA2-97F3-02DF918E73B1][Minimum vertex cover problem]] which is equivalent to [[id:2BFB9CF6-4D77-4753-88E1-B4BDF9BED66B][Maximum Bipartite Matching]] in such graphs.

#+begin_src python
  from typing import List


  class Solution:
      def minimumOperations(self, grid: List[List[int]]) -> int:
          N = len(grid)
          M = len(grid[0])

          def neighbours(i, j):
              for di, dj in [[+0, +1], [+0, -1], [+1, +0], [-1, +0]]:
                  if 0 <= di + i < N and 0 <= dj + j < M and grid[di + i][dj + j] == 1:
                      yield (di + i, dj + j)

          mt = {}

          def dfs(node, seen):
              if node in seen:
                  return False
              seen.add(node)
              for child in neighbours(*node):
                  if child not in mt or dfs(mt[child], seen):
                      mt[child] = node
                      return True
              return False

          ans = 0
          for i in range(N):
              for j in range(M):
                  if grid[i][j] == 1:
                      if dfs((i, j), set()):
                          ans += 1

          return ans // 2


  assert Solution().minimumOperations([[1, 1, 0], [0, 1, 1], [1, 1, 1]]) == 3
  assert Solution().minimumOperations([[0, 1], [1, 0]]) == 0
#+end_src

* Leetcode: 828. Count Unique Characters of All Substrings of a Given String
:PROPERTIES:
:ID:       1289D944-3EE5-4270-8F29-69047B204213
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-14 Thu 09:20]--[2022-07-14 Thu 09:57] =>  0:37
CLOCK: [2022-07-13 Wed 21:49]--[2022-07-13 Wed 21:52] =>  0:03
CLOCK: [2022-07-13 Wed 21:30]--[2022-07-13 Wed 21:40] =>  0:10
CLOCK: [2022-07-13 Wed 20:18]--[2022-07-13 Wed 21:21] =>  1:03
CLOCK: [2022-07-13 Wed 19:25]--[2022-07-13 Wed 19:32] =>  0:07
:END:
[[https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]]
- [[id:298CCCF3-C9A7-4FEC-BE7B-17CF0F67332C][Mistake: Bug caused by incorrect assumption]]
- [[id:56B18554-8EDB-44AF-B72A-8FD307B2980C][Mistake: High constant factor in the implementation]]

[[id:26656051-E32D-42FE-9315-05ADB46A1A82][Can we reuse or extend a solution from a sub-problem to solve the next sub-problem more efficiently?]]  Let $f(i)=\sum_{i \leq j < n} countUniqueChars(j)$ the function that we want to compute efficiently.  Be $i$ the first index from the left to right that is duplicated, and $j$ an index where $s[i]=s[j]$ and $i<j$.  We know that $f(i+1)=1+2+3+..+(n-i-1)$ since there is no duplicates and all letters in all substrings are counted.  All substring starting on $i+1$ and ending on $i+1,i+2,..,j-1$ will count one more letter when extend to $i$.  All substring starting on $i+1$ and ending on $j, j+1, ..., n$ will not count one when extended.  So, $f(i)=f(i+1) + (j - i)$.  Now, suppose that $s[i]$ is the third occurence of $s[i]$ from left to right.  Be $k$ an index where $s[i]=s[k]$ and $j<k$.  In this case, $f(i)= f(i+1) + (j - i) - (k - j)$, since all substrings starting on $i+1$ and ending on $k$ will not contribute to the sum of count of unique chars anymore.  Time and space complexity is $O(n)$.

#+begin_src python
  class Solution:
      def uniqueLetterString(self, s: str) -> int:
          N = len(s)

          nxt = {}
          last = {}
          for c in set(s):
              last[c] = N
              nxt[N, c] = N

          for i in range(N - 1, -1, -1):
              nxt[i, s[i]] = last[s[i]]
              last[s[i]] = i

          ans = 0
          cur = 0
          for i in range(N - 1, -1, -1):
              j = nxt[i, s[i]]
              k = nxt[j, s[i]]
              cur += (j - i) - (k - j)
              ans += cur
          return ans


  assert Solution().uniqueLetterString("ABC") == 10
  assert Solution().uniqueLetterString("ABA") == 8
  assert Solution().uniqueLetterString("LEETCODE") == 92
#+end_src

* Leetcode: 127. Word Ladder
:PROPERTIES:
:ID:       6EB17048-DA8B-443F-A28A-630DF77246B6
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-14 Thu 10:45]--[2022-07-14 Thu 11:02] =>  0:17
:END:
[[https://leetcode.com/problems/word-ladder/][Problem Statement]]

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Words are vertices and two words that match the problem's constraints are connected by an edge.  [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Find the shortest path ~beginWord~ to ~endWord~ using a [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]], and computing the edges in an efficient way since $O(n^2 \times 10)$ won't make the cut.  [[id:638547C6-7305-4AA8-A57B-D570C1C323DD][Can we first generate all candidates and then pick the best one?]]  For a given word, we can generate all possible transformations and create the edge with only the ones that appear in the dictionary.  This can be done in $O(n \times 250)$ since the max length is 10 and there are 25 different letter to try in each position.  Time and space complexity is $O(n)$.

#+begin_src python
  from typing import List
  import string


  class Solution:
      def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
          W = set(wordList)
          L = set(beginWord)
          for w in W:
              for c in w:
                  L.add(c)

          def adj(s):
              for i in range(len(s)):
                  for c in string.ascii_lowercase:
                      if c != s[i]:
                          nw = s[0:i] + c + s[i + 1 :]
                          if nw in W:
                              yield nw

          queue = [(0, beginWord)]
          seen = set()
          for steps, u in queue:
              if u == endWord:
                  return steps + 1
              if u in seen:
                  continue
              seen.add(u)

              for v in adj(u):
                  if v not in seen:
                      queue.append((steps + 1, v))

          return 0


  assert (
      Solution().ladderLength("hit", "cog", ["hot", "dot", "dog", "lot", "log", "cog"])
      == 5
  )
  assert Solution().ladderLength("hit", "cog", ["hot", "dot", "dog", "lot", "log"]) == 0
#+end_src

* Leetcode: 1675. Minimize Deviation in Array
:PROPERTIES:
:ID:       B9F5B1C1-6ED3-49C5-9AA1-6F0D56434720
:END:
:LOGBOOK:
CLOCK: [2022-07-14 Thu 18:46]--[2022-07-14 Thu 19:22] =>  0:36
CLOCK: [2022-07-14 Thu 16:54]--[2022-07-14 Thu 18:16] =>  1:22
CLOCK: [2022-07-14 Thu 12:18]--[2022-07-14 Thu 12:39] =>  0:21
:END:
[[https://leetcode.com/problems/minimize-deviation-in-array/][Problem Statement]]

- [[id:1AE37D0A-8E53-4F30-BBBE-114219226182][Mistake: Failed to find efficient solution for the alternative problem]].  I tried to represent the problem using intervals, but didn't really try to solve it.  After the tip, I came back to the problem and could solve it.

[[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  In the original problem, you can either divide (decrease) even number or multiply (increase) odd numbers.  As there is no need to minimize the number of operations, we can divide all numbers as much as we can and solve the problem where we will only increase the numbers.  Each turn, we remove the smallest element and add it's double back to the [[id:FCBEA48C-CFF6-43C4-B430-BCD00E245D22][Priority-Queue]].  We keep the maximum after each update.  This will be enough for us to compute the shortest interval that contains at least one of each given numbers.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  class Solution:
      def minimumDeviation(self, nums: List[int]) -> int:
          if len(nums) == 1:
              return 0

          seen = set()
          min_pq = []
          max_pq = []

          def push(a, b):
              if (a, b) not in seen:
                  heappush(min_pq, (a, b))
                  heappush(max_pq, (-a, b))
                  seen.add((a, b))

          def pop():
              a, b = heappop(min_pq)
              seen.remove((a, b))
              while len(max_pq) > 0 and (-max_pq[0][0], max_pq[0][1]) not in seen:
                  heappop(max_pq)
              return (a, b)

          k = 0
          for i in nums:
              if i % 2 == 1:
                  push(i, i * 2)
                  k += 2
              else:
                  j = i
                  while j % 2 == 0 and j > 0:
                      j = j // 2
                      k += 1
                  push(j, i)
                  k += 1

          ans = -max_pq[0][0] - min_pq[0][0]
          for i in range(k):
              cur = -max_pq[0][0] - min_pq[0][0]
              ans = min(ans, cur)
              left, right = pop()
              if left * 2 <= right:
                  push(left * 2, right)
              else:
                  push(left, right)

          return ans
#+end_src

* Leetcode: 632. Smallest Range Covering Elements from K Lists
:PROPERTIES:
:ID:       78E9E2DA-8ED3-4E3E-828D-9885691D0D9A
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-15 Fri 09:23]--[2022-07-15 Fri 09:38] =>  0:15
CLOCK: [2022-07-14 Thu 20:21]--[2022-07-14 Thu 20:33] =>  0:12
:END:
[[https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/][Problem Statement]]

- [[id:CCCF9587-5365-4BB0-B0D3-8FC82D55E781][Mistake: Failed to recognize known problem]]

[[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  This problem is similar to [[id:02D2E665-4FC5-45C7-A1BF-E7CE82E67B05][Leetcode: 23. Merge k Sorted Lists]].  The difference is that we have to keep the maximum of the next candidates while we remove one by one from the smaller to the greater.

#+begin_src python
  from typing import List
  from heapq import heappush, heappop


  class Solution:
      def smallestRange(self, nums: List[List[int]]) -> List[int]:
          pq = []
          for i, ns in enumerate(nums):
              heappush(pq, (ns[0], 0, i))

          def best(a, b):
              sa = a[1] - a[0]
              sb = b[1] - b[0]
              if sa < sb or (sa == sb and a[0] < b[0]):
                  return a
              return b

          ans = [min(ns[0] for ns in nums), max(ns[0] for ns in nums)]
          upper_bound = ans[1]
          while True:
              v, k, i = heappop(pq)
              ans = best(ans, [v, upper_bound])

              nk = k + 1
              if nk == len(nums[i]):
                  break
              nv = nums[i][nk]
              upper_bound = max(upper_bound, nv)

              heappush(pq, (nv, nk, i))
          return ans


  assert Solution().smallestRange(
      [[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]]
  ) == [20, 24]
  assert Solution().smallestRange([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) == [1, 1]
#+end_src

[[id:46522C06-DAC3-4986-A13A-17C2ED44ADD1][Can we formulate the problem as sliding window?]]  Yes, if the input was a list.  [[id:42B21DBC-4951-4AF2-8C41-A646F5675365][Can we pre-process the input in a way to make easy to solve the problem?]]  In this case, we want to pre-process to use a sliding window.  Be $l$ a list of pairs $(a, b)$ sorted by $a$ where $a$ is a number of the list $nums[b]$.  A valid solution for the original problem is a subsequence of $l$ where there is at least one number from each list in $nums$.  We can start our window with the first element and slide it to the right.  After we add a new item to the window, we can remove the left-most elements that have at least one more element from the same list in the window.  While doing this, we can update the best interval found so far.

#+begin_src python
  from typing import List


  class Solution:
      def smallestRange(self, nums: List[List[int]]) -> List[int]:
          horizon = []
          for i, ns in enumerate(nums):
              for n in ns:
                  horizon.append((n, i))
          horizon.sort()

          covered = [0] * len(nums)
          total_covered = 0

          def best(a, b):
              sa = a[1] - a[0]
              sb = b[1] - b[0]
              if sa < sb or (sa == sb and a[0] < b[0]):
                  return a
              return b

          ans = [horizon[0][0], horizon[-1][0]]
          i = 0
          covered[horizon[0][1]] = 1
          total_covered = 1

          for j in range(1, len(horizon)):
              jv, jk = horizon[j]
              total_covered += 1 if covered[jk] == 0 else 0
              covered[jk] += 1

              while covered[horizon[i][1]] > 1:
                  covered[horizon[i][1]] -= 1
                  i += 1

              if total_covered == len(nums):
                  iv, ik = horizon[i]
                  ans = best(ans, [iv, jv])

          return ans


  assert Solution().smallestRange(
      [[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]]
  ) == [20, 24]
  assert Solution().smallestRange([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) == [1, 1]
#+end_src

* Leetcode: 224. Basic Calculator
:PROPERTIES:
:ID:       C5B34111-0588-4C40-B161-133ED4759B37
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-15 Fri 13:57]--[2022-07-15 Fri 15:12] =>  1:15
:END:
[[https://leetcode.com/problems/basic-calculator/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  I came up with ~-(-2)~ and forgot about ~(8)~ which is also a valid expression.

The trick part is how we are going to handle the unary minus operator.  [[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  It would make the problem easier if all operator were binary what would require to transform ~-2~ in ~0-2~.  There is only two cases were ~-~ is an unary operator: (1) it occurs in the beginning of the stack or (2) after an open parentheses.  While parsing, we can insert a ~0~ at the right moment and make sure that all operators are binary.  Time and space complexity is $O(n)$.

#+begin_src python
  class Solution:
      def calculate(self, s: str) -> int:
          s = "(" + s + ")"

          st = []
          op = []
          i = 0
          maybe_unary = None

          while i < len(s):
              if s[i] == "(":
                  op.append("(")
                  maybe_unary = True
                  i += 1
              elif "0" <= s[i] <= "9":
                  j = i
                  n = 0
                  while j < len(s) and "0" <= s[j] <= "9":
                      n = n * 10 + ord(s[j]) - ord("0")
                      j += 1
                  st.append(n)
                  maybe_unary = False
                  i = j
              elif s[i] == " ":
                  i += 1
              else:
                  while len(op) > 0:
                      if op[-1] == "+":
                          b = st.pop()
                          a = st.pop()
                          st.append(a + b)
                          op.pop()
                      elif op[-1] == "-":
                          b = st.pop()
                          a = st.pop()
                          st.append(a - b)
                          op.pop()
                      elif op[-1] == "(":
                          if s[i] == ")":
                              op.pop()
                          break

                  if s[i] == "-" and maybe_unary:
                      st.append(0)

                  if s[i] != ")":
                      op.append(s[i])

                  maybe_unary = False
                  i += 1

          return st[0]

  assert Solution().calculate("1 + 1") == 2
  assert Solution().calculate(" 2-1 + 2 ") == 3
  assert Solution().calculate("(1+(4+5+2)-3)+(6+8)") == 23
  assert Solution().calculate("-(-2)") == 2
  assert Solution().calculate("(2)") == 2
#+end_src

* Leetcode: 631. Design Excel Sum Formula
:PROPERTIES:
:ID:       182C19E0-01FA-46DF-9F15-1BD4BD7C02CA
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-15 Fri 21:23]--[2022-07-15 Fri 21:28] =>  0:05
CLOCK: [2022-07-15 Fri 20:10]--[2022-07-15 Fri 20:41] =>  0:31
CLOCK: [2022-07-15 Fri 18:43]--[2022-07-15 Fri 19:09] =>  0:26
CLOCK: [2022-07-15 Fri 18:15]--[2022-07-15 Fri 18:39] =>  0:24
:END:
[[https://leetcode.com/problems/design-excel-sum-formula/][Problem Statement]]

- [[id:3D263A82-52AE-4C90-830D-C533ABAFFF3E][Mistake: Missing required invariants]].  The cache has to be invalidate after ~set~ and ~sum~, but I forgot the last one.

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Cells are edges on the graph.  Fixed-value cells don't have any outgoing edges while formula-cells have edges to all cells that need to be summed.  As there is no cicle on the formulas, the graph is an [[id:81260E21-C442-48DE-A414-CA7B83F2C404][Directed Acyclic Graph]] what allows us to recursively compute the formulas values using cache to avoid repeating computation.  Time complexity of ~get~ and ~sum~ is $O(r^2 \times c^2)$ since there at most $(n \times (n-1))/2$ edges on a [[id:81260E21-C442-48DE-A414-CA7B83F2C404][Directed Acyclic Graph]] with $n$ edges.  As there are $r \times c$ vertices in the graph, the search-space is at most $O(r \times c)$ with $O(r \times c)$ the value of each formula.  Space complexity is $O(r \times c)$.

#+begin_src python
  from typing import List


  class Excel:
      def __init__(self, height: int, width: str):
          self.s = [[0] * 100 for _ in range(100)]
          self.cache = {}

      def set(self, row: int, column: str, val: int) -> None:
          self.s[row][self._col2idx(column)] = val
          self.cache = {}

      def get(self, row: int, column: str) -> int:
          return self._get(row, self._col2idx(column))

      def _get(self, row, col):
          v = self.s[row][col]
          if isinstance(v, int):
              return v

          if (row, col) in self.cache:
              return self.cache[row, col]
          v = self._compute(v)
          self.cache[row, col] = v
          return v

      def sum(self, row: int, column: str, numbers: List[str]) -> int:
          self.s[row][self._col2idx(column)] = numbers
          self.cache = {}
          return self.get(row, column)

      def _compute(self, numbers):
          ans = 0
          for n in numbers:
              if ":" not in n:
                  ans += self._get(*self._s2idxs(n))
                  continue
              f, t = n.split(":")
              fi, fj = self._s2idxs(f)
              ti, tj = self._s2idxs(t)
              for i in range(fi, ti + 1):
                  for j in range(fj, tj + 1):
                      ans += self._get(i, j)
          return ans

      def _col2idx(self, c):
          return ord(c) - ord("A")

      def _s2idxs(self, s):
          return (int(s[1:]), self._col2idx(s[0]))


  # Your Excel object will be instantiated and called as such:
  # obj = Excel(height, width)
  # obj.set(row,column,val)
  # param_2 = obj.get(row,column)
  # param_3 = obj.sum(row,column,numbers)
#+end_src

* Leetcode: 815. Bus Routes
:PROPERTIES:
:ID:       28344F2B-F9AE-430E-A621-350AC5DE4933
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-15 Fri 22:53]--[2022-07-15 Fri 23:37] =>  0:44
:END:
[[https://leetcode.com/problems/bus-routes/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]]. Did not think about ~source = target~ case.
- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]].  Thought that [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] alternating between bus and stop would pass in the time limit.

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Stops are vertices and they are connected if there is a route that connect them.  Create a map from stops to routes and them perform a [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] starting on ~source~.  Time and space complexity is $O(n \times m)$.

Solution building the Build adjacency matrix:
#+begin_src python
  from typing import List


  class Solution:
      def numBusesToDestination(
          self, routes: List[List[int]], source: int, target: int
      ) -> int:
          if source == target:
              return 0

          stops = {}
          for bus, r in enumerate(routes):
              for stop in r:
                  stops.setdefault(stop, [])
                  stops[stop].append(bus)

          vis = [False] * len(routes)
          adj = [set() for _ in range(len(routes))]
          for _, bus in stops.items():
              for i in range(len(bus)):
                  for j in range(i + 1, len(bus)):
                      adj[bus[i]].add(bus[j])
                      adj[bus[j]].add(bus[i])

          queue = [(b, 1) for b in stops.get(source, [])]
          for u, steps in queue:
              if target in routes[u]:
                  return steps
              if vis[u]:
                  continue
              vis[u] = True
              for v in adj[u]:
                  if not vis[v]:
                      queue.append((v, steps + 1))
          return -1


  assert Solution().numBusesToDestination([[1, 2, 7], [3, 6, 7]], 1, 6) == 2
  assert (
      Solution().numBusesToDestination(
          [[7, 12], [4, 5, 15], [6], [15, 19], [9, 12, 13]], 15, 12
      )
      == -1
  )
#+end_src

Without building the adjacency matrix:
#+begin_src python
  from typing import List


  class Solution:
      def numBusesToDestination(
          self, routes: List[List[int]], source: int, target: int
      ) -> int:
          if source == target:
              return 0

          stops = {}
          for bus, r in enumerate(routes):
              for stop in r:
                  stops.setdefault(stop, [])
                  stops[stop].append(bus)

          vis = [False] * len(routes)
          queue = [(source, 0)]
          for u, steps in queue:
              if u == target:
                  return steps
              for bus in stops.get(u, []):
                  if not vis[bus]:
                      vis[bus] = True
                      for v in routes[bus]:
                          queue.append((v, steps + 1))
          return -1


  assert Solution().numBusesToDestination([[1, 2, 7], [3, 6, 7]], 1, 6) == 2
  assert (
      Solution().numBusesToDestination(
          [[7, 12], [4, 5, 15], [6], [15, 19], [9, 12, 13]], 15, 12
      )
      == -1
  )
#+end_src

* Leetcode: 212. Word Search II
:PROPERTIES:
:ID:       61355872-3E7E-4DFB-A470-0C0395CF9E5E
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-16 Sat 13:28]--[2022-07-16 Sat 13:31] =>  0:03
CLOCK: [2022-07-16 Sat 12:22]--[2022-07-16 Sat 12:26] =>  0:04
CLOCK: [2022-07-16 Sat 09:54]--[2022-07-16 Sat 10:02] =>  0:08
CLOCK: [2022-07-16 Sat 08:00]--[2022-07-16 Sat 08:32] =>  0:32
:END:
[[https://leetcode.com/problems/word-search-ii/][Problem Statement]]

- [[id:56B18554-8EDB-44AF-B72A-8FD307B2980C][Mistake: High constant factor in the implementation]].  Did not implement any prune to the backtracking.

[[id:42B21DBC-4951-4AF2-8C41-A646F5675365][Can we pre-process the input in a way to make easy to solve the problem?]]  The problem requires backtracking the board to find words.  Instead of look up the words on a list, we create a [[id:5BC30FCA-3402-4DA7-89D9-7661FEBDA3A7][Trie]] with all words on the dictionary and backtrack while we traverse the tree.  Words found are removed from the tree to avoid finding the same word over and over again.  Time complexity is $O(4 \times 10 \times n^2), and space complexity is $O(\sum|word[i]|)$.

#+begin_src python
  from typing import List


  class Solution:
      def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
          N = len(board)
          M = len(board[0])

          root = {}
          for w in words:
              node = root
              for c in w:
                  node.setdefault(c, {})
                  node = node[c]
              node["$"] = w

          ans = set()

          def dfs(i, j, node):
              if node.get("$"):
                  ans.add(node["$"])
                  del node["$"]

              c = board[i][j]
              board[i][j] = "*"
              for di, dj in [[+0, +1], [+0, -1], [+1, +0], [-1, +0]]:
                  ni = di + i
                  nj = dj + j
                  if 0 <= ni < N and 0 <= nj < M and board[ni][nj] in node:
                      dfs(ni, nj, node[board[ni][nj]])
                      if len(node[board[ni][nj]]) == 0:
                          del node[board[ni][nj]]
              board[i][j] = c

          for i in range(N):
              for j in range(M):
                  if board[i][j] in root:
                      dfs(i, j, root[board[i][j]])

          return list(ans)


  assert Solution().findWords(
      [
          ["o", "a", "a", "n"],
          ["e", "t", "a", "e"],
          ["i", "h", "k", "r"],
          ["i", "f", "l", "v"],
      ],
      ["oath", "pea", "eat", "rain"],
  ) == ["eat", "oath"]
  assert Solution().findWords([["a", "b"], ["c", "d"]], ["abcb"]) == []
#+end_src

* Leetcode: 269. Alien Dictionary
:PROPERTIES:
:ID:       1C9EFDE5-E454-422E-9918-2CF189F61B9D
:WA:       3
:END:
:LOGBOOK:
CLOCK: [2022-07-16 Sat 14:56]--[2022-07-16 Sat 15:33] =>  0:37
CLOCK: [2022-07-16 Sat 14:32]--[2022-07-16 Sat 14:51] =>  0:19
:END:
[[https://leetcode.com/problems/alien-dictionary/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  Did not create edge case for all properties of the problem.

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Letters are vertices and an edge $(u,v)$ means that the letter $u$ comes before $v$ in the alphabet.  This is a [[id:ABCED065-0F63-4FFE-8FEC-2D2615196BF7][Directed Graph]], if there are cycles in this graph then there is no way to build the alphabet because $u, v_1, v_2, ..., v_k, u$ means that $u$ comes before $u$ in the alphabet what is impossible.  So, we have to check if the graph is an [[id:81260E21-C442-48DE-A414-CA7B83F2C404][Directed Acyclic Graph]] and produce a [[id:80122A2F-3B84-48B1-B10D-6ACEE4373298][Topological Sort]] for it.  Time complexity is $O(n)$ and space complexity is $O(1)$.

#+begin_src python
  from typing import List

  class Solution:
      def alienOrder(self, words: List[str]) -> str:
          adj = {}
          for w1, w2 in zip(words, words[1:]):
              if len(w2) < len(w1) and w1.startswith(w2):
                  return ""
              for c1, c2 in zip(w1, w2):
                  if c1 != c2:
                      adj.setdefault(c1, set())
                      adj[c1].add(c2)
                      break

          NOT_VISITED = "NOT_VISITED"
          OPEN = "OPEN"
          CLOSED = "CLOSED"

          status = {c: NOT_VISITED for w in words for c in w}
          ans = []

          def dfs(u):
              if status[u] == CLOSED:
                  return True
              if status[u] == OPEN:
                  return False

              status[u] = OPEN
              for v in adj.get(u, []):
                  if not dfs(v):
                      return False

              ans.append(u)
              status[u] = CLOSED
              return True

          for c in status:
              if status[c] == NOT_VISITED:
                  if not dfs(c):
                      return ""

          return "".join(reversed(ans))

  assert Solution().alienOrder(["wrt","wrf","er","ett","rftt"]) == "wertf"
  assert Solution().alienOrder(["z","x"]) == "zx"
  assert Solution().alienOrder(["z","x","z"]) == ""
  assert Solution().alienOrder(["z","z"]) == "z"
  assert Solution().alienOrder(["abc","ab"]) == ""
#+end_src

* Leetcode: 239. Sliding Window Maximum
:PROPERTIES:
:ID:       373321D0-BE83-41C2-9C7E-10C33EEAF9CF
:END:
:LOGBOOK:
CLOCK: [2022-07-16 Sat 16:34]--[2022-07-16 Sat 16:51] =>  0:17
:END:
[[https://leetcode.com/problems/sliding-window-maximum/][Problem Statement]]

This problem is similar to [[id:798B6359-F1A6-4B42-BBA1-2120D8CD228B][Sliding Window Maximum]].

#+begin_src python
  from typing import List
  from collections import deque


  class Solution:
      def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
          queue = deque()
          ans = []
          for i in range(0, len(nums)):
              while len(queue) > 0 and queue[-1][0] < nums[i]:
                  queue.pop()
              queue.append((nums[i], i))
              if i >= k - 1:
                  if queue[0][1] == i - k:
                      queue.popleft()
                  ans.append(queue[0][0])

          return ans


  assert Solution().maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 6, 7]
  assert Solution().maxSlidingWindow([1], 1) == [1]
#+end_src

* Leetcode: 818. Race Car
:PROPERTIES:
:ID:       3904F180-0CAC-46C5-8ECE-2DAB9517B777
:END:
:LOGBOOK:
CLOCK: [2022-07-16 Sat 17:00]--[2022-07-16 Sat 18:15] =>  1:15
:END:
[[https://leetcode.com/problems/race-car/][Problem Statement]]

- [[id:298CCCF3-C9A7-4FEC-BE7B-17CF0F67332C][Mistake: Bug caused by incorrect assumption]].  Started to look for prunes and added one to avoid numbers greater than ~target~.
- [[id:3C649CC4-0609-4686-96C3-5F774F9C0292][Mistake: Failed to consider different strategies to solve the problem]].  Came up with [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] and didn't ask myself if I could solve the problem using [[id:241ABA4C-A86F-405F-B6FC-85BF441EB24B][Dynamic Programming]].
- [[id:27524F0A-5DA2-4768-8897-2934633CB62F][Mistake: Missing inspection of test cases]].  The test case ~5~ gave a hint which I didn't see because I rushed to code the BFS.

[[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  As in [[id:B9F5B1C1-6ED3-49C5-9AA1-6F0D56434720][Leetcode: 1675. Minimize Deviation in Array]], we can reduce the number of different operations by thinking on the problem to get from $0$ to $i$ only doing forward moves.  $dp[i]$ is the number of steps to get from $0$ to $i$ starting with speed 1.  The best way to get close to $i$ is to accelerate as much as possible.  Be $j$ the closest position to $i$ that we can get accelerating $t$ times at speed $s$.  If $i=j$, the solution is $dp[i]=t$.  Otherwise, $j<i$ and you can either go back to $k$ accelerating $p$ times and then try to go to $i$ or accelerate one more time and then go back to $i$.  Therefore, $dp[i]=min(t + 1 + p + 1 + dp[i - (j - k)], t + 1 + dp[t + s - i] + 1)$ for all $k$.  In summary, the idea is to define the search-space as distances from $0$ to $i$ where $0 \leq i \leq target$.  Space complexity is $O(target)$ and time complexity is $O(target \times \log(target))$.

#+begin_src python
  class Solution:
      def racecar(self, target: int) -> int:
          dp = [0] * (target + 1)
          dp[0] = 0

          def stops(target):
              pos = 0
              speed = 1
              steps = 0
              yield (pos, speed, steps)
              while pos + speed <= i:
                  pos += speed
                  speed *= 2
                  steps += 1
                  yield (pos, speed, steps)


          for i in range(1, target + 1):
              ,*_, (pos, speed, steps) = stops(i)
              if pos == i:
                  dp[i] = steps
                  continue

              dp[i] = steps + 1 + dp[(pos + speed) - i] + 1
              for rpos, _, rsteps in stops(pos):
                  dp[i] = min(dp[i], steps + 1 + rsteps + 1 + dp[i - (pos - rpos)])

          return dp[target]

  assert Solution().racecar(3) == 2
  assert Solution().racecar(6) == 5

#+end_src

[[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] solution starts by doing as much ~A~ as possible and them searching for the optimal path:
#+begin_src python
  class Solution:
      def racecar(self, target: int) -> int:
          seen = set()

          pos = 0
          speed = 1
          steps = 0
          while pos + speed <= target:
              pos += speed
              speed *= 2
              steps += 1

          queue = [(pos, speed, steps)]
          for pos, speed, steps in queue:
              if pos == target:
                  return steps

              if (pos, speed) in seen:
                  continue
              seen.add((pos, speed))

              queue.append((pos + speed, speed * 2, steps + 1))
              if speed > 0:
                  queue.append((pos, -1, steps + 1))
              else:
                  queue.append((pos, +1, steps + 1))


  assert Solution().racecar(3) == 2
  assert Solution().racecar(6) == 5
#+end_src

* Leetcode: 1289. Minimum Falling Path Sum II
:PROPERTIES:
:ID:       629C75D4-0704-4D15-8D20-F818DBCB5F61
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-17 Sun 14:54]--[2022-07-17 Sun 15:26] =>  0:32
:END:
[[https://leetcode.com/problems/minimum-falling-path-sum-ii/][Problem Statement]]

- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]].  First solution was $O(n^4)$ which was solution after manual test with $100 \times 100$ grid.
- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]],  where you had a fast way to pick the best result from the left and right ([[id:D00AC85C-A22C-4946-B379-812595D8387B][Leetcode: 1563. Stone Game V]]).

[[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  The best path that ends on $(i, j)$ is either one path that ended on its left or its right.  Be $left(j)$ the minimum path that ended on any of $(i-1, 0), (i-1, 1), .., (i-1, j)$ cells, and $right(j)$ the minimum path that ended on any of $(i-1, j+1), (i-1, j+2), .., (i-1, M-1)$.  Given that, we can compute $dp[i][j]=grid[i][j]+min(left[j-1], right[j+1])$.  Time and space complexity is $O(n^2)$.

#+begin_src python
  from typing import List


  class Solution:
      def minFallingPathSum(self, grid: List[List[int]]) -> int:
          N = len(grid)
          M = len(grid[0])

          if N == 1 and M == 1:
              return grid[0][0]

          dp = [[float("inf")] * M for _ in range(N)]
          left = [float("inf")] * M
          right = [float("inf")] * M

          for i in range(N):
              for j in range(M):
                  if i == 0:
                      dp[i][j] = grid[i][j]
                      continue

                  dp[i][j] = grid[i][j]
                  if j == 0:
                      dp[i][j] += right[j + 1]
                  elif j == M - 1:
                      dp[i][j] += left[j - 1]
                  else:
                      dp[i][j] += min(left[j - 1], right[j + 1])

              if i < M - 1:
                  for j in range(M):
                      left[j] = min(dp[i][j], float("inf") if j == 0 else left[j - 1])
                  for j in range(M - 1, -1, -1):
                      right[j] = min(
                          dp[i][j], float("inf") if j == M - 1 else right[j + 1]
                      )

          return min(dp[N - 1][j] for j in range(M))


  assert Solution().minFallingPathSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 13
  assert Solution().minFallingPathSum([[7]]) == 7
#+end_src
* Leetcode: 1987. Number of Unique Good Subsequences
:PROPERTIES:
:ID:       A2635C55-6A7B-4295-A3B5-E1A7C8861F11
:END:
:LOGBOOK:
CLOCK: [2022-07-17 Sun 19:06]--[2022-07-17 Sun 20:23] =>  1:17
CLOCK: [2022-07-17 Sun 16:15]--[2022-07-17 Sun 17:07] =>  0:52
:END:
[[https://leetcode.com/problems/number-of-unique-good-subsequences/][Problem Statement]]

- [[id:298CCCF3-C9A7-4FEC-BE7B-17CF0F67332C][Mistake: Bug caused by incorrect assumption]].  I re-wrote part of the code, but didn't check if I had to update the other part of the code.

[[id:BA632D61-93B6-47AB-B11A-7E9EBE3FC71D][Can we derive an invariant based on the smallest possible examples?]]  First, I generated all unique substrings of the string "1001" to see if a pattern emerge:

#+begin_example
  1
  xxx1
  2
  xx0x
  xx01
  2
  x00x
  x001
  5
  1xx1
  1x0x
  1x01
  100x
  1001
#+end_example

Let's compute $dp[i]$ which is the number of unique subsequences starting on $i$.  Let's do it from *left to right*.  Therefore, $dp[N - 1]=1$.  Be $i, j$ indexes where $i < j$, $binary[i]=binary[j]$ and $binary[i] \neq binary[k]$ for $i < k < j$.  Suppose that $binary[i]=1$.  Note that we can extend by one all unique subsequence starting with 1 (i.e. $binary[i]$) and they will all be unique.  Besides that, we can also extend all subsequences starting with 0 (i.e. $binary[i+1], binary[i+2], .., binary[j-1]$) by one and they will all be unique.  So, in this case, $dp[i]=dp[i+1]+dp[i+2]+...+dp[j]$.  We can't compute this sum, since $O(n^2)$ will not make the cut.  Note that if there are no zeros between $i$ and $j$, $dp[i]=dp[j]$.  This means that $dp[i+1]=dp[i+2]=...=dp[j-1]$, since they are computed similarly to the way we compute $dp$ for ones.  Therefore, $dp[i]=dp[i+1] \times (j - i) + dp[j]$.  To compute $dp$ efficiently, we can keep track of the last one and last zero and use it to compute $dp$.  Time and space is $O(n)$.

#+begin_src python
  class Solution:
      def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
          MOD = 10**9 + 7
          N = len(binary)

          dp = [0] * N
          dp[N - 1] = 1
          last = {}
          last["1"], last["0"] = (N - 1, None) if binary[-1] == "1" else (None, N - 1)

          for i in range(N - 2, -1, -1):
              b = binary[i]
              if last[b] is None:
                  dp[i] = N - i
              else:
                  if last[b] - i == 1:
                      dp[i] = dp[i + 1]
                  else:
                      dp[i] = (dp[last[b]] + dp[i + 1] * (last[b] - i - 1)) % MOD
              last[b] = i

          extra = 1 if "0" in binary else 0
          return (sum(dp[i] for i in range(N) if binary[i] == "1") + extra) % MOD


  assert Solution().numberOfUniqueGoodSubsequences("001") == 2
  assert Solution().numberOfUniqueGoodSubsequences("11") == 2
  assert Solution().numberOfUniqueGoodSubsequences("101") == 5
#+end_src

[[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  Other way to solve the problem is counting the unique subsequences from *right to left* which means that extend the unique subsequences that ended with 1 and 0 so far.  Be $e0$ and $e1$ the number of unique subsequences that end with zero and one respectively.  If the current number is 0, we will have all subsequences that ended with zero plus all subsequences that ended with one but now ending on zero.  So, $e0 = e0 + e1$.  If the current number is 1, we will have the same but we have to re-add ~1~ to the count.  So, $e1 = e0 + e1 + 1$.  Time complexity is $O(n)$ and space is $O(1)$.

#+begin_src python
  class Solution:
      def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
          MOD = 10**9 + 7

          count_zero = False
          e1 = 0
          e0 = 0
          for b in binary:
              if b == "0":
                  e0 = (e0 + e1) % MOD
                  count_zero = True
              else:
                  e1 = (e1 + e0 + 1) % MOD

          return (e1 + e0 + (1 if count_zero else 0)) % MOD


  assert Solution().numberOfUniqueGoodSubsequences("001") == 2
  assert Solution().numberOfUniqueGoodSubsequences("11") == 2
  assert Solution().numberOfUniqueGoodSubsequences("101") == 5
#+end_src

* Leetcode: 124. Binary Tree Maximum Path Sum
:PROPERTIES:
:ID:       D188B6DB-A827-4A63-B794-8708CEFB58B7
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-17 Sun 22:18]--[2022-07-17 Sun 22:36] =>  0:18
:END:
[[https://leetcode.com/problems/binary-tree-maximum-path-sum/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  The problem felt simple and I skipped the phase to create edge cases.
- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]].  Find the longest path in a tree which can be solved with two [[id:212DBFC3-FE3C-493E-86A6-42FF3F82CD53][Depth-first search]].

[[id:31D0B1E0-6881-478A-8F48-160BCFD94F31][Can we divide the search-space in two parts and combine solutions from both sides to solve the original problem?]]  Be $u$ a node in the tree.  Find the maximum path starting from the left $l$ and from the right $r$ of $u$.  The maximum path starting from $u$ is either $val(u)$, $val(u)+l$ or $val(u)+r$.  To compute the final answer, we still have to consider $u$ as the root of the maximum path: $val(u)+l+r$.  Time complexity is $O(n)$ and space complexity is $O(depth)$.

#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution:
      def maxPathSum(self, root: Optional[TreeNode]) -> int:
          ans = float("-inf")

          def dfs(node):
              nonlocal ans

              if node is None:
                  return 0

              lans = dfs(node.left) if node.left else float("-inf")
              rans = dfs(node.right) if node.right else float("-inf")
              cur = max(
                  node.val,
                  node.val + lans,
                  node.val + rans,
              )
              ans = max(ans, cur, node.val + lans + rans)

              return cur

          dfs(root)

          return ans
#+end_src

* Leetcode: 759. Employee Free Time
:PROPERTIES:
:ID:       976BF4D9-247A-4247-86C7-06D7B0C793FA
:END:
:LOGBOOK:
CLOCK: [2022-07-18 Mon 08:00]--[2022-07-18 Mon 08:14] =>  0:14
CLOCK: [2022-07-18 Mon 07:48]--[2022-07-18 Mon 07:54] =>  0:06
:END:
[[https://leetcode.com/problems/employee-free-time/][Problem Statement]]

- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]] with intervals where you used a [[id:06D27BC1-DFDC-4063-B3A9-7074FD5E13B3][Stack]] to compute the answer, and I solved a problem to create a sorted list from a list of sorted lists ([[id:02D2E665-4FC5-45C7-A1BF-E7CE82E67B05][Leetcode: 23. Merge k Sorted Lists]]).

- [[id:42B21DBC-4951-4AF2-8C41-A646F5675365][Can we pre-process the input in a way to make easy to solve the problem?]]  We can create a list of all intervals sorted by start time.  This will help us to process all of them as they come.

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  Be $a$ an array with all intervals sorted by start time.  We know that if there is a time off, it will definitely start after $a[0].end$.  If $a[1].start > a[0].end$, then there is a time off from $(a[0].end, a[1].start)$.  If $a[1].start \leq a[0].end$, then the time off might start at $\max(a[0].end, a[1].end)$.  This property holds for all intervals.  Therefore, we can keep a variable with the last end time and use it to create a new interval if needed or update it.  Time complexity is $O(n \log m$ where $m$ is the total number of intervals, because we use a [[id:FCBEA48C-CFF6-43C4-B430-BCD00E245D22][Priority-Queue]] to get the next interval sorted by start time.  Space complexity is $O(m)$.

#+begin_src python
  """
  # Definition for an Interval.
  class Interval:
      def __init__(self, start: int = None, end: int = None):
          self.start = start
          self.end = end
  """

  class Solution:
      def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':
          def intervals():
              pq = []
              for i, s in enumerate(schedule):
                  heappush(pq, (s[0].start, s[0].end, i, 0))
              while len(pq) > 0:
                  start, end, i, j = heappop(pq)
                  yield (start, end)
                  if j + 1 < len(schedule[i]):
                      heappush(pq, (schedule[i][j+1].start, schedule[i][j+1].end, i, j + 1))

          ans = []
          last = None
          for start, end in intervals():
              if last is None:
                  last = end
              elif start > last:
                  ans.append(Interval(last, start))
                  last = end
              else:
                  last = max(last, end)
          return ans
#+end_src

* Leetcode: 489. Robot Room Cleaner
:PROPERTIES:
:ID:       5A7676EA-96E2-42DE-B950-1B082F42CD92
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-19 Tue 10:37]--[2022-07-19 Tue 10:54] =>  0:17
CLOCK: [2022-07-19 Tue 10:05]--[2022-07-19 Tue 10:25] =>  0:20
CLOCK: [2022-07-18 Mon 09:59]--[2022-07-18 Mon 10:56] =>  0:57
:END:
[[https://leetcode.com/problems/robot-room-cleaner][Problem Statement]]

- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]]. My first idea was to make a [[id:212DBFC3-FE3C-493E-86A6-42FF3F82CD53][Depth-first search]], but spent much of the time thinking about other ways to do the search.

#+begin_src python
  # """
  # This is the robot's control interface.
  # You should not implement it, or speculate about its implementation
  # """
  #class Robot:
  #    def move(self):
  #        """
  #        Returns true if the cell in front is open and robot moves into the cell.
  #        Returns false if the cell in front is blocked and robot stays in the current cell.
  #        :rtype bool
  #        """
  #
  #    def turnLeft(self):
  #        """
  #        Robot will stay in the same cell after calling turnLeft/turnRight.
  #        Each turn will be 90 degrees.
  #        :rtype void
  #        """
  #
  #    def turnRight(self):
  #        """
  #        Robot will stay in the same cell after calling turnLeft/turnRight.
  #        Each turn will be 90 degrees.
  #        :rtype void
  #        """
  #
  #    def clean(self):
  #        """
  #        Clean the current cell.
  #        :rtype void
  #        """

  class Solution:
      def cleanRoom(self, robot):
          """
          :type robot: Robot
          :rtype: None
          """

          DIR = [[-1, +0], [+0, -1], [+1, +0], [+0, +1]]

          seen = set()
          def dfs(i, j, d):
              if (i, j, d) in seen:
                  return
              robot.clean()
              seen.add((i, j, d))

              if robot.move():
                  dfs(i + DIR[d][0], j + DIR[d][1], d)
                  robot.turnLeft()
                  robot.turnLeft()
                  robot.move()
                  robot.turnLeft()
                  robot.turnLeft()

              for k in range(3):
                  robot.turnLeft()
                  dfs(i, j, (d + k + 1) % len(DIR))
              robot.turnLeft()

          dfs(0, 0, 0)
#+end_src

* Leetcode: 778. Swim in Rising Water
:PROPERTIES:
:ID:       290376A3-74DD-4708-BA4F-8FDA493EBB1A
:END:
:LOGBOOK:
CLOCK: [2022-07-19 Tue 15:35]--[2022-07-19 Tue 15:51] =>  0:16
:END:
[[https://leetcode.com/problems/swim-in-rising-water/][Problem Statement]]

- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]] with increasing paths on grid and sorting the cells was useful.
- [[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  This is a variation of [[id:8BACB101-3C8B-47CA-9AB1-89D52F85F6DA][Shortest Path in a Graph Problem]] and can be solved using [[id:3D4A4826-ADA4-4975-9C9E-C8B6AF39E01A][Dijkstra Algorithm]].  Instead of adding up to compute the distance, we take the vertices with greatest value in the path so far.
- Time complexity is $O(n^2 \log n)$ and space is $O(n^2)$.

#+begin_src python
  from typing import List
  from heapq import heappush, heappop


  class Solution:
      def swimInWater(self, grid: List[List[int]]) -> int:
          N = len(grid)

          seen = set((grid[0][0], 0, 0))
          pq = [(grid[0][0], 0, 0)]

          while pq:
              t, i, j = heappop(pq)

              if i == N - 1 and j == N - 1:
                  return t

              for ni, nj in [[i, j + 1], [i, j - 1], [i + 1, j], [i - 1, j]]:
                  if 0 <= ni < N and 0 <= nj < N and (ni, nj) not in seen:
                      seen.add((ni, nj))
                      heappush(pq, (max(grid[ni][nj], t), ni, nj))


  assert Solution().swimInWater([[0, 2], [1, 3]]) == 3
  assert (
      Solution().swimInWater(
          [
              [0, 1, 2, 3, 4],
              [24, 23, 22, 21, 5],
              [12, 13, 14, 15, 16],
              [11, 17, 18, 19, 20],
              [10, 9, 8, 7, 6],
          ]
      )
      == 16
  )
#+end_src

* Leetcode: 715. Range Module
:PROPERTIES:
:ID:       AEBE4500-C0FA-498A-889E-17F8A1C7ECCF
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-19 Tue 21:57]--[2022-07-19 Tue 22:46] =>  0:49
CLOCK: [2022-07-19 Tue 19:34]--[2022-07-19 Tue 19:52] =>  0:18
CLOCK: [2022-07-19 Tue 18:32]--[2022-07-19 Tue 19:12] =>  0:40
:END:
[[https://leetcode.com/problems/range-module/][Problem Statement]]

- [[id:00CC89B4-340B-4219-9CF4-837F558947B4][Mistake: Bug caused by debug code]]

- [[id:EEDBE877-7C4A-4D0B-BA6B-EFDF9288B78C][Blackbox: This is a variation of a classic problem]]: [[id:8564CEB1-3E95-4A34-B888-0BCE6D6504B8][Lazy Segment Tree]].

The solution with [[id:8564CEB1-3E95-4A34-B888-0BCE6D6504B8][Lazy Segment Tree]] has time complexity of $O(n \log m)$ where $m$ is the maximum value in the interval, and space complexity of $O(n)$:
#+begin_src python
  class RangeModule:
      def __init__(self, left=1, right=10**9, full=False):
          self.left = left
          self.mid = left + (right - left) // 2
          self.right = right
          self.left_child = self.right_child = None
          self.full = full

      def addRange(self, left: int, right: int) -> None:
          self._update(left, right - 1, True)

      def removeRange(self, left: int, right: int) -> None:
          self._update(left, right - 1, False)

      def queryRange(self, left: int, right: int) -> bool:
          return self._query(left, right - 1)

      def _query(self, left: int, right: int) -> bool:
          if self.right < left or right < self.left:
              return True

          self._extend()
          if self.full or left <= self.left <= self.right <= right:
              return self.full

          return self.left_child._query(left, right) and self.right_child._query(
              left, right
          )

      def _update(self, left: int, right: int, value: bool) -> None:
          if self.right < left or right < self.left:
              return
          if left <= self.left <= self.right <= right:
              self.left_child = None
              self.right_child = None
              self.full = value
              return
          self._extend()
          self.left_child._update(left, right, value)
          self.right_child._update(left, right, value)
          self.full = self.left_child.full and self.right_child.full

      def _extend(self) -> None:
          if self.left_child is None and self.left < self.right:
              m = self.left + (self.right - self.left) // 2
              self.left_child = RangeModule(self.left, m, self.full)
              self.right_child = RangeModule(m + 1, self.right, self.full)

      def _print(self, level=0):
          print(" " * level, self.left, self.right, self.full)
          if self.left_child:
              self.left_child._print(level + 1)
              self.right_child._print(level + 1)


  # Your RangeModule object will be instantiated and called as such:
  # obj = RangeModule()
  # obj.addRange(left,right)
  # param_2 = obj.queryRange(left,right)
  # obj.removeRange(left,right)
#+end_src


** TODO Write solution using array of indexes

The idea is to represent intervals in an array where even number are start of intervals and odd indexes are end of intervals.

#+begin_example
  ["RangeModule","addRange","removeRange","queryRange","queryRange","queryRange"]
  [[],[10,20],[14,16],[10,14],[13,15],[16,17]]
  ["RangeModule","addRange","addRange","removeRange","queryRange","queryRange","removeRange","removeRange","removeRange","removeRange","removeRange","queryRange","removeRange","addRange","removeRange","addRange","queryRange","queryRange","addRange","addRange","queryRange","removeRange","queryRange","addRange","queryRange","removeRange","removeRange","addRange","addRange","removeRange","removeRange","removeRange","addRange","addRange","queryRange","queryRange","queryRange","queryRange","queryRange","removeRange","removeRange","queryRange","addRange","addRange","addRange","queryRange","addRange","addRange","removeRange","addRange","queryRange","removeRange","addRange","queryRange","addRange","addRange","addRange","queryRange","addRange","queryRange","removeRange","removeRange","removeRange","removeRange","queryRange","removeRange","queryRange","queryRange","removeRange","queryRange","addRange","addRange","queryRange","removeRange","removeRange","queryRange","addRange","removeRange","removeRange","addRange","addRange","addRange","queryRange","queryRange","addRange","queryRange","removeRange","queryRange","removeRange","addRange","queryRange"]
  [[],[55,62],[1,29],[18,49],[6,98],[59,71],[40,45],[4,58],[57,69],[20,30],[1,40],[73,93],[32,93],[38,100],[50,64],[26,72],[8,74],[15,53],[44,85],[10,71],[54,70],[10,45],[30,66],[47,98],[1,7],[44,78],[31,49],[62,63],[49,88],[47,72],[8,50],[49,79],[31,47],[54,87],[77,78],[59,100],[8,9],[50,51],[67,93],[25,86],[8,92],[31,87],[90,95],[28,56],[10,42],[27,34],[75,81],[17,63],[78,90],[9,18],[51,74],[20,54],[35,72],[2,29],[28,41],[17,95],[73,75],[34,43],[57,96],[51,72],[21,67],[40,73],[14,26],[71,86],[34,41],[10,25],[27,68],[18,32],[30,31],[45,61],[64,66],[18,93],[13,21],[13,46],[56,99],[6,93],[25,36],[27,88],[82,83],[30,71],[31,73],[10,41],[71,72],[9,56],[22,76],[38,74],[2,77],[33,61],[74,75],[11,43],[27,75]]
#+end_example

* Leetcode: 2158. Amount of New Area Painted Each Day
:PROPERTIES:
:ID:       2C7437BC-7DD0-460F-91DE-E3C915DC3731
:END:
:LOGBOOK:
CLOCK: [2022-07-21 Thu 09:09]--[2022-07-21 Thu 09:14] =>  0:05
CLOCK: [2022-07-20 Wed 22:38]--[2022-07-21 Thu 09:07] => 10:29
:END:
[[https://leetcode.com/problems/amount-of-new-area-painted-each-day/][Problem Statement]]

- [[id:56B18554-8EDB-44AF-B72A-8FD307B2980C][Mistake: High constant factor in the implementation]].  Did not optimize when query an interval that was already full.
- [[id:EEDBE877-7C4A-4D0B-BA6B-EFDF9288B78C][Blackbox: This is a variation of a classic problem]]: [[id:252C5055-2C0D-4B0E-A4BF-9507B85A179F][Segment Tree]]

- [[id:37B33434-71C2-4E55-9121-5D6855D8E169][Can we formulate the problem using a segment tree?]]  Suppose we have a [[id:8564CEB1-3E95-4A34-B888-0BCE6D6504B8][Lazy Segment Tree]] covering the full range (1 to $10^5$).  The problem adding intervals to the segment tree while computing the number of new points covered.  Time complexity is $O(n \log m)$ with space $O(min(m, n))$.

#+begin_src python
  from typing import List


  class SegTree:
      def __init__(self, left, right, count=0):
          self.left = left
          self.mid = left + (right - left) // 2
          self.right = right
          self.count = count
          self.left_child = self.right_child = None

      def add(self, left, right):
          if self.right < left or right < self.left:
              return 0
          if self.is_full() or left <= self.left <= self.right <= right:
              self.left_child = None
              self.right_child = None
              self.fill()
              return self.count
          self._extend()
          self.left_child.add(left, right)
          self.right_child.add(left, right)
          before = self.count
          after = self.count = self.left_child.count + self.right_child.count
          return after - before

      def is_full(self):
          return self.count == self.right - self.left + 1

      def fill(self):
          self.count = self.right - self.left + 1

      def _extend(self):
          if self.left_child is None and self.left < self.right:
              self.left_child = SegTree(self.left, self.mid)
              self.right_child = SegTree(self.mid + 1, self.right)
              if self.is_full():
                  self.left_child.fill()
                  self.right_child.fill()

      def _print(self, level=0):
          print(" " * level, (self.left, self.right), self.count)
          if self.left_child:
              self.left_child._print(level + 1)
              self.right_child._print(level + 1)


  class Solution:
      def amountPainted(self, paint: List[List[int]]) -> List[int]:
          st = SegTree(0, 50_000 + 1)
          ans = []
          for start, end in paint:
              ans.append(st.add(start, end - 1))
          return ans


  assert Solution().amountPainted([[1, 4], [4, 7], [5, 8]]) == [3, 3, 1]
  assert Solution().amountPainted([[1, 4], [5, 8], [4, 7]]) == [3, 3, 1]
  assert Solution().amountPainted([[1, 5], [2, 4]]) == [4, 0]
#+end_src

- [[id:29512D97-A54D-42F9-A8C7-C3422881933B][Can we use brute-force to solve the problem?]]  The brute-force means painting every single point and for that the answer is no.  But we can improve on the brute-force algorithm by tracking the next possible empty cell using an array $nxt$.  While processing $paint[i]$, we can set $nxt[paint[i].start]=nxt[paint[i].start+1]=..=nxt[paint[i].end-1]=paint[i].end$.  So, the next time that we reach any of those cells, we can jump directly to $nxt[paint[i].end]$.

#+begin_src python
  class Solution:
      def amountPainted(self, paint: List[List[int]]) -> List[int]:
          N = len(paint)
          nxt = [None for i in range(50_001)]
          ans = []
          for start, end in paint:
              cur = 0
              while start < end:
                  if nxt[start] is None:
                      nxt[start] = end
                      cur += 1
                      start += 1
                  else:
                      nstart = nxt[start]
                      nxt[start] = max(nxt[start], end)
                      start = nstart
              ans.append(cur)
          return ans
#+end_src

- [[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  The graph starts with $m$ vertices and no edges.  We process each paint on order and create the edges $(paint[i].start, paint[i].start+1), (paint[i].start+1, paint[i].start+2), ..., (paint[i].end-1, paint[i].end)$.  While adding the edges to the graph, we keep track of the components created using [[id:23A4E36E-24D3-40F8-AA20-32C0DB1E36F6][Union-Find]].  Each component is rooted on the left-most position in the component.  So, adding an edge $(u, u+1)$, we can jump to $find(u+1)$ since it is the next available point to paint.

#+begin_src python
  class Solution:
      def amountPainted(self, paint: List[List[int]]) -> List[int]:
          N = len(paint)
          p = [i for i in range(50_001)]
          ans = []

          def find(a):
              if p[a] == a:
                  return a
              p[a] = find(p[a])
              return p[a]

          def union(a, b):
              assert b > a
              pa = find(a)
              pb = find(b)
              p[pa] = pb
              return pb

          for start, end in paint:
              cur = 0
              start = find(start)
              while start < end:
                  start = union(start, start + 1)
                  cur += 1
              ans.append(cur)
          return ans
#+end_src

* Leetcode: 1610. Maximum Number of Visible Points
:PROPERTIES:
:ID:       3D1697BA-4AFC-47E7-83A5-56413F279DDF
:END:
:LOGBOOK:
CLOCK: [2022-07-21 Thu 18:00]--[2022-07-21 Thu 20:32] =>  2:32
:END:
[[https://leetcode.com/problems/maximum-number-of-visible-points/][Problem Statement]]

[[id:46522C06-DAC3-4986-A13A-17C2ED44ADD1][Can we formulate the problem as sliding window?]]  Create the window with the first points that don't exceed the given angle and after that insert point by point removing ones from the beginning while the window is invalid.  The trick is that you have to replicate the points because this is a circular sliding window problem.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  from typing import List


  def sub_points(pa, pb):
      return [pa[0] - pb[0], pa[1] - pb[1]]


  def angle_in_radians(p):
      return atan2(p[1], p[0])


  class Solution:
      def visiblePoints(
          self, points: List[List[int]], angle: int, location: List[int]
      ) -> int:
          _points, points = points, [
              sub_points(p, location) for p in points if p != location
          ]
          points.sort(key=angle_in_radians)
          rads = [angle_in_radians(p) for p in points] + [
              angle_in_radians(p) + 2 * pi for p in points
          ]

          N = len(rads)
          R = radians(angle)
          extra = len(_points) - len(points)
          ans = 0

          start = 0
          end = 0
          while end < N:
              while rads[end] - rads[start] > R:
                  start += 1
              ans = max(ans, end - start + 1)
              end += 1

          return ans + extra


  assert Solution().visiblePoints([[2, 1], [2, 2], [3, 3]], 90, [1, 1]) == 3
  assert Solution().visiblePoints([[2, 1], [2, 2], [3, 4], [1, 1]], 90, [1, 1]) == 4
  assert Solution().visiblePoints([[1, 0], [2, 1]], 13, [1, 1]) == 1
#+end_src

* Leetcode: 552. Student Attendance Record II
:PROPERTIES:
:ID:       18394CF2-A8EC-41C0-8BCB-FADCCE1C9448
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-21 Thu 21:59]--[2022-07-21 Thu 23:20] =>  1:21
:END:
[[https://leetcode.com/problems/student-attendance-record-ii/][Problem Statement]]

- [[id:AC9291C6-4C72-4143-80F2-0D414EF7B681][Mistake: Did not try hard to solve alternative problem]].  I found that I had to treat records with ~A~ separately, but I didn't try hard to find its formula.  Instead, I work the recurrence with ~A~, ~L~, and ~P~ which is way more complex than the first one.

- [[id:56B18554-8EDB-44AF-B72A-8FD307B2980C][Mistake: High constant factor in the implementation]].  Python's map is slow when looking up $10^5$ elements.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Be $f(d, s)$ the number of different records ending with status $s$ on the day $d$.  Be $g(d)$ the number of different records with $d$ days.  If there is no absence, then we have at least $x=f(d, L)+f(d, P)$ different records.  For each day $i$ that we can be absent, we have $y=\max(1, f(i-1,L)+f(i-1,P)) \times \max(1, f(n - i, L) + f(n - i, P))$ possible records.  So, $g(d)=x+y$.  Time and space complexity is $O(n)$.

#+begin_src python
  class Solution:
      def checkRecord(self, n: int) -> int:
          MOD = 10**9 + 7
          ans = 0

          L = 0
          P = 1
          dp = [[0, 0] for _ in range(n + 2)]

          dp[0][L] = dp[0][P] = 0
          dp[1][L] = dp[1][P] = 1
          dp[2][L] = dp[2][P] = 2

          for day in range(3, n + 1):
              dp[day][L] = (dp[day - 2][P] + dp[day - 1][P]) % MOD
              dp[day][P] = (dp[day - 1][L] + dp[day - 1][P]) % MOD

          def a(day):
              return (dp[day][L] + dp[day][P]) % MOD

          ans = a(n)
          for day in range(1, n + 1):
              ans = (ans + max(a(day - 1), 1) * max(a(n - day), 1)) % MOD
          return ans


  assert Solution().checkRecord(2) == 8
  assert Solution().checkRecord(1) == 3
  assert Solution().checkRecord(10101) == 183236316
#+end_src

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  The valid suffixes for a record are $XP$, $YPL$ and $ZPLL$, where $X$, $Y$ and $Z$ are records of size $n-1, n-2$ and $n-3$ respectively.  As these suffixes are mutually exclusive, we can compute the number of different records with only ~L~ and ~P~ as $f(d)=f(d-1)+f(d-2)+f(d-3)$.  To compute $g(d)$, we use the same trick as the above solution.  Time and space complexity is $O(n)$.

#+begin_src python
  class Solution:
      def checkRecord(self, n: int) -> int:
          MOD = 10**9 + 7

          dp = [0] * (n + 10)
          dp[0] = 1
          dp[1] = 2
          dp[2] = 4
          dp[3] = 7

          for day in range(4, n + 1):
              dp[day] = (dp[day - 1] + dp[day - 2] + dp[day - 3]) % MOD

          ans = dp[n]
          for day in range(1, n + 1):
              ans = (ans + dp[day - 1] * dp[n - day]) % MOD
          return ans


  assert Solution().checkRecord(2) == 8
  assert Solution().checkRecord(1) == 3
  assert Solution().checkRecord(10101) == 183236316
#+end_src

* Leetcode: 2242. Maximum Score of a Node Sequence
:PROPERTIES:
:ID:       E1B5330F-BC4C-499D-9422-A9AFA474D20F
:END:
:LOGBOOK:
CLOCK: [2022-07-22 Fri 08:03]--[2022-07-22 Fri 08:19] =>  0:16
:END:
[[https://leetcode.com/problems/maximum-score-of-a-node-sequence/][Problem Statement]]

- [[id:DD73E390-3303-40F8-9CE1-D1ED048D9588][How can we find the solution knowing part of it?]]  Be $(u, v)$ the central edge of the maximum path.  We have to find its extreme vertices $p$ and $q$, since the maximum path must have length 4.  We can find those vertices by searching through the top-4 vertices connected with $u$ and $v$.  Time and space complexity is $O(n)$.

#+begin_src python
  from typing import List
  from heapq import heappush, heappop


  class Solution:
      def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
          N = len(scores)
          candidates = [[] for _ in range(N)]

          def add_candidate(u, v):
              heappush(candidates[u], (scores[v], v))
              if len(candidates[u]) > 4:
                  heappop(candidates[u])

          for u, v in edges:
              add_candidate(u, v)
              add_candidate(v, u)

          ans = -1
          for u, v in edges:
              for pscore, p in candidates[u]:
                  if p == v:
                      continue
                  for qscore, q in candidates[v]:
                      if q == u or q == p:
                          continue
                      ans = max(ans, pscore + qscore + scores[u] + scores[v])
          return ans


  assert (
      Solution().maximumScore(
          [5, 2, 9, 8, 4], [[0, 1], [1, 2], [2, 3], [0, 2], [1, 3], [2, 4]]
      )
      == 24
  )
  assert (
      Solution().maximumScore([9, 20, 6, 4, 11, 12], [[0, 3], [5, 3], [2, 4], [1, 3]])
      == -1
  )
#+end_src

* Leetcode: 2035. Partition Array Into Two Arrays to Minimize Sum Difference
:PROPERTIES:
:ID:       A669D90C-A9DD-4A43-AE69-AB90D8197A00
:END:
:LOGBOOK:
CLOCK: [2022-07-22 Fri 13:35]--[2022-07-22 Fri 13:54] =>  0:19
CLOCK: [2022-07-22 Fri 10:15]--[2022-07-22 Fri 11:14] =>  0:59
CLOCK: [2022-07-22 Fri 08:54]--[2022-07-22 Fri 08:56] =>  0:02
:END:
[[https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/][Problem Statement]]

- Blackbox: Split the input.  We have to split the array in the half and its size is $2 \times n$ with $1 \leq n \leq 15$.  My intuition focused on the fact that $2^15$ isn't too much to compute.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Generate all possible sums with $0, 1, 2, ..., n / 2$ numbers for the first half of the array.  Do the same for the other side.  Suppose that we picked $A$ numbers from the first half.  We have to pick $B$ numbers from the other side to build a valid array where $|B|=n/2-|A|$.  For each $a$ in $A$, we can find the number in $B$ closest as possible to $S/2-a$ using [[id:5CDA0F71-AED2-47E7-9BB4-3B66EA8B85BF][Find index of first greater in sorted array]] algorithm, since it will be the one that minimize the difference between the two final arrays.  Time complexity is $O(2^15 \times \log(2^15))$ and space is $O(2^15)$.

#+begin_src python
  from typing import List
  from bisect import bisect_left


  class Solution:
      def minimumDifference(self, nums: List[int]) -> int:
          N = len(nums)
          M = N // 2

          m = min(n for n in nums)
          nums = [m + n for n in nums]
          S = sum(nums)

          a = [set() for _ in range(M + 1)]
          b = [set() for _ in range(M + 1)]

          a[0].add(0)
          b[0].add(0)

          for n in nums[:M]:
              for i in range(M - 1, -1, -1):
                  for k in a[i]:
                      a[i + 1].add(k + n)

          for n in nums[M:]:
              for i in range(M - 1, -1, -1):
                  for k in b[i]:
                      b[i + 1].add(k + n)

          for i in range(M + 1):
              a[i] = sorted(a[i])
              b[i] = sorted(b[i])

          ans = float("inf")
          for i in range(M + 1):
              j = M - i
              for p in a[i]:
                  t = S // 2 - p
                  m = bisect_left(b[j], t)
                  for k in range(max(0, m - 1), min(m + 1, len(b[j]))):
                      ans = min(ans, abs(S - 2 * (p + b[j][k])))

          return ans


  assert Solution().minimumDifference([3, 9, 7, 3]) == 2
  assert Solution().minimumDifference([-36, 36]) == 72
  assert Solution().minimumDifference([2, -1, 0, 4, -2, -9]) == 0
#+end_src
* TODO Leetcode: 843. Guess the Word
:PROPERTIES:
:ID:       559F0C7E-8D58-4212-B2C0-BB3DEDCD9D94
:END:
:LOGBOOK:
CLOCK: [2022-07-19 Tue 17:36]--[2022-07-19 Tue 18:31] =>  0:55
CLOCK: [2022-07-19 Tue 16:09]--[2022-07-19 Tue 16:19] =>  0:10
:END:
[[https://leetcode.com/problems/guess-the-word/][Problem Statement]]

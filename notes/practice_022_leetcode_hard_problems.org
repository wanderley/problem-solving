PROPERTIES:
:ID:       CCE8B891-5B15-4840-ACCA-7BB744804150
:END:
#+TITLE: Practice #022: Leetcode Hard Problems

* Leetcode: 42. Trapping Rain Water
:PROPERTIES:
:ID:       08B1CF58-22CC-4634-B230-96D578138B73
:WA: 1
:END:
:LOGBOOK:
CLOCK: [2022-07-11 Mon 21:56]--[2022-07-11 Mon 22:41] =>  0:45
:END:
[[https://leetcode.com/problems/trapping-rain-water/][Problem Statement]]

[[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  There is nothing to do if we have just one or two walls.  With three walls $h_1, h_2$ and $h_3$, there is no water trapped if $h_1<h_2<h_3$ or $h_1>h_2>h_3$, but there is water trapped if $h_1>h_2$ and $h_3>h_2$.  In the last case, we can compute the amount of water trapped $(\min(h_3,h_1) - h_2) \times (i_3 - i_1 - 1)$.  After that, we can remove $a_2$, add $a_3$ and continue the process with the next height.  We can use [[id:E4CFDB04-DCFD-47E3-9ED2-0DC6446420B5][Monotonic Stack]] to keep track of the heights and solve the problem in time and space $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def trap(self, height: List[int]) -> int:
          N = len(height)
          stack = []
          ans = 0
          for i in range(N):
              while stack and height[stack[-1]] < height[i]:
                  j = stack.pop()
                  if stack:
                      cur = (min(height[stack[-1]], height[i]) - height[j]) * (
                          i - stack[-1] - 1
                      )
                      ans += cur
              stack.append(i)
          return ans


  assert Solution().trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6
  assert Solution().trap([4, 2, 0, 3, 2, 5]) == 9
#+end_src

* Leetcode: 68. Text Justification
:PROPERTIES:
:ID:       7CACB161-1117-4C63-AF27-9537365BECC4
:WA: 0
:END:
:LOGBOOK:
CLOCK: [2022-07-12 Tue 10:42]--[2022-07-12 Tue 11:11] =>  0:29
:END:
[[https://leetcode.com/problems/text-justification/][Problem Statement]]

[[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  The smaller parts are (1) split the list on the words on each line, (2) justify one line and (3) left-justify one line.  Time and space complexity is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
          def justify(line):
              if len(line) == 1:
                  return line[0] + (" " * (maxWidth - len(line[0])))

              s = sum(map(len, line))
              ans = ""
              g = len(line) - 1
              e = (maxWidth - s) // g
              x = maxWidth - s - e * g
              for i, w in enumerate(line):
                  if i > 0:
                      ans += " " * e
                      ans += " " if x > 0 else ""
                      x -= 1
                  ans += w
              return ans

          def align_left(line):
              l = " ".join(line)
              l = l + (" " * (maxWidth - len(l)))
              return l

          lines = []
          line = []
          line_len = 0
          for w in words:
              new_line_len = line_len + (1 if line_len > 0 else 0) + len(w)
              if new_line_len > maxWidth:
                  lines.append(line)
                  line = []
                  line_len = 0
                  new_line_len = len(w)

              line.append(w)
              line_len = new_line_len

          if len(line) > 0:
              lines.append(line)

          return list(map(justify, lines[0:-1])) + [align_left(lines[-1])]


  assert Solution().fullJustify(
      ["This", "is", "an", "example", "of", "text", "justification."], 16
  ) == ["This    is    an", "example  of text", "justification.  "]
  assert Solution().fullJustify(
      ["What", "must", "be", "acknowledgment", "shall", "be"], 16
  ) == ["What   must   be", "acknowledgment  ", "shall be        "]
  assert Solution().fullJustify(
      [
          "Science",
          "is",
          "what",
          "we",
          "understand",
          "well",
          "enough",
          "to",
          "explain",
          "to",
          "a",
          "computer.",
          "Art",
          "is",
          "everything",
          "else",
          "we",
          "do",
      ],
      20,
  ) == [
      "Science  is  what we",
      "understand      well",
      "enough to explain to",
      "a  computer.  Art is",
      "everything  else  we",
      "do                  ",
  ]
#+end_src

* Leetcode: 588. Design In-Memory File System
:PROPERTIES:
:ID:       A65AAAF2-0F96-47F8-9A90-8F40324C00D3
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-12 Tue 11:19]--[2022-07-12 Tue 12:00] =>  0:41
:END:
[[https://leetcode.com/problems/design-in-memory-file-system/][Problem Statement]]

Use [[id:5BC30FCA-3402-4DA7-89D9-7661FEBDA3A7][Trie]] to represent the directory and file paths.  Time complexity is $O(p)$ to find a node (for ~mkdir~, ~write~ and ~read~) where $p$ is the length of the path, $O(p + P)$ for ~ls~ where the $P$ is the sum of length of all nodes in a sub-path.

#+begin_src python
  import string

  class FileSystem:

      def __init__(self):
          self.root = {"directory": True, "/": {}}

      def ls(self, path: str) -> List[str]:
          node = self._get_node(path)
          if "file" in node:
              return [path.split("/")[-1]]

          node = node["/"]
          ans = []

          def dfs(node, name):
              if "file" in node or "directory" in node:
                  ans.append(name)
              for c in string.ascii_lowercase:
                  if c in node:
                      dfs(node[c], name + c)

          dfs(node, "")
          return ans

      def mkdir(self, path: str) -> None:
          node = self._get_node(path)
          node["directory"] = True
          node["/"] = {}

      def addContentToFile(self, filePath: str, content: str) -> None:
          node = self._get_node(filePath)
          node["file"] = True
          node["content"] = node.get("content", "") + content

      def readContentFromFile(self, filePath: str) -> str:
          return self._get_node(filePath).get("content", "")

      def _get_node(self, path):
          if path == "/":
              return self.root
          node = self.root
          for c in path:
              if c not in node:
                  node[c] = {}
              if c == "/":
                  node["directory"] = True
              node = node[c]
          return node


  # Your FileSystem object will be instantiated and called as such:
  # obj = FileSystem()
  # param_1 = obj.ls(path)
  # obj.mkdir(path)
  # obj.addContentToFile(filePath,content)
  # param_4 = obj.readContentFromFile(filePath)
#+end_src

* Leetcode: 273. Integer to English Words
:PROPERTIES:
:ID:       D1635740-9FA0-4CE2-8DA3-6813C8752564
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-12 Tue 14:30]--[2022-07-12 Tue 15:28] =>  0:58
:END:
[[https://leetcode.com/problems/integer-to-english-words/][Problem Statement]]

[[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  This is not a question about efficiently, but if you can organize the solution in a handleable way.

#+begin_src python
  class Solution:
      def numberToWords(self, num: int) -> str:
          ntw = {
              0: "Zero",
              1: "One",
              2: "Two",
              3: "Three",
              4: "Four",
              5: "Five",
              6: "Six",
              7: "Seven",
              8: "Eight",
              9: "Nine",
              10: "Ten",
              11: "Eleven",
              12: "Twelve",
              13: "Thirteen",
              14: "Fourteen",
              15: "Fifteen",
              16: "Sixteen",
              17: "Seventeen",
              18: "Eighteen",
              19: "Nineteen",
              20: "Twenty",
              30: "Thirty",
              40: "Forty",
              50: "Fifty",
              60: "Sixty",
              70: "Seventy",
              80: "Eighty",
              90: "Ninety",
          }

          if num in ntw:
              return ntw[num]

          def convert(n):
              if n == 0:
                  return []
              if n in ntw:
                  return [ntw[n]]
              if n >= 100:
                  return [ntw[n // 100], "Hundred"] + convert(n % 100)
              else:
                  return [ntw[n - (n % 10)]] + convert(n % 10)

          e = [["Billion"], ["Million"], ["Thousand"], []]
          ans = []
          while num > 0:
              cur = num % 1000
              suf = e.pop()
              if cur > 0:
                  ans = convert(cur) + suf + ans
              num = num // 1000
          return " ".join(ans)


  assert Solution().numberToWords(123) == "One Hundred Twenty Three"
  assert Solution().numberToWords(12345) == "Twelve Thousand Three Hundred Forty Five"
  assert (
      Solution().numberToWords(1234567)
      == "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
  )
#+end_src

* Leetcode: 716. Max Stack
:PROPERTIES:
:ID:       8BC92BDE-2E5B-47AB-A3DF-FE3866E3E424
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-12 Tue 16:17]--[2022-07-12 Tue 17:03] =>  0:46
:END:
[[https://leetcode.com/problems/max-stack/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]]
- [[id:3D263A82-52AE-4C90-830D-C533ABAFFF3E][Mistake: Missing required invariants]]

The source is in [[id:A0500087-56D9-4D34-936F-E8E3912C4761][Max Stack]] since it might be useful in other problems.  It was implemented with a stack to efficiently reply to ~pop~ and ~top~, a heap for ~peekMax~ and ~popMax~.  While ~top~ is $O(1)$, all other operations are $O(\log n)$.

* Leetcode: 1948. Delete Duplicate Folders in System
:PROPERTIES:
:ID:       4488F27D-F20C-46A4-AD00-771BEBB8CCD8
:WA:       4
:END:
:LOGBOOK:
CLOCK: [2022-07-13 Wed 10:20]--[2022-07-13 Wed 10:59] =>  0:39
CLOCK: [2022-07-13 Wed 08:49]--[2022-07-13 Wed 08:55] =>  0:06
CLOCK: [2022-07-12 Tue 22:00]--[2022-07-12 Tue 23:07] =>  1:07
CLOCK: [2022-07-12 Tue 17:53]--[2022-07-12 Tue 18:30] =>  0:37
:END:
[[https://leetcode.com/problems/delete-duplicate-folders-in-system/][Problem Statement]]

- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]]: Coded a more complex and /wrong/ solution using hashes to avoid time limit when the simple solution was enough.

[[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  Imagine that we can assign an *id* for each subtree where different subtrees have different numbers and equivalent subtrees have the same number.  The problem becomes filtering all subtrees with duplicated id.  For this problem, the id can be a serialization of the subtree like one generated by a pre-order traversing of the tree.  Time complexity is $O(n)$ where $n$ is the number of nodes in the tree.

#+begin_src python
  from typing import List


  class Solution:
      def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:
          root = {}
          for p in paths:
              node = root
              for d in p:
                  node.setdefault(d, {})
                  node = node[d]

          groups = {}

          def serialize(root):
              ans = []
              for node in sorted(root):
                  ans.append((node, serialize(root[node])))
              ans = tuple(ans)

              groups.setdefault(ans, [])
              groups[ans].append(root)
              root["__s__"] = ans

              return ans

          serialize(root)

          ans = []

          def dfs(root, path):
              if len(groups[root["__s__"]]) > 1 and len(root) > 1:
                  return

              ans.append(path[:])
              for node in root:
                  if node == "__s__":
                      continue
                  path.append(node)
                  dfs(root[node], path)
                  path.pop()

          dfs(root, [])

          return ans[1:]


  assert Solution().deleteDuplicateFolder(
      [["a"], ["c"], ["d"], ["a", "b"], ["c", "b"], ["d", "a"]]
  ) == [["d"], ["d", "a"]]
  assert Solution().deleteDuplicateFolder(
      [
          ["a"],
          ["c"],
          ["a", "b"],
          ["c", "b"],
          ["a", "b", "x"],
          ["a", "b", "x", "y"],
          ["w"],
          ["w", "y"],
      ]
  ) == [["a"], ["a", "b"], ["c"], ["c", "b"]]
  assert Solution().deleteDuplicateFolder([["a", "b"], ["c", "d"], ["c"], ["a"]]) == [
      ["a"],
      ["a", "b"],
      ["c"],
      ["c", "d"],
  ]
#+end_src

* Leetcode: 23. Merge k Sorted Lists
:PROPERTIES:
:ID:       02D2E665-4FC5-45C7-A1BF-E7CE82E67B05
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-13 Wed 11:23]--[2022-07-13 Wed 11:36] =>  0:13
:END:
[[https://leetcode.com/problems/merge-k-sorted-lists/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]]: Had to fix my code multiple times since the input and output didn't match the problem's expectations.

#+begin_src python
  # Definition for singly-linked list.
  # class ListNode:
  #     def __init__(self, val=0, next=None):
  #         self.val = val
  #         self.next = next
  class Solution:
      def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
          pq = []
          for i, l in enumerate(lists):
              if l:
                  heappush(pq, (l.val, i))

          ans = None
          last = None
          while len(pq) > 0:
              v, i = heappop(pq)
              if ans is None:
                  ans = lists[i]
                  last = lists[i]
              else:
                  last.next = lists[i]
                  last = lists[i]

              if lists[i].next:
                  heappush(pq, (lists[i].next.val, i))
                  lists[i] = lists[i].next
          return ans

#+end_src

* Leetcode: 1293. Shortest Path in a Grid with Obstacles Elimination
:PROPERTIES:
:ID:       4416AFE9-6BB7-4AF8-9F85-68BAE35D4717
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-13 Wed 11:51]--[2022-07-13 Wed 12:14] =>  0:23
:END:
[[https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/][Problem Statement]]

- [[id:8E8E98F9-335A-4279-B523-549FD9025A0C][Mistake: Picked the wrong data structure]]:  A priority queue was unnecessary to solve the problem.

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Yes.  The problem becomes do a [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] starting from node $(0, 0)$ and ending on $(n-1, m-1)$.  Time and space complexity is $O(N \times M \times K)$.

#+begin_src python
  from typing import List


  class Solution:
      def shortestPath(self, grid: List[List[int]], k: int) -> int:
          N = len(grid)
          M = len(grid[0])

          queue = []
          vis = [[[False] * (k + 1) for _ in range(M)] for _ in range(N)]

          queue.append((0, 1 if grid[0][0] == 1 else 0, 0, 0))
          for d, c, i, j in queue:
              if c > k:
                  continue
              if vis[i][j][c]:
                  continue
              vis[i][j][c] = True

              if i == N - 1 and j == M - 1:
                  return d

              for di, dj in [[+0, +1], [+0, -1], [+1, +0], [-1, +0]]:
                  nd = d + 1
                  nc = c + (1 if grid[i][j] == 1 else 0)
                  if 0 <= di + i < N and 0 <= dj + j < M and nc <= k:
                      queue.append((nd, nc, di + i, dj + j))

          return -1


  assert (
      Solution().shortestPath([[0, 0, 0], [1, 1, 0], [0, 0, 0], [0, 1, 1], [0, 0, 0]], 1)
      == 6
  )
  assert Solution().shortestPath([[0, 1, 1], [1, 1, 1], [1, 0, 0]], 1) == -1
#+end_src

* Leetcode: 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix
:PROPERTIES:
:ID:       76B022D8-9C12-4415-AFDD-837067EC49DD
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-13 Wed 14:04]--[2022-07-13 Wed 14:29] =>  0:25
:END:
[[https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]]: Missed that I could also flip cells with 0.

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Each possible configuration of the binary matrix is a node in the graph, and two node are adjacent with a flip in one will generate the other.  The problem becomes do a [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] from the initial node to the node representing a zero matrix.  Time and space complexity is $O(n \times m \times 2^{n \times m})$.

#+begin_src python
  from typing import List


  class Solution:
      def minFlips(self, mat: List[List[int]]) -> int:
          N = len(mat)
          M = len(mat[0])

          def id(i, j):
              return 1 << (i * M + j)

          initial = 0
          for i in range(N):
              for j in range(M):
                  if mat[i][j] == 1:
                      initial = initial | id(i, j)

          seen = set()
          queue = [(0, initial)]

          for steps, state in queue:
              if state == 0:
                  return steps
              if state in seen:
                  continue
              seen.add(state)

              for i in range(N):
                  for j in range(M):
                      nstate = state
                      for di, dj in [[+0, +0], [+0, +1], [+0, -1], [+1, +0], [-1, +0]]:
                          if 0 <= di + i < N and 0 <= dj + j < M:
                              if nstate & id(di + i, dj + j) != 0:
                                  nstate = nstate & ~id(di + i, dj + j)
                              else:
                                  nstate = nstate | id(di + i, dj + j)
                      queue.append((steps + 1, nstate))
          return -1


  assert Solution().minFlips([[0, 0], [0, 1]]) == 3
  assert Solution().minFlips([[0]]) == 0
  assert Solution().minFlips([[1, 0, 0], [1, 0, 0]]) == -1
#+end_src

* Leetcode: 2123. Minimum Operations to Remove Adjacent Ones in Matrix
:PROPERTIES:
:ID:       DACEB904-5675-42F2-89E7-733320BE0751
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-13 Wed 18:45]--[2022-07-13 Wed 19:14] =>  0:29
CLOCK: [2022-07-13 Wed 17:30]--[2022-07-13 Wed 18:33] =>  1:03
CLOCK: [2022-07-13 Wed 15:31]--[2022-07-13 Wed 16:50] =>  1:19
:END:
[[https://leetcode.com/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/][Problem Statement]]

- [[id:B3BCF738-D1F0-4705-89B2-10B66DCE8977][Mistake: Failed to recognize a classic problem in the reduced problem]].

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  The 1-cells are vertices and an edge exists if two adjacent cells (left, right, top and down) are 1-cells.  This graph is a [[id:F1D5D810-3FDF-45C3-BAF1-68584BD77DB3][Bipartite Graph]] and the problem becomes finding the [[id:A293CEDD-F976-4FA2-97F3-02DF918E73B1][Minimum vertex cover problem]] which is equivalent to [[id:2BFB9CF6-4D77-4753-88E1-B4BDF9BED66B][Maximum Bipartite Matching]] in such graphs.

#+begin_src python
  from typing import List


  class Solution:
      def minimumOperations(self, grid: List[List[int]]) -> int:
          N = len(grid)
          M = len(grid[0])

          def neighbours(i, j):
              for di, dj in [[+0, +1], [+0, -1], [+1, +0], [-1, +0]]:
                  if 0 <= di + i < N and 0 <= dj + j < M and grid[di + i][dj + j] == 1:
                      yield (di + i, dj + j)

          mt = {}

          def dfs(node, seen):
              if node in seen:
                  return False
              seen.add(node)
              for child in neighbours(*node):
                  if child not in mt or dfs(mt[child], seen):
                      mt[child] = node
                      return True
              return False

          ans = 0
          for i in range(N):
              for j in range(M):
                  if grid[i][j] == 1:
                      if dfs((i, j), set()):
                          ans += 1

          return ans // 2


  assert Solution().minimumOperations([[1, 1, 0], [0, 1, 1], [1, 1, 1]]) == 3
  assert Solution().minimumOperations([[0, 1], [1, 0]]) == 0
#+end_src

* Leetcode: 828. Count Unique Characters of All Substrings of a Given String
:PROPERTIES:
:ID:       1289D944-3EE5-4270-8F29-69047B204213
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-14 Thu 09:20]--[2022-07-14 Thu 09:57] =>  0:37
CLOCK: [2022-07-13 Wed 21:49]--[2022-07-13 Wed 21:52] =>  0:03
CLOCK: [2022-07-13 Wed 21:30]--[2022-07-13 Wed 21:40] =>  0:10
CLOCK: [2022-07-13 Wed 20:18]--[2022-07-13 Wed 21:21] =>  1:03
CLOCK: [2022-07-13 Wed 19:25]--[2022-07-13 Wed 19:32] =>  0:07
:END:
[[https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]]
- [[id:298CCCF3-C9A7-4FEC-BE7B-17CF0F67332C][Mistake: Bug caused by incorrect assumption]]
- [[id:56B18554-8EDB-44AF-B72A-8FD307B2980C][Mistake: High constant factor in the implementation]]

- [[id:21114DEC-E1B0-4B45-8A7C-E4DA93BB9474][Pattern: Compute value for all subsequences of an array]].

- [[id:26656051-E32D-42FE-9315-05ADB46A1A82][Can we reuse or extend a solution from a sub-problem to solve the next sub-problem more efficiently?]]  Let $f(i)=\sum_{i \leq j < n} countUniqueChars(j)$ the function that we want to compute efficiently.  Be $i$ the first index from the left to right that is duplicated, and $j$ an index where $s[i]=s[j]$ and $i<j$.  We know that $f(i+1)=1+2+3+..+(n-i-1)$ since there is no duplicates and all letters in all substrings are counted.  All substring starting on $i+1$ and ending on $i+1,i+2,..,j-1$ will count one more letter when extend to $i$.  All substring starting on $i+1$ and ending on $j, j+1, ..., n$ will not count one when extended.  So, $f(i)=f(i+1) + (j - i)$.  Now, suppose that $s[i]$ is the third occurence of $s[i]$ from left to right.  Be $k$ an index where $s[i]=s[k]$ and $j<k$.  In this case, $f(i)= f(i+1) + (j - i) - (k - j)$, since all substrings starting on $i+1$ and ending on $k$ will not contribute to the sum of count of unique chars anymore.  Time and space complexity is $O(n)$.

#+begin_src python
  class Solution:
      def uniqueLetterString(self, s: str) -> int:
          N = len(s)

          nxt = {}
          last = {}
          for c in set(s):
              last[c] = N
              nxt[N, c] = N

          for i in range(N - 1, -1, -1):
              nxt[i, s[i]] = last[s[i]]
              last[s[i]] = i

          ans = 0
          cur = 0
          for i in range(N - 1, -1, -1):
              j = nxt[i, s[i]]
              k = nxt[j, s[i]]
              cur += (j - i) - (k - j)
              ans += cur
          return ans


  assert Solution().uniqueLetterString("ABC") == 10
  assert Solution().uniqueLetterString("ABA") == 8
  assert Solution().uniqueLetterString("LEETCODE") == 92
#+end_src

* Leetcode: 127. Word Ladder
:PROPERTIES:
:ID:       6EB17048-DA8B-443F-A28A-630DF77246B6
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-14 Thu 10:45]--[2022-07-14 Thu 11:02] =>  0:17
:END:
[[https://leetcode.com/problems/word-ladder/][Problem Statement]]

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Words are vertices and two words that match the problem's constraints are connected by an edge.  [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Find the shortest path ~beginWord~ to ~endWord~ using a [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]], and computing the edges in an efficient way since $O(n^2 \times 10)$ won't make the cut.  [[id:638547C6-7305-4AA8-A57B-D570C1C323DD][Can we first generate all candidates and then pick the best one?]]  For a given word, we can generate all possible transformations and create the edge with only the ones that appear in the dictionary.  This can be done in $O(n \times 250)$ since the max length is 10 and there are 25 different letter to try in each position.  Time and space complexity is $O(n)$.

#+begin_src python
  from typing import List
  import string


  class Solution:
      def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
          W = set(wordList)
          L = set(beginWord)
          for w in W:
              for c in w:
                  L.add(c)

          def adj(s):
              for i in range(len(s)):
                  for c in string.ascii_lowercase:
                      if c != s[i]:
                          nw = s[0:i] + c + s[i + 1 :]
                          if nw in W:
                              yield nw

          queue = [(0, beginWord)]
          seen = set()
          for steps, u in queue:
              if u == endWord:
                  return steps + 1
              if u in seen:
                  continue
              seen.add(u)

              for v in adj(u):
                  if v not in seen:
                      queue.append((steps + 1, v))

          return 0


  assert (
      Solution().ladderLength("hit", "cog", ["hot", "dot", "dog", "lot", "log", "cog"])
      == 5
  )
  assert Solution().ladderLength("hit", "cog", ["hot", "dot", "dog", "lot", "log"]) == 0
#+end_src

* Leetcode: 1675. Minimize Deviation in Array
:PROPERTIES:
:ID:       B9F5B1C1-6ED3-49C5-9AA1-6F0D56434720
:END:
:LOGBOOK:
CLOCK: [2022-07-14 Thu 18:46]--[2022-07-14 Thu 19:22] =>  0:36
CLOCK: [2022-07-14 Thu 16:54]--[2022-07-14 Thu 18:16] =>  1:22
CLOCK: [2022-07-14 Thu 12:18]--[2022-07-14 Thu 12:39] =>  0:21
:END:
[[https://leetcode.com/problems/minimize-deviation-in-array/][Problem Statement]]

- [[id:1AE37D0A-8E53-4F30-BBBE-114219226182][Mistake: Failed to find efficient solution for the alternative problem]].  I tried to represent the problem using intervals, but didn't really try to solve it.  After the tip, I came back to the problem and could solve it.

[[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  In the original problem, you can either divide (decrease) even number or multiply (increase) odd numbers.  As there is no need to minimize the number of operations, we can divide all numbers as much as we can and solve the problem where we will only increase the numbers.  Each turn, we remove the smallest element and add it's double back to the [[id:FCBEA48C-CFF6-43C4-B430-BCD00E245D22][Priority-Queue]].  We keep the maximum after each update.  This will be enough for us to compute the shortest interval that contains at least one of each given numbers.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  class Solution:
      def minimumDeviation(self, nums: List[int]) -> int:
          if len(nums) == 1:
              return 0

          seen = set()
          min_pq = []
          max_pq = []

          def push(a, b):
              if (a, b) not in seen:
                  heappush(min_pq, (a, b))
                  heappush(max_pq, (-a, b))
                  seen.add((a, b))

          def pop():
              a, b = heappop(min_pq)
              seen.remove((a, b))
              while len(max_pq) > 0 and (-max_pq[0][0], max_pq[0][1]) not in seen:
                  heappop(max_pq)
              return (a, b)

          k = 0
          for i in nums:
              if i % 2 == 1:
                  push(i, i * 2)
                  k += 2
              else:
                  j = i
                  while j % 2 == 0 and j > 0:
                      j = j // 2
                      k += 1
                  push(j, i)
                  k += 1

          ans = -max_pq[0][0] - min_pq[0][0]
          for i in range(k):
              cur = -max_pq[0][0] - min_pq[0][0]
              ans = min(ans, cur)
              left, right = pop()
              if left * 2 <= right:
                  push(left * 2, right)
              else:
                  push(left, right)

          return ans
#+end_src

* Leetcode: 632. Smallest Range Covering Elements from K Lists
:PROPERTIES:
:ID:       78E9E2DA-8ED3-4E3E-828D-9885691D0D9A
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-15 Fri 09:23]--[2022-07-15 Fri 09:38] =>  0:15
CLOCK: [2022-07-14 Thu 20:21]--[2022-07-14 Thu 20:33] =>  0:12
:END:
[[https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/][Problem Statement]]

- [[id:CCCF9587-5365-4BB0-B0D3-8FC82D55E781][Mistake: Failed to recognize known problem]]

[[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  This problem is similar to [[id:02D2E665-4FC5-45C7-A1BF-E7CE82E67B05][Leetcode: 23. Merge k Sorted Lists]].  The difference is that we have to keep the maximum of the next candidates while we remove one by one from the smaller to the greater.

#+begin_src python
  from typing import List
  from heapq import heappush, heappop


  class Solution:
      def smallestRange(self, nums: List[List[int]]) -> List[int]:
          pq = []
          for i, ns in enumerate(nums):
              heappush(pq, (ns[0], 0, i))

          def best(a, b):
              sa = a[1] - a[0]
              sb = b[1] - b[0]
              if sa < sb or (sa == sb and a[0] < b[0]):
                  return a
              return b

          ans = [min(ns[0] for ns in nums), max(ns[0] for ns in nums)]
          upper_bound = ans[1]
          while True:
              v, k, i = heappop(pq)
              ans = best(ans, [v, upper_bound])

              nk = k + 1
              if nk == len(nums[i]):
                  break
              nv = nums[i][nk]
              upper_bound = max(upper_bound, nv)

              heappush(pq, (nv, nk, i))
          return ans


  assert Solution().smallestRange(
      [[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]]
  ) == [20, 24]
  assert Solution().smallestRange([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) == [1, 1]
#+end_src

[[id:46522C06-DAC3-4986-A13A-17C2ED44ADD1][Can we formulate the problem as sliding window?]]  Yes, if the input was a list.  [[id:42B21DBC-4951-4AF2-8C41-A646F5675365][Can we pre-process the input in a way to make easy to solve the problem?]]  In this case, we want to pre-process to use a sliding window.  Be $l$ a list of pairs $(a, b)$ sorted by $a$ where $a$ is a number of the list $nums[b]$.  A valid solution for the original problem is a subsequence of $l$ where there is at least one number from each list in $nums$.  We can start our window with the first element and slide it to the right.  After we add a new item to the window, we can remove the left-most elements that have at least one more element from the same list in the window.  While doing this, we can update the best interval found so far.

#+begin_src python
  from typing import List


  class Solution:
      def smallestRange(self, nums: List[List[int]]) -> List[int]:
          horizon = []
          for i, ns in enumerate(nums):
              for n in ns:
                  horizon.append((n, i))
          horizon.sort()

          covered = [0] * len(nums)
          total_covered = 0

          def best(a, b):
              sa = a[1] - a[0]
              sb = b[1] - b[0]
              if sa < sb or (sa == sb and a[0] < b[0]):
                  return a
              return b

          ans = [horizon[0][0], horizon[-1][0]]
          i = 0
          covered[horizon[0][1]] = 1
          total_covered = 1

          for j in range(1, len(horizon)):
              jv, jk = horizon[j]
              total_covered += 1 if covered[jk] == 0 else 0
              covered[jk] += 1

              while covered[horizon[i][1]] > 1:
                  covered[horizon[i][1]] -= 1
                  i += 1

              if total_covered == len(nums):
                  iv, ik = horizon[i]
                  ans = best(ans, [iv, jv])

          return ans


  assert Solution().smallestRange(
      [[4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30]]
  ) == [20, 24]
  assert Solution().smallestRange([[1, 2, 3], [1, 2, 3], [1, 2, 3]]) == [1, 1]
#+end_src

* Leetcode: 224. Basic Calculator
:PROPERTIES:
:ID:       C5B34111-0588-4C40-B161-133ED4759B37
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-15 Fri 13:57]--[2022-07-15 Fri 15:12] =>  1:15
:END:
[[https://leetcode.com/problems/basic-calculator/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  I came up with ~-(-2)~ and forgot about ~(8)~ which is also a valid expression.

The trick part is how we are going to handle the unary minus operator.  [[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  It would make the problem easier if all operator were binary what would require to transform ~-2~ in ~0-2~.  There is only two cases were ~-~ is an unary operator: (1) it occurs in the beginning of the stack or (2) after an open parentheses.  While parsing, we can insert a ~0~ at the right moment and make sure that all operators are binary.  Time and space complexity is $O(n)$.

#+begin_src python
  class Solution:
      def calculate(self, s: str) -> int:
          s = "(" + s + ")"

          st = []
          op = []
          i = 0
          maybe_unary = None

          while i < len(s):
              if s[i] == "(":
                  op.append("(")
                  maybe_unary = True
                  i += 1
              elif "0" <= s[i] <= "9":
                  j = i
                  n = 0
                  while j < len(s) and "0" <= s[j] <= "9":
                      n = n * 10 + ord(s[j]) - ord("0")
                      j += 1
                  st.append(n)
                  maybe_unary = False
                  i = j
              elif s[i] == " ":
                  i += 1
              else:
                  while len(op) > 0:
                      if op[-1] == "+":
                          b = st.pop()
                          a = st.pop()
                          st.append(a + b)
                          op.pop()
                      elif op[-1] == "-":
                          b = st.pop()
                          a = st.pop()
                          st.append(a - b)
                          op.pop()
                      elif op[-1] == "(":
                          if s[i] == ")":
                              op.pop()
                          break

                  if s[i] == "-" and maybe_unary:
                      st.append(0)

                  if s[i] != ")":
                      op.append(s[i])

                  maybe_unary = False
                  i += 1

          return st[0]

  assert Solution().calculate("1 + 1") == 2
  assert Solution().calculate(" 2-1 + 2 ") == 3
  assert Solution().calculate("(1+(4+5+2)-3)+(6+8)") == 23
  assert Solution().calculate("-(-2)") == 2
  assert Solution().calculate("(2)") == 2
#+end_src

#+begin_src python
  class Solution:
      def calculate(self, s: str) -> int:
          s = "(" + s + ")"
          N = len(s)

          def dfs(i, left, right, sign):
              if i == N:
                  return left + sign * right

              if s[i] == " ":
                  return dfs(i + 1, left, right, sign)

              if s[i].isdigit():
                  j = i
                  while j < N and s[j].isdigit():
                      j += 1
                  return dfs(j, left, int(s[i:j]), sign)

              if s[i] in "+-":
                  return dfs(i + 1, left + sign * right, 0, +1 if s[i] == "+" else -1)

              if s[i] == "(":
                  ni, right = dfs(i + 1, 0, 0, +1)
                  return dfs(ni, left + sign * right, 0, +1)

              return i + 1, left + sign * right

          return dfs(0, 0, 0, +1)
#+end_src

* Leetcode: 631. Design Excel Sum Formula
:PROPERTIES:
:ID:       182C19E0-01FA-46DF-9F15-1BD4BD7C02CA
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-15 Fri 21:23]--[2022-07-15 Fri 21:28] =>  0:05
CLOCK: [2022-07-15 Fri 20:10]--[2022-07-15 Fri 20:41] =>  0:31
CLOCK: [2022-07-15 Fri 18:43]--[2022-07-15 Fri 19:09] =>  0:26
CLOCK: [2022-07-15 Fri 18:15]--[2022-07-15 Fri 18:39] =>  0:24
:END:
[[https://leetcode.com/problems/design-excel-sum-formula/][Problem Statement]]

- [[id:3D263A82-52AE-4C90-830D-C533ABAFFF3E][Mistake: Missing required invariants]].  The cache has to be invalidate after ~set~ and ~sum~, but I forgot the last one.

- [[id:117736F8-6CF6-435F-9043-18B8D22EDDE9][Pattern: Answer queries on online directed acyclic graph]].  Invalidate a cache for queries every time that the graph changes.

- [[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Cells are edges on the graph.  Fixed-value cells don't have any outgoing edges while formula-cells have edges to all cells that need to be summed.  As there is no cicle on the formulas, the graph is an [[id:81260E21-C442-48DE-A414-CA7B83F2C404][Directed Acyclic Graph]] what allows us to recursively compute the formulas values using cache to avoid repeating computation.  Time complexity of ~get~ and ~sum~ is $O(r^2 \times c^2)$ since there at most $(n \times (n-1))/2$ edges on a [[id:81260E21-C442-48DE-A414-CA7B83F2C404][Directed Acyclic Graph]] with $n$ edges.  As there are $r \times c$ vertices in the graph, the search-space is at most $O(r \times c)$ with $O(r \times c)$ the value of each formula.  Space complexity is $O(r \times c)$.

#+begin_src python
  from typing import List


  class Excel:
      def __init__(self, height: int, width: str):
          self.s = [[0] * 100 for _ in range(100)]
          self.cache = {}

      def set(self, row: int, column: str, val: int) -> None:
          self.s[row][self._col2idx(column)] = val
          self.cache = {}

      def get(self, row: int, column: str) -> int:
          return self._get(row, self._col2idx(column))

      def _get(self, row, col):
          v = self.s[row][col]
          if isinstance(v, int):
              return v

          if (row, col) in self.cache:
              return self.cache[row, col]
          v = self._compute(v)
          self.cache[row, col] = v
          return v

      def sum(self, row: int, column: str, numbers: List[str]) -> int:
          self.s[row][self._col2idx(column)] = numbers
          self.cache = {}
          return self.get(row, column)

      def _compute(self, numbers):
          ans = 0
          for n in numbers:
              if ":" not in n:
                  ans += self._get(*self._s2idxs(n))
                  continue
              f, t = n.split(":")
              fi, fj = self._s2idxs(f)
              ti, tj = self._s2idxs(t)
              for i in range(fi, ti + 1):
                  for j in range(fj, tj + 1):
                      ans += self._get(i, j)
          return ans

      def _col2idx(self, c):
          return ord(c) - ord("A")

      def _s2idxs(self, s):
          return (int(s[1:]), self._col2idx(s[0]))


  # Your Excel object will be instantiated and called as such:
  # obj = Excel(height, width)
  # obj.set(row,column,val)
  # param_2 = obj.get(row,column)
  # param_3 = obj.sum(row,column,numbers)
#+end_src

* Leetcode: 815. Bus Routes
:PROPERTIES:
:ID:       28344F2B-F9AE-430E-A621-350AC5DE4933
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-15 Fri 22:53]--[2022-07-15 Fri 23:37] =>  0:44
:END:
[[https://leetcode.com/problems/bus-routes/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]]. Did not think about ~source = target~ case.
- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]].  Thought that [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] alternating between bus and stop would pass in the time limit.

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Stops are vertices and they are connected if there is a route that connect them.  Create a map from stops to routes and them perform a [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] starting on ~source~.  Time and space complexity is $O(n \times m)$.

Solution building the Build adjacency matrix:
#+begin_src python
  from typing import List


  class Solution:
      def numBusesToDestination(
          self, routes: List[List[int]], source: int, target: int
      ) -> int:
          if source == target:
              return 0

          stops = {}
          for bus, r in enumerate(routes):
              for stop in r:
                  stops.setdefault(stop, [])
                  stops[stop].append(bus)

          vis = [False] * len(routes)
          adj = [set() for _ in range(len(routes))]
          for _, bus in stops.items():
              for i in range(len(bus)):
                  for j in range(i + 1, len(bus)):
                      adj[bus[i]].add(bus[j])
                      adj[bus[j]].add(bus[i])

          queue = [(b, 1) for b in stops.get(source, [])]
          for u, steps in queue:
              if target in routes[u]:
                  return steps
              if vis[u]:
                  continue
              vis[u] = True
              for v in adj[u]:
                  if not vis[v]:
                      queue.append((v, steps + 1))
          return -1


  assert Solution().numBusesToDestination([[1, 2, 7], [3, 6, 7]], 1, 6) == 2
  assert (
      Solution().numBusesToDestination(
          [[7, 12], [4, 5, 15], [6], [15, 19], [9, 12, 13]], 15, 12
      )
      == -1
  )
#+end_src

Without building the adjacency matrix:
#+begin_src python
  from typing import List


  class Solution:
      def numBusesToDestination(
          self, routes: List[List[int]], source: int, target: int
      ) -> int:
          if source == target:
              return 0

          stops = {}
          for bus, r in enumerate(routes):
              for stop in r:
                  stops.setdefault(stop, [])
                  stops[stop].append(bus)

          vis = [False] * len(routes)
          queue = [(source, 0)]
          for u, steps in queue:
              if u == target:
                  return steps
              for bus in stops.get(u, []):
                  if not vis[bus]:
                      vis[bus] = True
                      for v in routes[bus]:
                          queue.append((v, steps + 1))
          return -1


  assert Solution().numBusesToDestination([[1, 2, 7], [3, 6, 7]], 1, 6) == 2
  assert (
      Solution().numBusesToDestination(
          [[7, 12], [4, 5, 15], [6], [15, 19], [9, 12, 13]], 15, 12
      )
      == -1
  )
#+end_src

* Leetcode: 212. Word Search II
:PROPERTIES:
:ID:       61355872-3E7E-4DFB-A470-0C0395CF9E5E
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-16 Sat 13:28]--[2022-07-16 Sat 13:31] =>  0:03
CLOCK: [2022-07-16 Sat 12:22]--[2022-07-16 Sat 12:26] =>  0:04
CLOCK: [2022-07-16 Sat 09:54]--[2022-07-16 Sat 10:02] =>  0:08
CLOCK: [2022-07-16 Sat 08:00]--[2022-07-16 Sat 08:32] =>  0:32
:END:
[[https://leetcode.com/problems/word-search-ii/][Problem Statement]]

- [[id:56B18554-8EDB-44AF-B72A-8FD307B2980C][Mistake: High constant factor in the implementation]].  Did not implement any prune to the backtracking.

[[id:42B21DBC-4951-4AF2-8C41-A646F5675365][Can we pre-process the input in a way to make easy to solve the problem?]]  The problem requires backtracking the board to find words.  Instead of look up the words on a list, we create a [[id:5BC30FCA-3402-4DA7-89D9-7661FEBDA3A7][Trie]] with all words on the dictionary and backtrack while we traverse the tree.  Words found are removed from the tree to avoid finding the same word over and over again.  Time complexity is $O(4 \times 10 \times n^2), and space complexity is $O(\sum|word[i]|)$.

#+begin_src python
  from typing import List


  class Solution:
      def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
          N = len(board)
          M = len(board[0])

          root = {}
          for w in words:
              node = root
              for c in w:
                  node.setdefault(c, {})
                  node = node[c]
              node["$"] = w

          ans = set()

          def dfs(i, j, node):
              if node.get("$"):
                  ans.add(node["$"])
                  del node["$"]

              c = board[i][j]
              board[i][j] = "*"
              for di, dj in [[+0, +1], [+0, -1], [+1, +0], [-1, +0]]:
                  ni = di + i
                  nj = dj + j
                  if 0 <= ni < N and 0 <= nj < M and board[ni][nj] in node:
                      dfs(ni, nj, node[board[ni][nj]])
                      if len(node[board[ni][nj]]) == 0:
                          del node[board[ni][nj]]
              board[i][j] = c

          for i in range(N):
              for j in range(M):
                  if board[i][j] in root:
                      dfs(i, j, root[board[i][j]])

          return list(ans)


  assert Solution().findWords(
      [
          ["o", "a", "a", "n"],
          ["e", "t", "a", "e"],
          ["i", "h", "k", "r"],
          ["i", "f", "l", "v"],
      ],
      ["oath", "pea", "eat", "rain"],
  ) == ["eat", "oath"]
  assert Solution().findWords([["a", "b"], ["c", "d"]], ["abcb"]) == []
#+end_src

* Leetcode: 269. Alien Dictionary
:PROPERTIES:
:ID:       1C9EFDE5-E454-422E-9918-2CF189F61B9D
:WA:       3
:END:
:LOGBOOK:
CLOCK: [2022-07-16 Sat 14:56]--[2022-07-16 Sat 15:33] =>  0:37
CLOCK: [2022-07-16 Sat 14:32]--[2022-07-16 Sat 14:51] =>  0:19
:END:
[[https://leetcode.com/problems/alien-dictionary/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  Did not create edge case for all properties of the problem.

[[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Letters are vertices and an edge $(u,v)$ means that the letter $u$ comes before $v$ in the alphabet.  This is a [[id:ABCED065-0F63-4FFE-8FEC-2D2615196BF7][Directed Graph]], if there are cycles in this graph then there is no way to build the alphabet because $u, v_1, v_2, ..., v_k, u$ means that $u$ comes before $u$ in the alphabet what is impossible.  So, we have to check if the graph is an [[id:81260E21-C442-48DE-A414-CA7B83F2C404][Directed Acyclic Graph]] and produce a [[id:80122A2F-3B84-48B1-B10D-6ACEE4373298][Topological Sort]] for it.  Time complexity is $O(n)$ and space complexity is $O(1)$.

#+begin_src python
  from typing import List

  class Solution:
      def alienOrder(self, words: List[str]) -> str:
          adj = {}
          for w1, w2 in zip(words, words[1:]):
              if len(w2) < len(w1) and w1.startswith(w2):
                  return ""
              for c1, c2 in zip(w1, w2):
                  if c1 != c2:
                      adj.setdefault(c1, set())
                      adj[c1].add(c2)
                      break

          NOT_VISITED = "NOT_VISITED"
          OPEN = "OPEN"
          CLOSED = "CLOSED"

          status = {c: NOT_VISITED for w in words for c in w}
          ans = []

          def dfs(u):
              if status[u] == CLOSED:
                  return True
              if status[u] == OPEN:
                  return False

              status[u] = OPEN
              for v in adj.get(u, []):
                  if not dfs(v):
                      return False

              ans.append(u)
              status[u] = CLOSED
              return True

          for c in status:
              if status[c] == NOT_VISITED:
                  if not dfs(c):
                      return ""

          return "".join(reversed(ans))

  assert Solution().alienOrder(["wrt","wrf","er","ett","rftt"]) == "wertf"
  assert Solution().alienOrder(["z","x"]) == "zx"
  assert Solution().alienOrder(["z","x","z"]) == ""
  assert Solution().alienOrder(["z","z"]) == "z"
  assert Solution().alienOrder(["abc","ab"]) == ""
#+end_src

* Leetcode: 239. Sliding Window Maximum
:PROPERTIES:
:ID:       373321D0-BE83-41C2-9C7E-10C33EEAF9CF
:END:
:LOGBOOK:
CLOCK: [2022-07-16 Sat 16:34]--[2022-07-16 Sat 16:51] =>  0:17
:END:
[[https://leetcode.com/problems/sliding-window-maximum/][Problem Statement]]

- [[id:07D31904-E85B-4566-A2CD-9013AAA800C0][Pattern: Find optimal values for every subarray of specific size]].  This problem is similar to [[id:798B6359-F1A6-4B42-BBA1-2120D8CD228B][Sliding Window Maximum]].  Time and space complexity are $O(n)$.

#+begin_src python
  from typing import List
  from collections import deque


  class Solution:
      def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
          q = deque()
          ans = []
          for i in range(len(nums)):
              while q and i - q[0] >= k:
                  q.popleft()
              while q and nums[q[-1]] <= nums[i]:
                  q.pop()
              q.append(i)
              if i + 1 >= k:
                  ans.append(nums[q[0]])
          return ans


  assert Solution().maxSlidingWindow([1, 3, -1, -3, 5, 3, 6, 7], 3) == [3, 3, 5, 5, 6, 7]
  assert Solution().maxSlidingWindow([1], 1) == [1]
#+end_src

* Leetcode: 818. Race Car
:PROPERTIES:
:ID:       3904F180-0CAC-46C5-8ECE-2DAB9517B777
:END:
:LOGBOOK:
CLOCK: [2022-07-16 Sat 17:00]--[2022-07-16 Sat 18:15] =>  1:15
:END:
[[https://leetcode.com/problems/race-car/][Problem Statement]]

- [[id:298CCCF3-C9A7-4FEC-BE7B-17CF0F67332C][Mistake: Bug caused by incorrect assumption]].  Started to look for prunes and added one to avoid numbers greater than ~target~.
- [[id:3C649CC4-0609-4686-96C3-5F774F9C0292][Mistake: Failed to consider different strategies to solve the problem]].  Came up with [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] and didn't ask myself if I could solve the problem using [[id:241ABA4C-A86F-405F-B6FC-85BF441EB24B][Dynamic Programming]].
- [[id:27524F0A-5DA2-4768-8897-2934633CB62F][Mistake: Missing inspection of test cases]].  The test case ~5~ gave a hint which I didn't see because I rushed to code the BFS.

[[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  As in [[id:B9F5B1C1-6ED3-49C5-9AA1-6F0D56434720][Leetcode: 1675. Minimize Deviation in Array]], we can reduce the number of different operations by thinking on the problem to get from $0$ to $i$ only doing forward moves.  $dp[i]$ is the number of steps to get from $0$ to $i$ starting with speed 1.  The best way to get close to $i$ is to accelerate as much as possible.  Be $j$ the closest position to $i$ that we can get accelerating $t$ times at speed $s$.  If $i=j$, the solution is $dp[i]=t$.  Otherwise, $j<i$ and you can either go back to $k$ accelerating $p$ times and then try to go to $i$ or accelerate one more time and then go back to $i$.  Therefore, $dp[i]=min(t + 1 + p + 1 + dp[i - (j - k)], t + 1 + dp[t + s - i] + 1)$ for all $k$.  In summary, the idea is to define the search-space as distances from $0$ to $i$ where $0 \leq i \leq target$.  Space complexity is $O(target)$ and time complexity is $O(target \times \log(target))$.

#+begin_src python
  class Solution:
      def racecar(self, target: int) -> int:
          dp = [0] * (target + 1)
          dp[0] = 0

          def stops(target):
              pos = 0
              speed = 1
              steps = 0
              yield (pos, speed, steps)
              while pos + speed <= i:
                  pos += speed
                  speed *= 2
                  steps += 1
                  yield (pos, speed, steps)


          for i in range(1, target + 1):
              ,*_, (pos, speed, steps) = stops(i)
              if pos == i:
                  dp[i] = steps
                  continue

              dp[i] = steps + 1 + dp[(pos + speed) - i] + 1
              for rpos, _, rsteps in stops(pos):
                  dp[i] = min(dp[i], steps + 1 + rsteps + 1 + dp[i - (pos - rpos)])

          return dp[target]

  assert Solution().racecar(3) == 2
  assert Solution().racecar(6) == 5

#+end_src

[[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] solution starts by doing as much ~A~ as possible and them searching for the optimal path:
#+begin_src python
  class Solution:
      def racecar(self, target: int) -> int:
          seen = set()

          pos = 0
          speed = 1
          steps = 0
          while pos + speed <= target:
              pos += speed
              speed *= 2
              steps += 1

          queue = [(pos, speed, steps)]
          for pos, speed, steps in queue:
              if pos == target:
                  return steps

              if (pos, speed) in seen:
                  continue
              seen.add((pos, speed))

              queue.append((pos + speed, speed * 2, steps + 1))
              if speed > 0:
                  queue.append((pos, -1, steps + 1))
              else:
                  queue.append((pos, +1, steps + 1))


  assert Solution().racecar(3) == 2
  assert Solution().racecar(6) == 5
#+end_src

* Leetcode: 1289. Minimum Falling Path Sum II
:PROPERTIES:
:ID:       629C75D4-0704-4D15-8D20-F818DBCB5F61
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-17 Sun 14:54]--[2022-07-17 Sun 15:26] =>  0:32
:END:
[[https://leetcode.com/problems/minimum-falling-path-sum-ii/][Problem Statement]]

- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]].  First solution was $O(n^4)$ which was solution after manual test with $100 \times 100$ grid.
- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]],  where you had a fast way to pick the best result from the left and right ([[id:D00AC85C-A22C-4946-B379-812595D8387B][Leetcode: 1563. Stone Game V]]).

[[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem
 in small and easily to solve parts?]]  The best path that ends on $(i, j)$ is either one path that ended on its left or its right.  Be $left(j)$ the minimum path that ended on any of $(i-1, 0), (i-1, 1), .., (i-1, j)$ cells, and $right(j)$ the minimum path that ended on any of $(i-1, j+1), (i-1, j+2), .., (i-1, M-1)$.  Given that, we can compute $dp[i][j]=grid[i][j]+min(left[j-1], right[j+1])$.  Time and space complexity is $O(n^2)$.

#+begin_src python
  from typing import List


  class Solution:
      def minFallingPathSum(self, grid: List[List[int]]) -> int:
          N = len(grid)
          M = len(grid[0])

          if N == 1 and M == 1:
              return grid[0][0]

          dp = [[float("inf")] * M for _ in range(N)]
          left = [float("inf")] * M
          right = [float("inf")] * M

          for i in range(N):
              for j in range(M):
                  if i == 0:
                      dp[i][j] = grid[i][j]
                      continue

                  dp[i][j] = grid[i][j]
                  if j == 0:
                      dp[i][j] += right[j + 1]
                  elif j == M - 1:
                      dp[i][j] += left[j - 1]
                  else:
                      dp[i][j] += min(left[j - 1], right[j + 1])

              if i < M - 1:
                  for j in range(M):
                      left[j] = min(dp[i][j], float("inf") if j == 0 else left[j - 1])
                  for j in range(M - 1, -1, -1):
                      right[j] = min(
                          dp[i][j], float("inf") if j == M - 1 else right[j + 1]
                      )

          return min(dp[N - 1][j] for j in range(M))


  assert Solution().minFallingPathSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 13
  assert Solution().minFallingPathSum([[7]]) == 7
#+end_src

* Leetcode: 1987. Number of Unique Good Subsequences
:PROPERTIES:
:ID:       A2635C55-6A7B-4295-A3B5-E1A7C8861F11
:END:
:LOGBOOK:
CLOCK: [2022-07-17 Sun 19:06]--[2022-07-17 Sun 20:23] =>  1:17
CLOCK: [2022-07-17 Sun 16:15]--[2022-07-17 Sun 17:07] =>  0:52
:END:
[[https://leetcode.com/problems/number-of-unique-good-subsequences/][Problem Statement]]

- [[id:298CCCF3-C9A7-4FEC-BE7B-17CF0F67332C][Mistake: Bug caused by incorrect assumption]].  I re-wrote part of the code, but didn't check if I had to update the other part of the code.

[[id:BA632D61-93B6-47AB-B11A-7E9EBE3FC71D][Can we derive an invariant based on the smallest possible examples?]]  First, I generated all unique substrings of the string "1001" to see if a pattern emerge:

#+begin_example
  1
  xxx1
  2
  xx0x
  xx01
  2
  x00x
  x001
  5
  1xx1
  1x0x
  1x01
  100x
  1001
#+end_example

Let's compute $dp[i]$ which is the number of unique subsequences starting on $i$.  Let's do it from *left to right*.  Therefore, $dp[N - 1]=1$.  Be $i, j$ indexes where $i < j$, $binary[i]=binary[j]$ and $binary[i] \neq binary[k]$ for $i < k < j$.  Suppose that $binary[i]=1$.  Note that we can extend by one all unique subsequence starting with 1 (i.e. $binary[i]$) and they will all be unique.  Besides that, we can also extend all subsequences starting with 0 (i.e. $binary[i+1], binary[i+2], .., binary[j-1]$) by one and they will all be unique.  So, in this case, $dp[i]=dp[i+1]+dp[i+2]+...+dp[j]$.  We can't compute this sum, since $O(n^2)$ will not make the cut.  Note that if there are no zeros between $i$ and $j$, $dp[i]=dp[j]$.  This means that $dp[i+1]=dp[i+2]=...=dp[j-1]$, since they are computed similarly to the way we compute $dp$ for ones.  Therefore, $dp[i]=dp[i+1] \times (j - i) + dp[j]$.  To compute $dp$ efficiently, we can keep track of the last one and last zero and use it to compute $dp$.  Time and space is $O(n)$.

#+begin_src python
  class Solution:
      def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
          MOD = 10**9 + 7
          N = len(binary)

          dp = [0] * N
          dp[N - 1] = 1
          last = {}
          last["1"], last["0"] = (N - 1, None) if binary[-1] == "1" else (None, N - 1)

          for i in range(N - 2, -1, -1):
              b = binary[i]
              if last[b] is None:
                  dp[i] = N - i
              else:
                  if last[b] - i == 1:
                      dp[i] = dp[i + 1]
                  else:
                      dp[i] = (dp[last[b]] + dp[i + 1] * (last[b] - i - 1)) % MOD
              last[b] = i

          extra = 1 if "0" in binary else 0
          return (sum(dp[i] for i in range(N) if binary[i] == "1") + extra) % MOD


  assert Solution().numberOfUniqueGoodSubsequences("001") == 2
  assert Solution().numberOfUniqueGoodSubsequences("11") == 2
  assert Solution().numberOfUniqueGoodSubsequences("101") == 5
#+end_src

[[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  Other way to solve the problem is counting the unique subsequences from *right to left* which means that extend the unique subsequences that ended with 1 and 0 so far.  Be $e0$ and $e1$ the number of unique subsequences that end with zero and one respectively.  If the current number is 0, we will have all subsequences that ended with zero plus all subsequences that ended with one but now ending on zero.  So, $e0 = e0 + e1$.  If the current number is 1, we will have the same but we have to re-add ~1~ to the count.  So, $e1 = e0 + e1 + 1$.  Time complexity is $O(n)$ and space is $O(1)$.

#+begin_src python
  class Solution:
      def numberOfUniqueGoodSubsequences(self, binary: str) -> int:
          MOD = 10**9 + 7

          count_zero = False
          e1 = 0
          e0 = 0
          for b in binary:
              if b == "0":
                  e0 = (e0 + e1) % MOD
                  count_zero = True
              else:
                  e1 = (e1 + e0 + 1) % MOD

          return (e1 + e0 + (1 if count_zero else 0)) % MOD


  assert Solution().numberOfUniqueGoodSubsequences("001") == 2
  assert Solution().numberOfUniqueGoodSubsequences("11") == 2
  assert Solution().numberOfUniqueGoodSubsequences("101") == 5
#+end_src

* Leetcode: 124. Binary Tree Maximum Path Sum
:PROPERTIES:
:ID:       D188B6DB-A827-4A63-B794-8708CEFB58B7
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-17 Sun 22:18]--[2022-07-17 Sun 22:36] =>  0:18
:END:
[[https://leetcode.com/problems/binary-tree-maximum-path-sum/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  The problem felt simple and I skipped the phase to create edge cases.
- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]].  Find the longest path in a tree which can be solved with two [[id:212DBFC3-FE3C-493E-86A6-42FF3F82CD53][Depth-first search]].

[[id:31D0B1E0-6881-478A-8F48-160BCFD94F31][Can we divide the search-space in two parts and combine solutions from both sides to solve the original problem?]]  Be $u$ a node in the tree.  Find the maximum path starting from the left $l$ and from the right $r$ of $u$.  The maximum path starting from $u$ is either $val(u)$, $val(u)+l$ or $val(u)+r$.  To compute the final answer, we still have to consider $u$ as the root of the maximum path: $val(u)+l+r$.  Time complexity is $O(n)$ and space complexity is $O(depth)$.

#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution:
      def maxPathSum(self, root: Optional[TreeNode]) -> int:
          ans = float("-inf")

          def dfs(node):
              nonlocal ans

              if node is None:
                  return 0

              lans = dfs(node.left) if node.left else float("-inf")
              rans = dfs(node.right) if node.right else float("-inf")
              cur = max(
                  node.val,
                  node.val + lans,
                  node.val + rans,
              )
              ans = max(ans, cur, node.val + lans + rans)

              return cur

          dfs(root)

          return ans
#+end_src

* Leetcode: 759. Employee Free Time
:PROPERTIES:
:ID:       976BF4D9-247A-4247-86C7-06D7B0C793FA
:END:
:LOGBOOK:
CLOCK: [2022-07-18 Mon 08:00]--[2022-07-18 Mon 08:14] =>  0:14
CLOCK: [2022-07-18 Mon 07:48]--[2022-07-18 Mon 07:54] =>  0:06
:END:
[[https://leetcode.com/problems/employee-free-time/][Problem Statement]]

- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]] with intervals where you used a [[id:06D27BC1-DFDC-4063-B3A9-7074FD5E13B3][Stack]] to compute the answer, and I solved a problem to create a sorted list from a list of sorted lists ([[id:02D2E665-4FC5-45C7-A1BF-E7CE82E67B05][Leetcode: 23. Merge k Sorted Lists]]).

- [[id:42B21DBC-4951-4AF2-8C41-A646F5675365][Can we pre-process the input in a way to make easy to solve the problem?]]  We can create a list of all intervals sorted by start time.  This will help us to process all of them as they come.

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  Be $a$ an array with all intervals sorted by start time.  We know that if there is a time off, it will definitely start after $a[0].end$.  If $a[1].start > a[0].end$, then there is a time off from $(a[0].end, a[1].start)$.  If $a[1].start \leq a[0].end$, then the time off might start at $\max(a[0].end, a[1].end)$.  This property holds for all intervals.  Therefore, we can keep a variable with the last end time and use it to create a new interval if needed or update it.  Time complexity is $O(n \log m$ where $m$ is the total number of intervals, because we use a [[id:FCBEA48C-CFF6-43C4-B430-BCD00E245D22][Priority-Queue]] to get the next interval sorted by start time.  Space complexity is $O(m)$.

#+begin_src python
  """
  # Definition for an Interval.
  class Interval:
      def __init__(self, start: int = None, end: int = None):
          self.start = start
          self.end = end
  """

  class Solution:
      def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':
          def intervals():
              pq = []
              for i, s in enumerate(schedule):
                  heappush(pq, (s[0].start, s[0].end, i, 0))
              while len(pq) > 0:
                  start, end, i, j = heappop(pq)
                  yield (start, end)
                  if j + 1 < len(schedule[i]):
                      heappush(pq, (schedule[i][j+1].start, schedule[i][j+1].end, i, j + 1))

          ans = []
          last = None
          for start, end in intervals():
              if last is None:
                  last = end
              elif start > last:
                  ans.append(Interval(last, start))
                  last = end
              else:
                  last = max(last, end)
          return ans
#+end_src

* Leetcode: 489. Robot Room Cleaner
:PROPERTIES:
:ID:       5A7676EA-96E2-42DE-B950-1B082F42CD92
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-19 Tue 10:37]--[2022-07-19 Tue 10:54] =>  0:17
CLOCK: [2022-07-19 Tue 10:05]--[2022-07-19 Tue 10:25] =>  0:20
CLOCK: [2022-07-18 Mon 09:59]--[2022-07-18 Mon 10:56] =>  0:57
:END:
[[https://leetcode.com/problems/robot-room-cleaner][Problem Statement]]

- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]]. My first idea was to make a [[id:212DBFC3-FE3C-493E-86A6-42FF3F82CD53][Depth-first search]], but spent much of the time thinking about other ways to do the search.

#+begin_src python
  # """
  # This is the robot's control interface.
  # You should not implement it, or speculate about its implementation
  # """
  #class Robot:
  #    def move(self):
  #        """
  #        Returns true if the cell in front is open and robot moves into the cell.
  #        Returns false if the cell in front is blocked and robot stays in the current cell.
  #        :rtype bool
  #        """
  #
  #    def turnLeft(self):
  #        """
  #        Robot will stay in the same cell after calling turnLeft/turnRight.
  #        Each turn will be 90 degrees.
  #        :rtype void
  #        """
  #
  #    def turnRight(self):
  #        """
  #        Robot will stay in the same cell after calling turnLeft/turnRight.
  #        Each turn will be 90 degrees.
  #        :rtype void
  #        """
  #
  #    def clean(self):
  #        """
  #        Clean the current cell.
  #        :rtype void
  #        """

  class Solution:
      def cleanRoom(self, robot):
          """
          :type robot: Robot
          :rtype: None
          """

          DIR = [[-1, +0], [+0, -1], [+1, +0], [+0, +1]]

          seen = set()
          def dfs(i, j, d):
              if (i, j, d) in seen:
                  return
              robot.clean()
              seen.add((i, j, d))

              if robot.move():
                  dfs(i + DIR[d][0], j + DIR[d][1], d)
                  robot.turnLeft()
                  robot.turnLeft()
                  robot.move()
                  robot.turnLeft()
                  robot.turnLeft()

              for k in range(3):
                  robot.turnLeft()
                  dfs(i, j, (d + k + 1) % len(DIR))
              robot.turnLeft()

          dfs(0, 0, 0)
#+end_src

* Leetcode: 778. Swim in Rising Water
:PROPERTIES:
:ID:       290376A3-74DD-4708-BA4F-8FDA493EBB1A
:END:
:LOGBOOK:
CLOCK: [2022-07-19 Tue 15:35]--[2022-07-19 Tue 15:51] =>  0:16
:END:
[[https://leetcode.com/problems/swim-in-rising-water/][Problem Statement]]

- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]] with increasing paths on grid and sorting the cells was useful.
- [[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  This is a variation of [[id:8BACB101-3C8B-47CA-9AB1-89D52F85F6DA][Shortest Path in a Graph Problem]] and can be solved using [[id:3D4A4826-ADA4-4975-9C9E-C8B6AF39E01A][Dijkstra Algorithm]].  Instead of adding up to compute the distance, we take the vertices with greatest value in the path so far.
- Time complexity is $O(n^2 \log n)$ and space is $O(n^2)$.

#+begin_src python
  from typing import List
  from heapq import heappush, heappop


  class Solution:
      def swimInWater(self, grid: List[List[int]]) -> int:
          N = len(grid)

          seen = set((grid[0][0], 0, 0))
          pq = [(grid[0][0], 0, 0)]

          while pq:
              t, i, j = heappop(pq)

              if i == N - 1 and j == N - 1:
                  return t

              for ni, nj in [[i, j + 1], [i, j - 1], [i + 1, j], [i - 1, j]]:
                  if 0 <= ni < N and 0 <= nj < N and (ni, nj) not in seen:
                      seen.add((ni, nj))
                      heappush(pq, (max(grid[ni][nj], t), ni, nj))


  assert Solution().swimInWater([[0, 2], [1, 3]]) == 3
  assert (
      Solution().swimInWater(
          [
              [0, 1, 2, 3, 4],
              [24, 23, 22, 21, 5],
              [12, 13, 14, 15, 16],
              [11, 17, 18, 19, 20],
              [10, 9, 8, 7, 6],
          ]
      )
      == 16
  )
#+end_src

* Leetcode: 715. Range Module
:PROPERTIES:
:ID:       AEBE4500-C0FA-498A-889E-17F8A1C7ECCF
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-19 Tue 21:57]--[2022-07-19 Tue 22:46] =>  0:49
CLOCK: [2022-07-19 Tue 19:34]--[2022-07-19 Tue 19:52] =>  0:18
CLOCK: [2022-07-19 Tue 18:32]--[2022-07-19 Tue 19:12] =>  0:40
:END:
[[https://leetcode.com/problems/range-module/][Problem Statement]]

- [[id:00CC89B4-340B-4219-9CF4-837F558947B4][Mistake: Bug caused by debug code]]

- [[id:EEDBE877-7C4A-4D0B-BA6B-EFDF9288B78C][Blackbox: This is a variation of a classic problem]]: [[id:8564CEB1-3E95-4A34-B888-0BCE6D6504B8][Lazy Segment Tree]].

The solution with [[id:8564CEB1-3E95-4A34-B888-0BCE6D6504B8][Lazy Segment Tree]] has time complexity of $O(n \log m)$ where $m$ is the maximum value in the interval, and space complexity of $O(n)$:
#+begin_src python
  class RangeModule:
      def __init__(self, left=1, right=10**9, full=False):
          self.left = left
          self.mid = left + (right - left) // 2
          self.right = right
          self.left_child = self.right_child = None
          self.full = full

      def addRange(self, left: int, right: int) -> None:
          self._update(left, right - 1, True)

      def removeRange(self, left: int, right: int) -> None:
          self._update(left, right - 1, False)

      def queryRange(self, left: int, right: int) -> bool:
          return self._query(left, right - 1)

      def _query(self, left: int, right: int) -> bool:
          if self.right < left or right < self.left:
              return True

          self._extend()
          if self.full or left <= self.left <= self.right <= right:
              return self.full

          return self.left_child._query(left, right) and self.right_child._query(
              left, right
          )

      def _update(self, left: int, right: int, value: bool) -> None:
          if self.right < left or right < self.left:
              return
          if left <= self.left <= self.right <= right:
              self.left_child = None
              self.right_child = None
              self.full = value
              return
          self._extend()
          self.left_child._update(left, right, value)
          self.right_child._update(left, right, value)
          self.full = self.left_child.full and self.right_child.full

      def _extend(self) -> None:
          if self.left_child is None and self.left < self.right:
              m = self.left + (self.right - self.left) // 2
              self.left_child = RangeModule(self.left, m, self.full)
              self.right_child = RangeModule(m + 1, self.right, self.full)

      def _print(self, level=0):
          print(" " * level, self.left, self.right, self.full)
          if self.left_child:
              self.left_child._print(level + 1)
              self.right_child._print(level + 1)


  # Your RangeModule object will be instantiated and called as such:
  # obj = RangeModule()
  # obj.addRange(left,right)
  # param_2 = obj.queryRange(left,right)
  # obj.removeRange(left,right)
#+end_src


** TODO Write solution using array of indexes

The idea is to represent intervals in an array where even number are start of intervals and odd indexes are end of intervals.

#+begin_example
  ["RangeModule","addRange","removeRange","queryRange","queryRange","queryRange"]
  [[],[10,20],[14,16],[10,14],[13,15],[16,17]]
  ["RangeModule","addRange","addRange","removeRange","queryRange","queryRange","removeRange","removeRange","removeRange","removeRange","removeRange","queryRange","removeRange","addRange","removeRange","addRange","queryRange","queryRange","addRange","addRange","queryRange","removeRange","queryRange","addRange","queryRange","removeRange","removeRange","addRange","addRange","removeRange","removeRange","removeRange","addRange","addRange","queryRange","queryRange","queryRange","queryRange","queryRange","removeRange","removeRange","queryRange","addRange","addRange","addRange","queryRange","addRange","addRange","removeRange","addRange","queryRange","removeRange","addRange","queryRange","addRange","addRange","addRange","queryRange","addRange","queryRange","removeRange","removeRange","removeRange","removeRange","queryRange","removeRange","queryRange","queryRange","removeRange","queryRange","addRange","addRange","queryRange","removeRange","removeRange","queryRange","addRange","removeRange","removeRange","addRange","addRange","addRange","queryRange","queryRange","addRange","queryRange","removeRange","queryRange","removeRange","addRange","queryRange"]
  [[],[55,62],[1,29],[18,49],[6,98],[59,71],[40,45],[4,58],[57,69],[20,30],[1,40],[73,93],[32,93],[38,100],[50,64],[26,72],[8,74],[15,53],[44,85],[10,71],[54,70],[10,45],[30,66],[47,98],[1,7],[44,78],[31,49],[62,63],[49,88],[47,72],[8,50],[49,79],[31,47],[54,87],[77,78],[59,100],[8,9],[50,51],[67,93],[25,86],[8,92],[31,87],[90,95],[28,56],[10,42],[27,34],[75,81],[17,63],[78,90],[9,18],[51,74],[20,54],[35,72],[2,29],[28,41],[17,95],[73,75],[34,43],[57,96],[51,72],[21,67],[40,73],[14,26],[71,86],[34,41],[10,25],[27,68],[18,32],[30,31],[45,61],[64,66],[18,93],[13,21],[13,46],[56,99],[6,93],[25,36],[27,88],[82,83],[30,71],[31,73],[10,41],[71,72],[9,56],[22,76],[38,74],[2,77],[33,61],[74,75],[11,43],[27,75]]
#+end_example

* Leetcode: 2158. Amount of New Area Painted Each Day
:PROPERTIES:
:ID:       2C7437BC-7DD0-460F-91DE-E3C915DC3731
:END:
:LOGBOOK:
CLOCK: [2022-07-21 Thu 09:09]--[2022-07-21 Thu 09:14] =>  0:05
CLOCK: [2022-07-20 Wed 22:38]--[2022-07-21 Thu 09:07] => 10:29
:END:
[[https://leetcode.com/problems/amount-of-new-area-painted-each-day/][Problem Statement]]

- [[id:56B18554-8EDB-44AF-B72A-8FD307B2980C][Mistake: High constant factor in the implementation]].  Did not optimize when query an interval that was already full.
- [[id:EEDBE877-7C4A-4D0B-BA6B-EFDF9288B78C][Blackbox: This is a variation of a classic problem]]: [[id:252C5055-2C0D-4B0E-A4BF-9507B85A179F][Segment Tree]]

- [[id:37B33434-71C2-4E55-9121-5D6855D8E169][Can we formulate the problem using a segment tree?]]  Suppose we have a [[id:8564CEB1-3E95-4A34-B888-0BCE6D6504B8][Lazy Segment Tree]] covering the full range (1 to $10^5$).  The problem adding intervals to the segment tree while computing the number of new points covered.  Time complexity is $O(n \log m)$ with space $O(min(m, n))$.

#+begin_src python
  from typing import List


  class SegTree:
      def __init__(self, left, right, count=0):
          self.left = left
          self.mid = left + (right - left) // 2
          self.right = right
          self.count = count
          self.left_child = self.right_child = None

      def add(self, left, right):
          if self.right < left or right < self.left:
              return 0
          if self.is_full() or left <= self.left <= self.right <= right:
              self.left_child = None
              self.right_child = None
              self.fill()
              return self.count
          self._extend()
          self.left_child.add(left, right)
          self.right_child.add(left, right)
          before = self.count
          after = self.count = self.left_child.count + self.right_child.count
          return after - before

      def is_full(self):
          return self.count == self.right - self.left + 1

      def fill(self):
          self.count = self.right - self.left + 1

      def _extend(self):
          if self.left_child is None and self.left < self.right:
              self.left_child = SegTree(self.left, self.mid)
              self.right_child = SegTree(self.mid + 1, self.right)
              if self.is_full():
                  self.left_child.fill()
                  self.right_child.fill()

      def _print(self, level=0):
          print(" " * level, (self.left, self.right), self.count)
          if self.left_child:
              self.left_child._print(level + 1)
              self.right_child._print(level + 1)


  class Solution:
      def amountPainted(self, paint: List[List[int]]) -> List[int]:
          st = SegTree(0, 50_000 + 1)
          ans = []
          for start, end in paint:
              ans.append(st.add(start, end - 1))
          return ans


  assert Solution().amountPainted([[1, 4], [4, 7], [5, 8]]) == [3, 3, 1]
  assert Solution().amountPainted([[1, 4], [5, 8], [4, 7]]) == [3, 3, 1]
  assert Solution().amountPainted([[1, 5], [2, 4]]) == [4, 0]
#+end_src

- [[id:29512D97-A54D-42F9-A8C7-C3422881933B][Can we use brute-force to solve the problem?]]  The brute-force means painting every single point and for that the answer is no.  But we can improve on the brute-force algorithm by tracking the next possible empty cell using an array $nxt$.  While processing $paint[i]$, we can set $nxt[paint[i].start]=nxt[paint[i].start+1]=..=nxt[paint[i].end-1]=paint[i].end$.  So, the next time that we reach any of those cells, we can jump directly to $nxt[paint[i].end]$.

#+begin_src python
  class Solution:
      def amountPainted(self, paint: List[List[int]]) -> List[int]:
          N = len(paint)
          nxt = [None for i in range(50_001)]
          ans = []
          for start, end in paint:
              cur = 0
              while start < end:
                  if nxt[start] is None:
                      nxt[start] = end
                      cur += 1
                      start += 1
                  else:
                      nstart = nxt[start]
                      nxt[start] = max(nxt[start], end)
                      start = nstart
              ans.append(cur)
          return ans
#+end_src

- [[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  The graph starts with $m$ vertices and no edges.  We process each paint on order and create the edges $(paint[i].start, paint[i].start+1), (paint[i].start+1, paint[i].start+2), ..., (paint[i].end-1, paint[i].end)$.  While adding the edges to the graph, we keep track of the components created using [[id:23A4E36E-24D3-40F8-AA20-32C0DB1E36F6][Union-Find]].  Each component is rooted on the left-most position in the component.  So, adding an edge $(u, u+1)$, we can jump to $find(u+1)$ since it is the next available point to paint.

#+begin_src python
  class Solution:
      def amountPainted(self, paint: List[List[int]]) -> List[int]:
          N = len(paint)
          p = [i for i in range(50_001)]
          ans = []

          def find(a):
              if p[a] == a:
                  return a
              p[a] = find(p[a])
              return p[a]

          def union(a, b):
              assert b > a
              pa = find(a)
              pb = find(b)
              p[pa] = pb
              return pb

          for start, end in paint:
              cur = 0
              start = find(start)
              while start < end:
                  start = union(start, start + 1)
                  cur += 1
              ans.append(cur)
          return ans
#+end_src

* Leetcode: 1610. Maximum Number of Visible Points
:PROPERTIES:
:ID:       3D1697BA-4AFC-47E7-83A5-56413F279DDF
:END:
:LOGBOOK:
CLOCK: [2022-07-21 Thu 18:00]--[2022-07-21 Thu 20:32] =>  2:32
:END:
[[https://leetcode.com/problems/maximum-number-of-visible-points/][Problem Statement]]

[[id:46522C06-DAC3-4986-A13A-17C2ED44ADD1][Can we formulate the problem as sliding window?]]  Create the window with the first points that don't exceed the given angle and after that insert point by point removing ones from the beginning while the window is invalid.  The trick is that you have to replicate the points because this is a circular sliding window problem.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  from typing import List


  def sub_points(pa, pb):
      return [pa[0] - pb[0], pa[1] - pb[1]]


  def angle_in_radians(p):
      return atan2(p[1], p[0])


  class Solution:
      def visiblePoints(
          self, points: List[List[int]], angle: int, location: List[int]
      ) -> int:
          _points, points = points, [
              sub_points(p, location) for p in points if p != location
          ]
          points.sort(key=angle_in_radians)
          rads = [angle_in_radians(p) for p in points] + [
              angle_in_radians(p) + 2 * pi for p in points
          ]

          N = len(rads)
          R = radians(angle)
          extra = len(_points) - len(points)
          ans = 0

          start = 0
          end = 0
          while end < N:
              while rads[end] - rads[start] > R:
                  start += 1
              ans = max(ans, end - start + 1)
              end += 1

          return ans + extra


  assert Solution().visiblePoints([[2, 1], [2, 2], [3, 3]], 90, [1, 1]) == 3
  assert Solution().visiblePoints([[2, 1], [2, 2], [3, 4], [1, 1]], 90, [1, 1]) == 4
  assert Solution().visiblePoints([[1, 0], [2, 1]], 13, [1, 1]) == 1
#+end_src

* Leetcode: 552. Student Attendance Record II
:PROPERTIES:
:ID:       18394CF2-A8EC-41C0-8BCB-FADCCE1C9448
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-21 Thu 21:59]--[2022-07-21 Thu 23:20] =>  1:21
:END:
[[https://leetcode.com/problems/student-attendance-record-ii/][Problem Statement]]

- [[id:AC9291C6-4C72-4143-80F2-0D414EF7B681][Mistake: Did not try hard to solve alternative problem]].  I found that I had to treat records with ~A~ separately, but I didn't try hard to find its formula.  Instead, I work the recurrence with ~A~, ~L~, and ~P~ which is way more complex than the first one.

- [[id:56B18554-8EDB-44AF-B72A-8FD307B2980C][Mistake: High constant factor in the implementation]].  Python's map is slow when looking up $10^5$ elements.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Be $f(d, s)$ the number of different records ending with status $s$ on the day $d$.  Be $g(d)$ the number of different records with $d$ days.  If there is no absence, then we have at least $x=f(d, L)+f(d, P)$ different records.  For each day $i$ that we can be absent, we have $y=\max(1, f(i-1,L)+f(i-1,P)) \times \max(1, f(n - i, L) + f(n - i, P))$ possible records.  So, $g(d)=x+y$.  Time and space complexity is $O(n)$.

#+begin_src python
  class Solution:
      def checkRecord(self, n: int) -> int:
          MOD = 10**9 + 7
          ans = 0

          L = 0
          P = 1
          dp = [[0, 0] for _ in range(n + 2)]

          dp[0][L] = dp[0][P] = 0
          dp[1][L] = dp[1][P] = 1
          dp[2][L] = dp[2][P] = 2

          for day in range(3, n + 1):
              dp[day][L] = (dp[day - 2][P] + dp[day - 1][P]) % MOD
              dp[day][P] = (dp[day - 1][L] + dp[day - 1][P]) % MOD

          def a(day):
              return (dp[day][L] + dp[day][P]) % MOD

          ans = a(n)
          for day in range(1, n + 1):
              ans = (ans + max(a(day - 1), 1) * max(a(n - day), 1)) % MOD
          return ans


  assert Solution().checkRecord(2) == 8
  assert Solution().checkRecord(1) == 3
  assert Solution().checkRecord(10101) == 183236316
#+end_src

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  The valid suffixes for a record are $XP$, $YPL$ and $ZPLL$, where $X$, $Y$ and $Z$ are records of size $n-1, n-2$ and $n-3$ respectively.  As these suffixes are mutually exclusive, we can compute the number of different records with only ~L~ and ~P~ as $f(d)=f(d-1)+f(d-2)+f(d-3)$.  To compute $g(d)$, we use the same trick as the above solution.  Time and space complexity is $O(n)$.

#+begin_src python
  class Solution:
      def checkRecord(self, n: int) -> int:
          MOD = 10**9 + 7

          dp = [0] * (n + 10)
          dp[0] = 1
          dp[1] = 2
          dp[2] = 4
          dp[3] = 7

          for day in range(4, n + 1):
              dp[day] = (dp[day - 1] + dp[day - 2] + dp[day - 3]) % MOD

          ans = dp[n]
          for day in range(1, n + 1):
              ans = (ans + dp[day - 1] * dp[n - day]) % MOD
          return ans


  assert Solution().checkRecord(2) == 8
  assert Solution().checkRecord(1) == 3
  assert Solution().checkRecord(10101) == 183236316
#+end_src

* Leetcode: 2242. Maximum Score of a Node Sequence
:PROPERTIES:
:ID:       E1B5330F-BC4C-499D-9422-A9AFA474D20F
:END:
:LOGBOOK:
CLOCK: [2022-07-22 Fri 08:03]--[2022-07-22 Fri 08:19] =>  0:16
:END:
[[https://leetcode.com/problems/maximum-score-of-a-node-sequence/][Problem Statement]]

- [[id:DD73E390-3303-40F8-9CE1-D1ED048D9588][How can we find the solution knowing part of it?]]  Be $(u, v)$ the central edge of the maximum path.  We have to find its extreme vertices $p$ and $q$, since the maximum path must have length 4.  We can find those vertices by searching through the top-4 vertices connected with $u$ and $v$.  Time and space complexity is $O(n)$.

#+begin_src python
  from typing import List
  from heapq import heappush, heappop


  class Solution:
      def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
          N = len(scores)
          candidates = [[] for _ in range(N)]

          def add_candidate(u, v):
              heappush(candidates[u], (scores[v], v))
              if len(candidates[u]) > 4:
                  heappop(candidates[u])

          for u, v in edges:
              add_candidate(u, v)
              add_candidate(v, u)

          ans = -1
          for u, v in edges:
              for pscore, p in candidates[u]:
                  if p == v:
                      continue
                  for qscore, q in candidates[v]:
                      if q == u or q == p:
                          continue
                      ans = max(ans, pscore + qscore + scores[u] + scores[v])
          return ans


  assert (
      Solution().maximumScore(
          [5, 2, 9, 8, 4], [[0, 1], [1, 2], [2, 3], [0, 2], [1, 3], [2, 4]]
      )
      == 24
  )
  assert (
      Solution().maximumScore([9, 20, 6, 4, 11, 12], [[0, 3], [5, 3], [2, 4], [1, 3]])
      == -1
  )
#+end_src

* Leetcode: 2035. Partition Array Into Two Arrays to Minimize Sum Difference
:PROPERTIES:
:ID:       A669D90C-A9DD-4A43-AE69-AB90D8197A00
:END:
:LOGBOOK:
CLOCK: [2022-07-22 Fri 13:35]--[2022-07-22 Fri 13:54] =>  0:19
CLOCK: [2022-07-22 Fri 10:15]--[2022-07-22 Fri 11:14] =>  0:59
CLOCK: [2022-07-22 Fri 08:54]--[2022-07-22 Fri 08:56] =>  0:02
:END:
[[https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/][Problem Statement]]

- Blackbox: Split the input.  We have to split the array in the half and its size is $2 \times n$ with $1 \leq n \leq 15$.  My intuition focused on the fact that $2^15$ isn't too much to compute.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Generate all possible sums with $0, 1, 2, ..., n / 2$ numbers for the first half of the array.  Do the same for the other side.  Suppose that we picked $A$ numbers from the first half.  We have to pick $B$ numbers from the other side to build a valid array where $|B|=n/2-|A|$.  For each $a$ in $A$, we can find the number in $B$ closest as possible to $S/2-a$ using [[id:5CDA0F71-AED2-47E7-9BB4-3B66EA8B85BF][Find index of first greater in sorted array]] algorithm, since it will be the one that minimize the difference between the two final arrays.  Time complexity is $O(2^15 \times \log(2^15))$ and space is $O(2^15)$.

#+begin_src python
  from typing import List
  from bisect import bisect_left


  class Solution:
      def minimumDifference(self, nums: List[int]) -> int:
          N = len(nums)
          M = N // 2

          m = min(n for n in nums)
          nums = [m + n for n in nums]
          S = sum(nums)

          a = [set() for _ in range(M + 1)]
          b = [set() for _ in range(M + 1)]

          a[0].add(0)
          b[0].add(0)

          for n in nums[:M]:
              for i in range(M - 1, -1, -1):
                  for k in a[i]:
                      a[i + 1].add(k + n)

          for n in nums[M:]:
              for i in range(M - 1, -1, -1):
                  for k in b[i]:
                      b[i + 1].add(k + n)

          for i in range(M + 1):
              a[i] = sorted(a[i])
              b[i] = sorted(b[i])

          ans = float("inf")
          for i in range(M + 1):
              j = M - i
              for p in a[i]:
                  t = S // 2 - p
                  m = bisect_left(b[j], t)
                  for k in range(max(0, m - 1), min(m + 1, len(b[j]))):
                      ans = min(ans, abs(S - 2 * (p + b[j][k])))

          return ans


  assert Solution().minimumDifference([3, 9, 7, 3]) == 2
  assert Solution().minimumDifference([-36, 36]) == 72
  assert Solution().minimumDifference([2, -1, 0, 4, -2, -9]) == 0
#+end_src

* Leetcode: 726. Number of Atoms
:PROPERTIES:
:ID:       ADDAD428-DB33-4834-929F-A92B78EBC36E
:END:
:LOGBOOK:
CLOCK: [2022-07-22 Fri 14:10]--[2022-07-22 Fri 15:30] =>  1:20
:END:
[[https://leetcode.com/problems/number-of-atoms/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]]: ~(A)2(B)2~.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  The difficult of the problem comes from implementing a parser which you can break-down on ~read_atom~, ~read_int~ and ~parse~.  Time complexity is $O(n^2)$ and space $O(n)$.

#+begin_src python
  class Solution:
      def countOfAtoms(self, formula: str) -> str:
          def read_atom(i):
              assert formula[i].isalpha()
              j = i + 1
              while j < len(formula) and "a" <= formula[j] <= "z":
                  j += 1
              atom = formula[i:j]
              k, count = read_int(j)
              return k, atom, count

          def read_int(i):
              j = i
              while j < len(formula) and "0" <= formula[j] <= "9":
                  j += 1
              return j, 1 if i == j else int(formula[i:j])

          def parse(i, atoms):
              if i == len(formula) or formula[i] == ")":
                  return i, atoms
              elif formula[i] == "(":
                  j, new_atoms = parse(i + 1, {})
                  k, count = read_int(j + 1)
                  for atom in new_atoms:
                      atoms.setdefault(atom, 0)
                      atoms[atom] += new_atoms[atom] * count
                  return parse(k, atoms)
              elif formula[i].isalpha():
                  j, atom, count = read_atom(i)
                  atoms.setdefault(atom, 0)
                  atoms[atom] += count
                  return parse(j, atoms)

          ans = ""
          for atom, count in sorted(parse(0, {})[1].items()):
              ans += atom
              if count > 1:
                  ans += str(count)
          return ans

  assert Solution().countOfAtoms("H2O") == "H2O"
  assert Solution().countOfAtoms("Mg(OH)2") == "H2MgO2"
  assert Solution().countOfAtoms("K4(ON(SO3)2)2") == "K4N2O14S4"
  assert Solution().countOfAtoms("(A)2(B)2") == "A2B2"
#+end_src

* Leetcode: 839. Similar String Groups
:PROPERTIES:
:ID:       80E6FAE6-7CD5-4238-992B-9BF369D02E2B
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-22 Fri 16:00]--[2022-07-22 Fri 16:15] =>  0:15
CLOCK: [2022-07-22 Fri 15:37]--[2022-07-22 Fri 15:39] =>  0:02
:END:
[[https://leetcode.com/problems/similar-string-groups/][Problem Statement]]

- [[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Words are vertices and they are connected if similar.  The problem becomes finding the number of connected components in the graph using [[id:23A4E36E-24D3-40F8-AA20-32C0DB1E36F6][Union-Find]].  Time and space complexity is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def numSimilarGroups(self, strs: List[str]) -> int:
          N = len(strs)
          M = len(strs[0])
          p = [i for i in range(N)]

          def find(u):
              if p[u] == u:
                  return u
              p[u] = find(p[u])
              return p[u]

          def union(u, v):
              gu = find(u)
              gv = find(v)
              p[gu] = gv

          def is_similar(i, j):
              cnt = 0
              for k in range(M):
                  if cnt > 2:
                      return False
                  if strs[i][k] != strs[j][k]:
                      cnt += 1
              return cnt == 0 or cnt == 2

          for i in range(N):
              for j in range(i + 1, N):
                  if is_similar(i, j):
                      union(i, j)

          comps = set(find(i) for i in range(N))
          return len(comps)


  assert Solution().numSimilarGroups(["tars", "rats", "arts", "star"]) == 2
  assert Solution().numSimilarGroups(["omv", "ovm"]) == 1
#+end_src

* Leetcode: 1606. Find Servers That Handled Most Number of Requests
:PROPERTIES:
:ID:       D163B6CA-B6A6-4FE2-9B0E-755FF57AA2F0
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-22 Fri 16:23]--[2022-07-22 Fri 16:55] =>  0:32
:END:
[[https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/][Problem Statement]]

This is a simulation problem where the goal is to pick the right data structures.  Time complexity is $O(n \log m)$ with space $O(n)$.

#+begin_src python
  from typing import List
  from sortedcontainers import SortedList
  from heapq import heappush, heappop


  from sortedcontainers import SortedList


  class Solution:
      def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:
          available = SortedList(range(k))
          cleanup = []
          counter = {}

          busiest_count = 0

          for i, start, time in zip(range(len(arrival)), arrival, load):
              while cleanup and cleanup[0][0] < start:
                  _, server = heappop(cleanup)
                  available.add(server)

              if available:
                  j = available.bisect_left(i % k)
                  server = available[j if j < len(available) else 0]
                  available.remove(server)
                  heappush(cleanup, (start + time - 1, server))
                  counter.setdefault(server, 0)
                  counter[server] += 1
                  busiest_count = max(busiest_count, counter[server])

          return [server for server in counter if counter[server] == busiest_count]


  assert Solution().busiestServers(3, [1, 2, 3, 4, 5], [5, 2, 3, 3, 3]) == [1]
  assert Solution().busiestServers(3, [1, 2, 3, 4], [1, 2, 1, 2]) == [0]
  assert Solution().busiestServers(3, [1, 2, 3], [10, 12, 11]) == [0, 1, 2]
#+end_src

* Leetcode: 1632. Rank Transform of a Matrix
:PROPERTIES:
:ID:       64D350AB-B82B-4923-BA81-4D55335B5BCE
:END:
:LOGBOOK:
CLOCK: [2022-07-24 Sun 20:00]--[2022-07-24 Sun 22:03] =>  2:03
CLOCK: [2022-07-23 Sat 12:07]--[2022-07-23 Sat 12:22] =>  0:15
CLOCK: [2022-07-23 Sat 07:10]--[2022-07-23 Sat 07:20] =>  0:10
:END:
[[https://leetcode.com/problems/rank-transform-of-a-matrix/][Problem Statement]]

- [[id:AC9291C6-4C72-4143-80F2-0D414EF7B681][Mistake: Did not try hard to solve alternative problem]].  I considered the graph formed by rows and cols, but I didn't think about having one graph for each value in the grid.
b
- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]].  My first implementation had vertices as cells and edges between cells with the same value that share the same column and/or row.  The complexity of the solution ended up to be $O((n \times m)^2)$.

- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]] where you had to process the cells in increase order of values.

- [[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  Suppose that we have all cells sorted by value.  The smaller one should have the smallest value in the input.  In order to discover the value of the cell, we have to know the max value used in its column and row (stored in two arrays).  We still have to discover what are the cells (with same value) that have to be updated at the same time.

- [[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  For each different cell value $k$, we will create an [[id:F1D5D810-3FDF-45C3-BAF1-68584BD77DB3][Bipartite Graph]] $g_k$ where vertices of $g_k$ are rows and columns and there is an edge between two vertices $i$ (row) and $j$ (column) if there is $matrix[i][j]=k$.  In this graph, we can use [[id:23A4E36E-24D3-40F8-AA20-32C0DB1E36F6][Union-Find]] to find the components of the graph and therefore discovering the cells that have to be updated together.

- Time and space complexity is $O(n \times m)$.

#+begin_src python
  from typing import List
  from collections import defaultdict


  class UnionFind:
      def __init__(self):
          self.p = {}

      def find(self, u):
          if self.p[u] != u:
              self.p[u] = self.find(self.p[u])
          return self.p[u]

      def union(self, u, v):
          self.p.setdefault(u, u)
          self.p.setdefault(v, v)
          self.p[self.find(u)] = self.find(v)


  class Solution:
      def matrixRankTransform(self, matrix: List[List[int]]) -> List[List[int]]:
          N = len(matrix)
          M = len(matrix[0])

          uf = defaultdict(UnionFind)
          for i in range(N):
              for j in range(M):
                  uf[matrix[i][j]].union(i, ~j)

          components = defaultdict(lambda: defaultdict(list))
          for i in range(N):
              for j in range(M):
                  value = matrix[i][j]
                  u = uf[value].find(i)
                  components[value][u].append((i, j))

          ar = [1 for _ in range(N)]
          ac = [1 for _ in range(M)]
          ans = [[None] * M for _ in range(N)]
          for c in sorted(components):
              for cells in components[c].values():
                  m = max(max(ar[ni], ac[nj]) for ni, nj in cells)
                  for ni, nj in cells:
                      ar[ni] = m + 1
                      ac[nj] = m + 1
                      ans[ni][nj] = m
          return ans


  assert Solution().matrixRankTransform([[1, 2], [3, 4]]) == [[1, 2], [2, 3]]
  assert Solution().matrixRankTransform([[7, 7], [7, 7]]) == [[1, 1], [1, 1]]
  assert Solution().matrixRankTransform(
      [[20, -21, 14], [-19, 4, 19], [22, -47, 24], [-19, 4, 19]]
  ) == [[4, 2, 3], [1, 3, 4], [5, 1, 6], [1, 3, 4]]
#+end_src

* Leetcode: 564. Find the Closest Palindrome
:PROPERTIES:
:ID:       034FC1E7-4AFB-4534-8C2D-0D3F3E8A5292
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-25 Mon 07:04]--[2022-07-25 Mon 07:55] =>  0:51
:END:
[[https://leetcode.com/problems/find-the-closest-palindrome/][Problem Statement]]

- [[id:05007800-BCCC-415E-A4D3-7B69ABC73588][Pattern: Search for closest number of some kind]].  Generate all closest palindromes and pick the optimal one: closest palindrome with less digits is "999...", with more digits "100..001" and others can be generate by summing or subtracting one from the middle digits.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Build a palindrome with the input number by splitting it and them combining the first part in reverse order.  The answer will be doing this but adding +1, +0 or -1 to the split part.  Time and space complexity is $O(n)$.

#+begin_src python
  class Solution:
      def nearestPalindromic(self, num: str) -> str:
          N = len(num)
          even = N % 2 == 0
          l = list(num)

          def same():
              p = l[0 : N // 2]
              if even:
                  return "".join(p + p[::-1])
              else:
                  return "".join(p + [l[N // 2]] + p[::-1])

          def smaller():
              if even:
                  p = l[0 : N // 2]
                  n = str(int("".join(p)) - 1)
                  return "".join(n + n[::-1])
              else:
                  p = l[0 : N // 2 + 1]
                  n = str(int("".join(p)) - 1)
                  return "".join(n + n[:-1][::-1])

          def greater():
              if even:
                  p = l[0 : N // 2]
                  n = str(int("".join(p)) + 1)
                  return "".join(n + n[::-1])
              else:
                  p = l[0 : N // 2 + 1]
                  n = str(int("".join(p)) + 1)
                  return "".join(n + n[:-1][::-1])

          candidates = set([str(10 ** N + 1), str(10 ** (N - 1) - 1)])
          candidates.add(same())
          candidates.add(smaller())
          candidates.add(greater())
          candidates.discard(num)

          return min(*candidates, key=lambda e: (abs(int(e)-int(num)), int(e)))

  assert Solution().nearestPalindromic("123") == "121"
  assert Solution().nearestPalindromic("1") == "0"
  assert Solution().nearestPalindromic("10") == "9"
  assert Solution().nearestPalindromic("11") == "9"
  assert Solution().nearestPalindromic("19") == "22"
  assert Solution().nearestPalindromic("9") == "8"
  assert Solution().nearestPalindromic("99") == "101"
  assert Solution().nearestPalindromic("999") == "1001"
  assert Solution().nearestPalindromic("100") == "99"
  assert Solution().nearestPalindromic("1000") == "999"
#+end_src


#+begin_src python
  class Solution:
      def nearestPalindromic(self, num: str) -> str:
          if len(num) == 1:
              return str(int(num) - 1)

          inum = int(num)
          num = list(num)

          candidates = set()

          def add(x):
              ix = int("".join(x))
              if ix != inum:
                  candidates.add(ix)

          add(["9"] * (len(num) - 1))
          add(["1"] + ["0"] * (len(num) - 1) + ["1"])

          if len(num) % 2 == 0:
              p = num[:len(num) // 2]
              for d in +0, +1, -1:
                  q = list(str(int("".join(p)) + d))
                  add(q + q[::-1])
          else:
              p = num[:len(num) // 2]
              for d in +0, +1, -1:
                  q = list(str(int("".join(p + [num[len(num) // 2]])) + d))
                  add(q[:-1] + q[::-1])

          ans = None
          for c in sorted(candidates):
              if ans is None or abs(ans - inum) > abs(c - inum):
                  ans = c
          return str(ans)
#+end_src

* Leetcode: 44. Wildcard Matching
:PROPERTIES:
:ID:       C2267FAA-C888-4025-AFEF-F6E6615D27DD
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-25 Mon 09:57]--[2022-07-25 Mon 10:39] =>  0:42
:END:
[[https://leetcode.com/problems/wildcard-matching/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  I solved a problem like this before and again I forgot to test
  ~s="", p="*"~ and ~s="a..", p="*a..."~.

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  We should compute $dp[i][j]$ which means that $s[i..(n-1)]$ matches $p[j..(m-1)]$.  If the [[id:241ABA4C-A86F-405F-B6FC-85BF441EB24B][Dynamic Programming]] isn't clear at first, write the recursive function and them translate it to an iterative algorithm.  Time and space complexity is $O(n \times m)$.

#+begin_src python
  class Solution:
      def isMatch(self, s: str, p: str) -> bool:
          s += "$"
          p += "$"
          N = len(s)
          M = len(p)

          dp = [[False] * (M + 1) for _ in range(N + 1)]
          for i in range(N, -1, -1):
              for j in range(M, -1, -1):
                  if i == N and j == M:
                      dp[i][j] = True
                  elif i == N or j == M:
                      dp[i][j] = False
                  elif p[j] == "?":
                      dp[i][j] = dp[i + 1][j + 1]
                  elif s[i] == p[j]:
                      dp[i][j] = dp[i + 1][j + 1]
                  elif p[j] == "*":
                      dp[i][j] = dp[i][j + 1] or dp[i + 1][j] or dp[i + 1][j + 1]
                  else:
                      dp[i][j] = False

          return dp[0][0]


  assert Solution().isMatch("aa", "a") == False
  assert Solution().isMatch("aa", "*") == True
  assert Solution().isMatch("cb", "?a") == False
#+end_src

* Leetcode: 2132. Stamping the grid
:PROPERTIES:
:ID:       79BCE5C5-AA81-4855-8F69-5F6546CE55EF
:WA:       4
:END:
:LOGBOOK:
CLOCK: [2022-07-25 Mon 21:30]--[2022-07-25 Mon 22:05] =>  0:35
CLOCK: [2022-07-25 Mon 11:25]--[2022-07-25 Mon 11:56] =>  0:31
CLOCK: [2022-07-25 Mon 10:39]--[2022-07-25 Mon 11:08] =>  0:29
:END:
[[https://leetcode.com/problems/stamping-the-grid/][Problem Statement]]

- [[id:40E38FD2-DDF0-4C25-BB8C-43D07F3D5136][Mistake: Overcomplicated solution]]. Discovered the area to paint by computing all possible valid rectangles and painting its area.

- [[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  If $stampHeight=1$, the problem becomes detecting if all empty cells are part of an empty segment of size at least $stampWidth$.  This can be done by extending the empty segments with the empty cells to its right.  If $stampHeight>1$, we have to find the segments where each cell is part of a vertical segment of empty cells of size at least $stampHeight$ ().  We paint all these segments as we find them.  To paint efficiently, we do it from bottom to up and stop when we find a painted cell since it marks that from that point on there is more $stampHeight$ painted cells.  Time and space complexity is $O(n \times m)$.


#+begin_src python
  from typing import List


  class Solution:
      def possibleToStamp(
          self, grid: List[List[int]], stampHeight: int, stampWidth: int
      ) -> bool:
          N = len(grid)
          M = len(grid[0])

          p = [[False] * M for _ in range(N)]

          def paint(i0, j0, i1, j1):
              j = j1
              while j >= j0:
                  i = i1
                  while i >= i0 and not p[i][j]:
                      p[i][j] = True
                      i -= 1
                  j -= 1

          a = [0] * M
          for i in range(N):
              for j in range(M):
                  a[j] = a[j] + 1 if grid[i][j] == 0 else 0
              j0 = 0
              while j0 < M:
                  while j0 < M and a[j0] < stampHeight:
                      j0 += 1
                  j1 = j0
                  while j1 < M and a[j1] >= stampHeight:
                      j1 += 1
                  if j1 - j0 >= stampWidth:
                      paint(i - stampHeight + 1, j0, i, j1 - 1)
                  j0 = j1

          ans = True
          for i in range(N):
              for j in range(M):
                  if grid[i][j] == 0 and p[i][j] == False:
                      return False
          return ans


  assert (
      Solution().possibleToStamp(
          [[1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0], [1, 0, 0, 0]], 4, 3
      )
      == True
  )
  assert (
      Solution().possibleToStamp(
          [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], 2, 2
      )
      == False
  )
#+end_src
* Leetcode: 493. Reverse Pairs
:PROPERTIES:
:ID:       BE41E9D4-3508-418A-87B9-85A66A947011
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-26 Tue 06:08]--[2022-07-26 Tue 06:13] =>  0:05
:END:
[[https://leetcode.com/problems/reverse-pairs/][Problem Statement]]

- [[id:26656051-E32D-42FE-9315-05ADB46A1A82][Can we reuse or extend a solution from a sub-problem to solve the next sub-problem more efficiently?]]  The number of reverse pairs in the last element is zero.  We will have only one reverse pair if $a[n-2] > 2 \times a[n-1]$.  On iteration $i$, be $b$ an array with numbers $2 \times a[i+1], ... 2 \times a[n-1]$.  The problem is then finding the number of number in $b$ that are smaller than $a[i]$.  After processing $i$, we can add $2 \times a[i]$ to the list and continue to the next index.  Time complexity is $O(n \times \log n)$ and space is $O(n)$.

#+begin_src python
  from sortedcontainers import SortedList
  from typing import List


  class Solution:
      def reversePairs(self, nums: List[int]) -> int:
          sl = SortedList()
          ans = 0
          for num in reversed(nums):
              p = sl.bisect_left(num)
              ans += p
              sl.add(num * 2)
          return ans


  assert Solution().reversePairs([1, 3, 2, 3, 1]) == 2
  assert Solution().reversePairs([2, 4, 3, 5, 1]) == 3
#+end_src

- Other way to solve this problem is to implement a [[id:1A99D477-2FF8-481E-80B4-735122D0A8D7][Merge Sort]] and count the number of swaps was done.  Time complexity is $O(n \log n)$ and space is $O(n)$.
* Leetcode: 2092. Find All People With Secret
:PROPERTIES:
:ID:       89FA1E49-41EE-4B0D-8C76-1864049C8C54
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-26 Tue 06:24]--[2022-07-26 Tue 07:03] =>  0:39
:END:
[[https://leetcode.com/problems/find-all-people-with-secret/][Problem Statement]]

- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]].  I computed the connections to person ~0~, by looking to the edges that starts on person ~0~ component.  The problem is that it will become $O(n^2)$ in the worst case and not $O(m)$.

- [[id:49FB2683-60E5-4B10-B2B7-1D0B951EA1E0][Pattern: Build graph online]].  For each meeting time, we add all edges using [[id:23A4E36E-24D3-40F8-AA20-32C0DB1E36F6][Union-Find]] from the meetings to the graph and after that we remove all those edges which its vertices aren't connected to the vertex 0.

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  We are going to build the solution by time.  Group all meetings by their times.  From the earlier to the later meeting, connect the vertices (people) that met at that time.  On the end, reset the connected components other the one that has people ~0~ on it.  Time complexity is $O(m)$ and space is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def findAllPeople(
          self, n: int, meetings: List[List[int]], firstPerson: int
      ) -> List[int]:
          p = [i for i in range(n)]

          def find(u):
              if p[u] != u:
                  p[u] = find(p[u])
              return p[u]

          def union(u, v):
              p[find(u)] = p[find(v)]

          union(0, firstPerson)

          m = {t: [] for _, _, t in meetings}
          for u, v, t in meetings:
              m[t].append((u, v))

          for t in sorted(m):
              vs = set()
              for u, v in m[t]:
                  union(u, v)
                  vs.add(u)
                  vs.add(v)
              for u in vs:
                  if find(u) != find(0):
                      p[u] = u

          return [u for u in range(n) if find(u) == find(0)]


  assert Solution().findAllPeople(6, [[1, 2, 5], [2, 3, 8], [1, 5, 10]], 1) == [
      0,
      1,
      2,
      3,
      5,
  ]
  assert Solution().findAllPeople(4, [[3, 1, 3], [1, 2, 2], [0, 3, 3]], 3) == [0, 1, 3]
  assert Solution().findAllPeople(5, [[3, 4, 2], [1, 2, 1], [2, 3, 1]], 1) == [
      0,
      1,
      2,
      3,
      4,
  ]
#+end_src

* Leetcode: 1825. Finding MK Average
:PROPERTIES:
:ID:       FDD0EA78-D683-405B-A31B-49B0E17C0A82
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-26 Tue 09:40]--[2022-07-26 Tue 10:13] =>  0:33
CLOCK: [2022-07-26 Tue 07:22]--[2022-07-26 Tue 08:04] =>  0:42
:END:
[[https://leetcode.com/problems/finding-mk-average/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  Did not test for cases where all numbers are the same.  I thought that my formula was covering it, but it wasn't.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Be $s$ a list of last $m$ numbers sorted.  The problem then is to return $\sum_{k \leq i < n - k}_{} s[i]$ which can be solved using a [[id:2B44007C-8EC7-49DA-9A9B-0D6CF6578083][FenwickTree]].  Time complexity is $O(\log M)$ for all operations and space is $O(M)$ where $M$ is the number of distinct numbers allowed.

#+begin_src python
  from sortedcontainers import SortedList
  from collections import deque


  class FenwickTree:
      def __init__(self, n):
          self.n = n
          self.bit = [0] * n

      def sum(self, r, l=None):
          if l is not None:
              return self.sum(l) - self.sum(r - 1)
          ret = 0
          while r >= 0:
              ret += self.bit[r]
              r = (r & (r + 1)) - 1
          return ret

      def add(self, idx, delta):
          while idx < self.n:
              self.bit[idx] += delta
              idx = idx | (idx + 1)


  class MKAverage:
      def __init__(self, m: int, k: int):
          self.m = m
          self.k = k
          self.cnt = self.m - 2 * self.k
          self.ac = FenwickTree(100_001)
          self.nums = deque(maxlen=m + 1)
          self.sorted = SortedList()

      def addElement(self, num: int) -> None:
          if len(self.nums) == self.m:
              r = self.nums.popleft()
              self.sorted.remove(r)
              self.ac.add(r, -r)
          self.nums.append(num)
          self.sorted.add(num)
          self.ac.add(num, num)

      def calculateMKAverage(self) -> int:
          if len(self.nums) < self.m:
              return -1

          i = self.k
          j = self.m - self.k - 1
          start_num = self.sorted[i]
          end_num = self.sorted[j]

          if start_num == end_num:
              return start_num

          s = self.ac.sum(start_num, end_num + 1)
          s -= end_num * (self.sorted.bisect_right(end_num) - j - 1)
          s -= start_num * (self.k - self.sorted.bisect_left(start_num))
          return s // self.cnt


  obj = MKAverage(3, 1)
  obj.addElement(3)
  obj.addElement(1)
  assert obj.calculateMKAverage() == -1
  obj.addElement(10)
  assert obj.calculateMKAverage() == 3
  obj.addElement(5)
  obj.addElement(5)
  obj.addElement(5)
  assert obj.calculateMKAverage() == 5
#+end_src

#+begin_src python
  class FenwickTree:
      def __init__(self, n):
          self.n = n
          self.bit = [0] * n

      def sum(self, r, l=None):
          if l is not None:
              return self.sum(l) - self.sum(r - 1)
          ret = 0
          while r >= 0:
              ret += self.bit[r]
              r = (r & (r + 1)) - 1
          return ret

      def add(self, idx, delta):
          while idx < self.n:
              self.bit[idx] += delta
              idx = idx | (idx + 1)


  class MKAverage:
      def __init__(self, m: int, k: int):
          self.m = m
          self.k = k
          self.r = m - 2 * k
          self.c = FenwickTree(10**5 + 1)
          self.n = FenwickTree(10**5 + 1)
          self.stream = deque()

      def addElement(self, num: int) -> None:
          if len(self.stream) == self.m:
              x = self.stream.popleft()
              self.c.add(x, -1)
              self.n.add(x, -x)
          self.stream.append(num)
          self.c.add(num, +1)
          self.n.add(num, +num)

      def index(self, v):
          s = 1
          e = 10**5
          while s < e:
              m = s + (e - s) // 2
              if self.c.sum(m) >= v:
                  e = m
              else:
                  s = m + 1
          return s

      def calculateMKAverage(self) -> int:
          if len(self.stream) < self.m:
              return -1

          s = self.index(self.k)
          e = self.index(self.m - self.k)
          ans = self.n.sum(e) - self.n.sum(s)
          ans += s * max(0, self.c.sum(s) - self.k)
          ans -= e * max(0, self.c.sum(e) - (self.m - self.k))
          return floor(ans / self.r)
#+end_src

- We can replace the sorted list and [[id:2B44007C-8EC7-49DA-9A9B-0D6CF6578083][FenwickTree]] by implementing a [[id:252C5055-2C0D-4B0E-A4BF-9507B85A179F][Segment Tree]] that keeps the sum and a count for each node.  Time complexity is $O(\log M)$ for all operations and space is $O(M)$ where $M$ is the number of distinct numbers allowed.

#+begin_src python
  from collections import deque


  class SegTree:
      def __init__(self, start, end):
          self.start = start
          self.end = end
          self.sum = 0
          self.count = 0
          self.left = None
          self.right = None

      def add(self, v):
          if v < self.start or self.end < v:
              return
          self.sum += v
          self.count += 1
          if self.start == self.end:
              return
          self._extend()
          self.left.add(v)
          self.right.add(v)

      def remove(self, v):
          if v < self.start or self.end < v:
              return
          self.sum -= v
          self.count -= 1
          if self.start == self.end:
              return
          self._extend()
          self.left.remove(v)
          self.right.remove(v)

      def query(self, count):
          if count == 0:
              return 0
          if self.start == self.end:
              return self.start * count
          if self.left.count < count:
              return self.left.sum + self.right.query(count - self.left.count)
          else:
              return self.left.query(count)

      def _extend(self):
          if self.left is None and self.start < self.end:
              m = self.start + (self.end - self.start) // 2
              self.left = SegTree(self.start, m)
              self.right = SegTree(m + 1, self.end)

      def print(self, level=0):
          print(
              " " * level,
              "SegTree",
              (self.start, self.end),
              "sum",
              self.sum,
              "count",
              self.count,
          )
          if self.left:
              self.left.print(level + 1)
              self.right.print(level + 1)


  class MKAverage:
      def __init__(self, m: int, k: int):
          self.m = m
          self.k = k
          self.sg = SegTree(0, 100_001)
          self.nums = deque(maxlen=m + 1)

      def addElement(self, num: int) -> None:
          if len(self.nums) == self.m:
              self.sg.remove(self.nums.popleft())
          self.sg.add(num)
          self.nums.append(num)

      def calculateMKAverage(self) -> int:
          if len(self.nums) < self.m:
              return -1
          return (self.sg.query(self.m - self.k) - self.sg.query(self.k)) // (
              self.m - 2 * self.k
          )


  obj = MKAverage(3, 1)
  obj.addElement(3)
  obj.addElement(1)
  assert obj.calculateMKAverage() == -1
  obj.addElement(10)
  assert obj.calculateMKAverage() == 3
  obj.addElement(5)
  obj.addElement(5)
  obj.addElement(5)
  assert obj.calculateMKAverage() == 5
#+end_src

- [[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  Keep tree lists $left, mid$ and $right$ with the last $m$ elements from the stream.  After receiving a list, first remove one if it exceeds the limit and then update the lists to respect its sizes from left to right.  Time complexity is $O(n \log n)$ and space complexity is $O(n)$.

#+begin_src python
  from sortedcontainers import SortedList

  class MKAverage:

      def __init__(self, m: int, k: int):
          self.m = m
          self.k = k
          self.r = m - 2 * k
          self.left = SortedList()
          self.right = SortedList()
          self.mid = SortedList()
          self.sum = 0
          self.nums = deque()

      def addElement(self, num: int) -> None:
          if len(self.nums) == self.m:
              self.popleft()
          self.nums.append(num)
          self.left.add(num)
          if len(self.left) > self.k:
              x = self.left.pop(-1)
              self.mid.add(x)
              self.sum += x
          if len(self.mid) > self.r:
              x = self.mid.pop(-1)
              self.right.add(x)
              self.sum -= x

      def popleft(self) -> None:
          num = self.nums.popleft()
          if num in self.left:
              self.left.remove(num)
          elif num in self.mid:
              self.mid.remove(num)
              self.sum -= num
          else:
              self.right.remove(num)
          if len(self.left) < self.k:
              x = self.mid.pop(0)
              self.left.add(x)
              self.sum -= x
          if len(self.mid) < self.r:
              x = self.right.pop(0)
              self.mid.add(x)
              self.sum += x

      def calculateMKAverage(self) -> int:
          if len(self.nums) < self.m:
              return -1
          return floor(self.sum / len(self.mid))
#+end_src

* Leetcode: 188. Best Time to Buy and Sell Stock IV
:PROPERTIES:
:ID:       A4D61D75-3B82-4399-8C8D-AF848075E792
:END:
:LOGBOOK:
CLOCK: [2022-07-26 Tue 11:14]--[2022-07-26 Tue 11:53] =>  0:39
:END:
[[https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  I was too confident my implementation and didn't test it fully.

- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]].  Sometimes, I get away with $10^8$ at Leetcode.  So, I tried without optimization.

- [[id:26656051-E32D-42FE-9315-05ADB46A1A82][Can we reuse or extend a solution from a sub-problem to solve the next sub-problem more efficiently?]]  Suppose that we always started the day with money on the pocket.  So, we have to find the best between buying today and selling in future day, since there is no point of holding it.  This can be modeled with $dp[i][k]=\max(dp[i+1][k], -prices[i] + prices[j] + dp[j + 1][k -1])$, and it will be efficiently computed if we store $best[i][k]=\max(best[i+1][k], prices[i] + 1][k - 1])$ and $dp[i][k]=\max(dp[i+1][k], -prices[i] + best[i+1][k])$.  Time and space complexity is $O(n \times k)$.

#+begin_src python
  from typing import List


  class Solution:
      def maxProfit(self, K: int, prices: List[int]) -> int:
          N = len(prices)
          dp = [[0] * (K + 1) for _ in range(N + 1)]
          best = [[0] * (K + 1) for _ in range(N + 1)]
          for i in range(N, -1, -1):
              for k in range(K, -1, -1):
                  if k == 0 or i == N:
                      continue
                  dp[i][k] = max(dp[i + 1][k], -prices[i] + best[i + 1][k])
                  best[i][k] = max(best[i + 1][k], prices[i] + dp[i + 1][k - 1])
          return dp[0][K]


  assert Solution().maxProfit(2, [2, 4, 1]) == 2
  assert Solution().maxProfit(2, [3, 2, 6, 5, 0, 3]) == 7
#+end_src

* Leetcode: 871. Minimum Number of Refueling Stops
:PROPERTIES:
:ID:       D481FE85-1B1B-4615-987F-9F006701403F
:WA:       6
:END:
:LOGBOOK:
CLOCK: [2022-07-26 Tue 14:43]--[2022-07-26 Tue 15:40] =>  0:57
CLOCK: [2022-07-26 Tue 13:56]--[2022-07-26 Tue 14:04] =>  0:08
:END:
[[https://leetcode.com/problems/minimum-number-of-refueling-stops/][Problem Statement]]

- [[id:E6B9ECE9-E7F6-4273-90DB-226664B11C0A][Mistake: Did not slow down to make sure that each part of the problem was solved correctly]].  I found the recurrence with time complexity of $O(n^2 \times k)$ and didn't not carefully extract the memorization to make it $O(n \times k)$.

- [[id:A32AAFD2-5569-4417-8085-04005F85A435][Pattern: Find shortest path on directed acyclic graph]].

- [[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  Compute $m[k][i]$ which represents the minimum fuel required to go from station $i$ to $target$ stopping in other $k$ stations ahead.  If $stations[i][0] + m[k][i] <= startFuel$, then $k$ is an answer to the original problem.  The original recurrence is $m[k][i] = max(0, min_{i < j \leq n}(m[k-1][j] + stations[j][0] - stations[i][0] - stations[i][1] for j in range(i + 1, N))$ which consumes $O(n^2 \times k)$ to be computed, but the $min$ part can be extracted and answered in $O(1)$.  Therefore, the time and space complexity of the solution is $O(n \times k)$.

#+begin_src python
  from typing import List


  class Solution:
      def minRefuelStops(
          self, target: int, startFuel: int, stations: List[List[int]]
      ) -> int:
          if target <= startFuel:
              return 0
          N = len(stations)
          m = [[float("inf")] * N for _ in range(N)]
          b = [[float("inf")] * N for _ in range(N)]
          for k in range(N):
              for i in range(N - 1, -1, -1):
                  if k == 0:
                      m[k][i] = max(0, target - stations[i][0] - stations[i][1])
                      b[k][i] = min(
                          b[k][i + 1] if i + 1 < N else float("inf"),
                          m[k][i] + stations[i][0],
                      )
                  elif i + 1 == N:
                      b[k][i] = float("inf")
                  else:
                      m[k][i] = b[k - 1][i + 1]
                      m[k][i] += -stations[i][0] - stations[i][1]
                      m[k][i] = max(0, m[k][i])
                      b[k][i] = min(b[k][i + 1], m[k][i] + stations[i][0])
                  if stations[i][0] + m[k][i] <= startFuel:
                      return k + 1
          return -1


  assert Solution().minRefuelStops(1, startFuel=1, stations=[])
  assert Solution().minRefuelStops(100, startFuel=1, stations=[[10, 100]])
  assert Solution().minRefuelStops(
      100, startFuel=10, stations=[[10, 60], [20, 30], [30, 30], [60, 40]]
  )
#+end_src

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Compute the max distance that it is possible to reach with 0 stops (ie. $startFuel$).  Compute the max distance with 1 stop, it will be $startFuel+stations[0][1]$ iff $startFuel \geq stations[0][1]$.  Time complexity is $O(n ^ 2)$ and space is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def minRefuelStops(
          self, target: int, startFuel: int, stations: List[List[int]]
      ) -> int:
          N = len(stations)
          dp = [0] * (N + 1)
          dp[0] = startFuel
          for i in range(N):
              for k in range(i, -1, -1):
                  if dp[k] >= stations[i][0]:
                      dp[k + 1] = max(dp[k + 1], dp[k] + stations[i][1])
          for k in range(N + 1):
              if dp[k] >= target:
                  return k
          return -1
#+end_src

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Similar to the idea above, but keep the station that you passed by in a heap and use the one with max fuel if you need it.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  class Solution:
      def minRefuelStops(self, target: int, startFuel: int, stations: List[List[int]]) -> int:
          stations = stations + [[target, 0]]
          N = len(stations)

          last = ans = 0
          tank = startFuel
          pq = []
          for i in range(N):
              dist = stations[i][0] - last
              tank -= dist
              while pq and tank < 0:
                  tank += -heappop(pq)
                  ans += 1
              if tank < 0:
                  return -1
              last = stations[i][0]
              heappush(pq, -stations[i][1])
          return ans
#+end_src

* Leetcode: 354. Russian Doll Envelopes
:PROPERTIES:
:ID:       E9A797EE-27EE-4BC1-9863-88EEF3986B6C
:WA:       6
:END:
:LOGBOOK:
CLOCK: [2022-07-26 Tue 22:19]--[2022-07-26 Tue 23:50] =>  1:31
CLOCK: [2022-07-26 Tue 21:34]--[2022-07-26 Tue 21:36] =>  0:02
:END:
[[https://leetcode.com/problems/russian-doll-envelopes/][Problem Statement]]

- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]].  The constant factor of [[id:252C5055-2C0D-4B0E-A4BF-9507B85A179F][Segment Tree]] was too high to get an AC.

- [[id:AC9291C6-4C72-4143-80F2-0D414EF7B681][Mistake: Did not try hard to solve alternative problem]].  I found many useful properties but couldn't put all them together (e.g. sort envelopes first by increase $h$ and then decreasing $w$).

- [[id:42B21DBC-4951-4AF2-8C41-A646F5675365][Can we pre-process the input in a way to make easy to solve the problem?]]  Sort the envelopes by $h$ values.  Now the problem becomes finding [[id:665B7733-6D7E-4A34-8F77-7E64747CE2C9][Longest Increasing Subsequence]] on values of $w$.  To avoid creating number with same $h$, we make sure that $h$ values are increase and $w$ values with same $h$ value is in decrease order.  Time complexity is $O(n \log n)$ and space is $O(k)$ where $k$ is the size of the longest subsequence.

#+begin_src python
  from typing import List
  from bisect import bisect_left


  class Solution:
      def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
          N = len(envelopes)
          envelopes.sort(key=lambda e: (e[1], -e[0]))
          seq = []
          for n, _ in envelopes:
              k = bisect_left(seq, n)
              if k == len(seq):
                  seq.append(n)
              else:
                  seq[k] = n
          return len(seq)


  assert Solution().maxEnvelopes([[5, 4], [6, 4], [6, 7], [2, 3]]) == 3
  assert Solution().maxEnvelopes([[1, 1], [1, 1], [1, 1]]) == 1
#+end_src

- [[id:37B33434-71C2-4E55-9121-5D6855D8E169][Can we formulate the problem using a segment tree?]]  Sort the envelopes by $h$ and from the last to the first.  Add them to a [[id:252C5055-2C0D-4B0E-A4BF-9507B85A179F][Segment Tree]] or [[id:2B44007C-8EC7-49DA-9A9B-0D6CF6578083][FenwickTree]] which supports getting the max value of an interval.  Time complexity is $O(n \log m)$ where $m$ is the max size of the interval, and space is $O(m)$.

#+begin_src python
  from typing import List


  class FenwickTreeMax:
      def __init__(self, n):
          self.n = n
          self.bit = [float("-inf")] * n

      def getmax(self, r):
          ret = float("-inf")
          while r >= 0:
              ret = max(ret, self.bit[r])
              r = (r & (r + 1)) - 1
          return ret

      def update(self, idx, val):
          while idx < self.n:
              self.bit[idx] = max(self.bit[idx], val)
              idx = idx | (idx + 1)


  class Solution:
      def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
          M = 123_456
          best = FenwickTreeMax(M)

          envelopes.sort(key=lambda e: (e[1], -e[0]))
          ans = 0
          for i in range(len(envelopes) - 1, -1, -1):
              n = envelopes[i][0]
              c = max(1, 1 + best.getmax(M - (n + 1)))
              best.update(M - n, c)
              ans = max(ans, c)
          return ans


  assert Solution().maxEnvelopes([[5, 4], [6, 4], [6, 7], [2, 3]]) == 3
  assert Solution().maxEnvelopes([[1, 1], [1, 1], [1, 1]]) == 1
#+end_src

* Leetcode: 282. Expression Add Operators
:PROPERTIES:
:ID:       FEE30A8E-D995-47E9-83FA-B79E82173863
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-07-27 Wed 15:18]--[2022-07-27 Wed 16:07] =>  0:49
:END:
[[https://leetcode.com/problems/expression-add-operators/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  Didn't even try to write down edge cases.

- [[id:29512D97-A54D-42F9-A8C7-C3422881933B][Can we use brute-force to solve the problem?]]  The length of $num$ is at most 10 what means that there are 8 positions where we can decide to not put an operator or put $+,-,\times$.  So, there are $8^4$ possible expressions.  Generate all them avoiding operands with leading zero and compute their value on the end.  Time complexity is $O(4^n)$ and space is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def addOperators(self, num: str, target: int) -> List[str]:
          def valid(exp):
              value = 0
              for e in exp.replace("-", "+-").split("+"):
                  cur = 1
                  for m in e.split("*"):
                      cur *= int(m)
                  value += cur
              return value == target

          ans = []

          def bt(i, leading, exp):
              if i == len(num):
                  if valid(exp):
                      ans.append(exp)
                  return
              for o in "*", "+", "-":
                  bt(i + 1, num[i] == "0", exp + o + num[i])
              if not leading:
                  bt(i + 1, False, exp + num[i])

          bt(1, num[0] == "0", num[0])

          return ans


  assert Solution().addOperators("123", 6) == ["1*2*3", "1+2+3"]
  assert Solution().addOperators("232", 8) == ["2*3+2", "2+3*2"]
  assert Solution().addOperators("3456237490", 9191) == []
#+end_src

* Leetcode: 76. Minimum Window Substring
:PROPERTIES:
:ID:       DA2BC287-CB04-444A-A245-C8235211B58A
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-07-27 Wed 16:18]--[2022-07-27 Wed 16:54] =>  0:36
:END:
[[https://leetcode.com/problems/minimum-window-substring/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]]. I tried but didn't come up with ~("a", "b")~.

- [[id:46522C06-DAC3-4986-A13A-17C2ED44ADD1][Can we formulate the problem as sliding window?]]  To check if the window is valid, we count the number of letters that reached the correct frequency in the window.  It can be done by keeping a dictionary with the frequency.  Time complexity is $O(n)$ and space complexity is $O(1)$.

#+begin_src python
  from collections import defaultdict


  class Solution:
      def minWindow(self, s: str, t: str) -> str:
          R = len(set(t))
          N = len(s)
          required = defaultdict(int)
          for c in t:
              required[c] += 1

          freq = defaultdict(int)
          cnt_ok = 0

          start = 0
          valid = False

          ans = None
          for end, c in enumerate(s):
              if not valid and freq[c] == required[c] - 1:
                  cnt_ok += 1
                  valid = cnt_ok == R

              freq[c] += 1
              while start < N and freq[s[start]] > required[s[start]]:
                  freq[s[start]] -= 1
                  start += 1

              if valid and (ans is None or (ans[1] - ans[0] + 1) > (end - start + 1)):
                  ans = (start, end)

          return s[ans[0] : ans[1] + 1] if ans else ""


  assert Solution().minWindow("ADOBECODEBANC", "ABC") == "BANC"
  assert Solution().minWindow("a", "a") == "a"
#+end_src

* Leetcode: 2147. Number of Ways to Divide a Long Corridor
:PROPERTIES:
:ID:       1E5CD06C-3000-446D-ADEF-843AA2F932FC
:END:
:LOGBOOK:
CLOCK: [2022-07-27 Wed 17:02]--[2022-07-27 Wed 17:25] =>  0:23
:END:
[[https://leetcode.com/problems/number-of-ways-to-divide-a-long-corridor/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  Missed smallest edge cases possible (i.e. one letter).

- [[id:42B21DBC-4951-4AF2-8C41-A646F5675365][Can we pre-process the input in a way to make easy to solve the problem?]]  We can trim the plants on both extremes since no section will be created between them.

- [[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  Be $p_0, p_1, ..., p_k$ the number of plants between the first two seats and the next two and so on.  The problem becomes computing $p_0 \times p_1 \times ... \times p_k \mod 10^9 + 7$.  Time complexity is $O(n)$ and space is $O(1)$.

#+begin_src python
  class Solution:
      def numberOfWays(self, corridor: str) -> int:
          M = 10**9 + 7
          N = len(corridor)
          i = 0
          while i < N and corridor[i] == "P":
              i += 1
          ans = None
          while i < N:
              cnt = 0
              while i < N and corridor[i] == "P":
                  i += 1
                  cnt += 1
              if i == N:
                  break
              assert corridor[i] == "S"
              i += 1
              while i < N and corridor[i] == "P":
                  i += 1
              if i == N:
                  return 0
              assert corridor[i] == "S"
              if ans is None:
                  ans = 1
              ans = (ans * (cnt + 1)) % M
              i += 1
          return 0 if ans is None else ans


  assert Solution().numberOfWays("SSPPSPS") == 3
  assert Solution().numberOfWays("PPSPSP") == 1
  assert Solution().numberOfWays("S") == 0
#+end_src

* Leetcode: 135. Candy
:PROPERTIES:
:ID:       68E325FC-3866-4A89-B1C5-88A85559E43B
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-27 Wed 19:00]--[2022-07-27 Wed 19:26] =>  0:26
CLOCK: [2022-07-27 Wed 17:32]--[2022-07-27 Wed 17:43] =>  0:11
:END:
[[https://leetcode.com/problems/candy/][Problem Statement]]

- [[id:42B21DBC-4951-4AF2-8C41-A646F5675365][Can we pre-process the input in a way to make easy to solve the problem?]]  Sort a list of pairs $(v, i)$ in increasing order where $ratings[i]=v$.  For each child in order, assign its candy as describe in the rules.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def candy(self, r: List[int]) -> int:
          N = len(r)
          low = [1] * N

          ans = 0
          for v, i in sorted(zip(r, range(N))):
              c = []
              if i - 1 >= 0 and r[i - 1] < v:
                  c.append(low[i - 1] + 1)
              if i + 1 < N and r[i + 1] < v:
                  c.append(low[i + 1] + 1)
              if c:
                  low[i] = max(c)
              ans += low[i]

          return ans


  assert Solution().candy([1, 0, 2]) == 5
  assert Solution().candy([1, 2, 2]) == 4
#+end_src

- [[id:6E896F0D-AB58-4C26-A685-8A74D775BD71][Can we formulate the problem as a line chart?]]  We want to assign $1+2+..+k$ when we see a spike and $p+(p-1)+...+1$ when we see a drop.  If a spike is followed by a drop, we want to get $max(k, p)$ for that child.  Time and space complexity is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def candy(self, r: List[int]) -> int:
          N = len(r)

          cand = [1] * N
          for i in range(1, N):
              if r[i] > r[i - 1]:
                  cand[i] = cand[i - 1] + 1

          for i in range(N - 2, -1, -1):
              if r[i] > r[i + 1]:
                  cand[i] = max(cand[i], cand[i + 1] + 1)

          return sum(cand)


  assert Solution().candy([1, 0, 2]) == 5
  assert Solution().candy([1, 2, 2]) == 4
#+end_src

* Leetcode: 332. Reconstruct Itinerary
:PROPERTIES:
:ID:       6B445CC7-3916-4A98-9D5C-6FA02A6B5C32
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-28 Thu 10:21]--[2022-07-28 Thu 14:08] =>  3:47
:END:
[[https://leetcode.com/problems/reconstruct-itinerary/][Problem Statement]]

- [[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Find an [[id:BE52E57C-4A9B-4F62-9F8F-EBD0447ABBB9][Eulerian path in Directed Graph]].  Time and space complexity is $O(m)$ where $m$ is the number of edges in the graph.

#+begin_src python
  from typing import List


  class Solution:
      def findItinerary(self, tickets: List[List[str]]) -> List[str]:
          A = {u: [] for u in set(u for t in tickets for u in t)}
          for u, v in tickets:
              A[u].append(v)
          for u in A:
              A[u].sort(reverse=True)
          st = ["JFK"]
          ans = []
          while st:
              if not A[st[-1]]:
                  ans.append(st.pop())
              else:
                  st.append(A[st[-1]].pop())
          ans.reverse()
          return ans


  assert Solution().findItinerary(
      [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
  ) == ["JFK", "MUC", "LHR", "SFO", "SJC"]
  assert Solution().findItinerary(
      [["JFK", "SFO"], ["JFK", "ATL"], ["SFO", "ATL"], ["ATL", "JFK"], ["ATL", "SFO"]]
  ) == ["JFK", "ATL", "JFK", "SFO", "ATL", "SFO"]
#+end_src

* Leetcode: 2188. Minimum Time to Finish the Race
:PROPERTIES:
:ID:       9B046900-A7C0-45C0-8592-B4538C21EBCC
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-07-28 Thu 14:57]--[2022-07-28 Thu 16:15] =>  1:18
CLOCK: [2022-07-28 Thu 14:08]--[2022-07-28 Thu 14:21] =>  0:13
:END:
[[https://leetcode.com/problems/minimum-time-to-finish-the-race/][Problem Statement]]

- [[id:1CFF662A-6F16-43CE-BB07-EA12BA382690][Can we formulate the problem as a classical problem?]]  If we know the tires to make 1 lap, 2 laps and so on, the problem is reduced to [[id:0F085C54-E45A-41E6-951B-79CFD7ECBED5][Knapsack problem]].  The main trick is to notice that the best tire $i$ for $k$ laps has it factor $r_i$ less than or equal to $r_j$ where $j$ is the best tire for $k-1$ consecutive laps.  Time complexity is $O(n \times m)$ with space $O(n ^ 2)$.

#+begin_src python
  from typing import List


  class Solution:
      def minimumFinishTime(
          self, tires: List[List[int]], changeTime: int, numLaps: int
      ) -> int:
          N = len(tires)
          M = numLaps

          tires.sort(key=lambda t: (t[1], t[0]))

          best = [(float("inf"), N - 1) for _ in range(M + 1)]
          cand = set(range(N))
          total = [0] * N
          laptime = [f for f, _ in tires]
          for l in range(1, M + 1):
              for i in range(best[l - 1][1] + 1):
                  if l > 1:
                      laptime[i] *= tires[i][1]
                  total[i] += laptime[i]
                  if best[l][0] > total[i]:
                      best[l] = (total[i], i)

          dp = [float("inf")] * (M + 1)
          for i in range(M + 1):
              if i == 0:
                  dp[i] = 0
              else:
                  dp[i] = best[i][0]
                  for l in range(1, i + 1):
                      dp[i] = min(dp[i], dp[i - l] + best[l][0] + changeTime)

          return dp[M]


  assert Solution().minimumFinishTime([[2, 3], [3, 4]], 5, 4) == 21
  assert Solution().minimumFinishTime([[1, 10], [2, 2], [3, 4]], 6, 5) == 25
#+end_src

* Leetcode: 158. Read N Characters Given read4 II - Call Multiple Times
:PROPERTIES:
:ID:       C6085F95-819B-4903-B333-44C54D36D484
:END:
:LOGBOOK:
CLOCK: [2022-07-28 Thu 18:05]--[2022-07-28 Thu 18:11] =>  0:06
:END:
[[https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times/][Problem Statement]]

#+begin_src python
  from typing import List

  # The read4 API is already defined for you.
  # def read4(buf4: List[str]) -> int:


  class Solution:
      def __init__(self):
          self.buf = [" "] * 4
          self.pos = 0
          self.len = 0

      def read(self, buf: List[str], n: int) -> int:
          i = 0
          while i < n:
              if self.pos == self.len:
                  self.buf = [" "] * 4
                  self.pos = 0
                  self.len = read4(self.buf)

              if self.len == 0:
                  break

              buf[i] = self.buf[self.pos]
              self.pos += 1
              i += 1

          return i
#+end_src

* Leetcode: 924. Minimize Malware Spread
:PROPERTIES:
:ID:       5C0FE5FA-1048-411A-8154-59E964601A5C
:END:
:LOGBOOK:
CLOCK: [2022-07-28 Thu 21:00]--[2022-07-28 Thu 21:50] =>  0:50
:END:
[[https://leetcode.com/problems/minimize-malware-spread/][Problem Statement]]

- [[id:EEDBE877-7C4A-4D0B-BA6B-EFDF9288B78C][Blackbox: This is a variation of a classic problem]]: find bridges on graphs.  But it turned out that my intuition was wrong.  After reading the problem again, I noticed that we have to find the connected components instead.

- [[id:693ED7C4-4F2D-4AD1-8326-AB6C2D6D9BE6][Pattern: Find optimal component in graph]].  The answer is the component using [[id:212DBFC3-FE3C-493E-86A6-42FF3F82CD53][Depth-first search]] or [[id:23A4E36E-24D3-40F8-AA20-32C0DB1E36F6][Union-Find]] with maximum number of vertices that doesn't not contain other initial vertex, otherwise it is the initial vertex with smallest index.  Time complexity is $O(n^2)$ with space $O(n)$.

- [[id:1CFF662A-6F16-43CE-BB07-EA12BA382690][Can we formulate the problem as a classical problem?]]  Find [[id:367C887D-3517-4AC8-8219-293AC0E77E07][Connected Components in a Graph]] and pick the one that contains only one initial vertices and has maximum size or the smaller initial vertices id.  Time complexity is $O(n^2)$ and space is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
          N = len(graph)
          vis = [None] * N
          comp_size = [0] * N
          initial = set(initial)

          def dfs(u, p):
              for v in range(N):
                  if graph[u][v] == 1 and vis[v] is None:
                      vis[v] = p
                      comp_size[p] += 1
                      dfs(v, p)

          for u in initial:
              if vis[u] is None:
                  vis[u] = u
                  comp_size[u] += 1
                  dfs(u, u)

          comp_initial = [0] * N
          for u in initial:
              comp_initial[vis[u]] += 1

          ans = None
          for u in initial:
              improve = 0 if comp_initial[vis[u]] > 1 else comp_size[vis[u]]
              if ans is None or ans[1] < improve or (ans[1] == improve and ans[0] > u):
                  ans = (u, improve)

          return ans[0] if ans else 0


  assert Solution().minMalwareSpread([[1, 1, 0], [1, 1, 0], [0, 0, 1]], [0, 1]) == 0
  assert Solution().minMalwareSpread([[1, 0, 0], [0, 1, 0], [0, 0, 1]], [0, 2]) == 0
  assert Solution().minMalwareSpread([[1, 1, 1], [1, 1, 1], [1, 1, 1]], [1, 2]) == 1
#+end_src

#+begin_src python
  from typing import List


  class Solution:
      def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
          N = len(graph)
          initial.sort()

          p = [i for i in range(N)]

          def find(u):
              if p[u] != u:
                  p[u] = find(p[u])
              return p[u]

          def union(u, v):
              p[find(u)] = p[find(v)]

          ans = None
          for u in range(N):
              for v in range(u + 1, N):
                  if graph[u][v]:
                      union(u, v)

          s = [0] * N
          for u in range(N):
              s[find(u)] += 1

          ans = None
          for u in initial:
              if all(p[find(u)] != p[find(v)] for v in initial if u != v):
                  if ans is None or s[find(ans)] < s[find(u)]:
                      ans = u
          return ans if ans is not None else initial[0]
#+end_src

* Leetcode: 132. Palindrome Partitioning II
:PROPERTIES:
:ID:       1BF208FD-93A0-45A6-ADDE-969A8A64D314
:END:
[[https://leetcode.com/problems/palindrome-partitioning-ii/][Problem Statement]]

- [[id:EC7DFA39-8E96-4EF7-9297-FAEE2ABF0849][Blackbox: The dependent problem needs to be optimized]].  Noticed that I had to be able to query if $(i,j)$ is a palindrome in $O(1)$.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Build a matrix $p[i,j]$ which is $True$ if $s[i...j]$ is a palindrome and $False$ otherwise.  With that done, we can compute $dp[i]$ which is the minimum number of cuts to make $s[i...(n-1)]$ palindromes.  To do that, we pick the best $j$ where $p[i,j]=True$ and $1 + dp[j]$ is minimum.

#+begin_src python
  from typing import List


  class Solution:
      def minCut(self, s: str) -> int:
          N = len(s)

          is_palindrome = [[False] * N for _ in range(N)]
          for k in range(N):
              i = k
              j = k
              while 0 <= i and j < N and s[i] == s[j] and is_palindrome[i][j] == False:
                  is_palindrome[i][j] = True
                  i -= 1
                  j += 1
          for k in range(N - 1):
              if s[k] != s[k + 1]:
                  continue
              i = k
              j = k + 1
              while 0 <= i and j < N and s[i] == s[j] and is_palindrome[i][j] == False:
                  is_palindrome[i][j] = True
                  i -= 1
                  j += 1

          dp = [float("inf")] * N
          for i in range(N - 1, -1, -1):
              for j in range(i, N):
                  if not is_palindrome[i][j]:
                      continue
                  if j + 1 == N:
                      dp[i] = min(dp[i], 0)
                  else:
                      dp[i] = min(dp[i], 1 + dp[j + 1])
          return dp[0]


  assert Solution().minCut("aab") == 1
  assert Solution().minCut("a") == 0
  assert Solution().minCut("ab") == 1
#+end_src

* Leetcode: 664. Strange Printer
:PROPERTIES:
:ID:       58453EDD-24BD-477E-806D-AF8F4E53D790
:END:
[[https://leetcode.com/problems/strange-printer/][Problem Statement]]

- [[id:40E38FD2-DDF0-4C25-BB8C-43D07F3D5136][Mistake: Overcomplicated solution]].  I shouldn't have try to immediately after defining the match.

- [[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  Swap consecutive letters with only one of them.

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  The trick part of this problem is that we have to postpone as much as we can to count a print when we are dealing with $s[i] = s[k]$ and $i < k$.  To do so, we find an interval to print $s[i..k..j]$ where $s[i]=s[k]$ and we recur over $s[i..(k-1)]$ leaving the printing of $s[i..k]$ to be record when $s[i]$ is inevitably printed.  Time complexity is $O(n^3)$ and space is $O(n^2)$.

#+begin_src python
  class Solution:
      def strangePrinter(self, s: str) -> int:
          s = "".join([a for a, b in zip(s, s[1:] + "$") if a != b])
          N = len(s)

          dp = [[0] * N for _ in range(N)]
          for i in range(N - 1, -1, -1):
              for j in range(i, N):
                  if i == j:
                      dp[i][j] = 1
                  elif i + 1 == j:
                      dp[i][j] = 2
                  else:
                      dp[i][j] = 1 + dp[i + 1][j]
                      for k in range(i + 1, j + 1):
                          if s[i] == s[k]:
                              dp[i][j] = min(
                                  dp[i][j],
                                  dp[i][k - 1] + (dp[k + 1][j] if k + 1 < N else 0),
                              )

          return dp[0][N - 1]


  assert Solution().strangePrinter("aaabbb") == 2
  assert Solution().strangePrinter("aba") == 2
#+end_src

* Leetcode: 943. Find the Shortest Superstring
:PROPERTIES:
:ID:       34806110-7C4D-47EF-A337-AA9018C3CB2E
:WA:       1
:END:
[[https://leetcode.com/problems/find-the-shortest-superstring/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  Did not test for single elements (e.g. ~["a"]~).

- [[id:FEEE596A-DFF4-4B02-8995-1BCF70A76410][Pattern: Find optimal subset of small set]].

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  After we put the word $i$, we should put a word $j$ using the maximum of overlap possible which is the biggest suffix of $i$ that is a prefix of $j$.  With that, we have to keep increasing the answer until all words are covered.

#+begin_src python
  from typing import List
  from functools import cache


  class Solution:
      def shortestSuperstring(self, words: List[str]) -> str:
          N = len(words)

          nxt = [list() for _ in range(N)]
          for i in range(N):
              for j in range(N):
                  for k in range(0, len(words[i]) + 1):
                      if words[j].startswith(words[i][k:]):
                          nxt[i].append((j, k))
                          break

          @cache
          def dfs(i, used):
              if used == (1 << N) - 1:
                  return words[i]

              ans = None
              for j, k in nxt[i]:
                  if used & (1 << j) != 0:
                      continue
                  s = words[i][:k] + words[j]
                  cur = words[i][:k] + dfs(j, used | (1 << j))
                  if ans is None or len(ans) > len(cur):
                      ans = cur

              return ans

          return min([dfs(i, 0) for i in range(N)], key=len)


  assert (
      Solution().shortestSuperstring(["alex", "loves", "leetcode"]) == "alexlovesleetcode"
  )
  assert (
      Solution().shortestSuperstring(["catg", "ctaagt", "gcta", "ttca", "atgcatc"])
      == "gctaagttcatgcatc"
  )
#+end_src

* Leetcode: 1359. Count All Valid Pickup and Delivery Options
:PROPERTIES:
:ID:       A74425B5-0ED5-4E3B-9D1B-D60D77FBB1A8
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-02 Tue 11:25]--[2022-08-02 Tue 22:11] => 10:46
CLOCK: [2022-08-02 Tue 11:04]--[2022-08-02 Tue 11:09] =>  0:05
:END:
[[https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/][Problem Statement]]

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  Select the order to pick and when it will be delivered.  To delivery the rest of order, we have the solve the same problem with less one order.  Time complexity is $O(n)$ and space is $O(1)$.

#+begin_src python
  class Solution:
      def countOrders(self, n: int) -> int:
          MOD = 10**9 + 7
          ans = 1
          for i in range(2, n + 1):
              ans = ((i * (2 * i - 1) % MOD) * ans) % MOD
          return ans


  assert Solution().countOrders(1) == 1
  assert Solution().countOrders(2) == 6
  assert Solution().countOrders(3) == 90
#+end_src

* Leetcode: 2167. Minimum Time to Remove All Cars Containing Illegal Goods
:PROPERTIES:
:ID:       FD2C957B-FE09-4290-AAFD-2FEB3203824D
:END:


[[https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/][Problem Statement]]

- [[id:461C7633-08C5-468D-9FC3-D78154DDBD42][Mistake: Careless coding]].  Came up with the way to count but didn't stop to verify if they were covering all cases.

- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]] where you had to compute $dp[i]$ using only the next $j$ that satisfy some condition.

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  The answer will have an interval $(i, j)$ (could be empty) where we will pay $2$ to remove the cars.   Therefore, it score is $i-1+ones(i,j)+n-j$.  We can't iterate over all intervals, but can compute the same score if we have $f(i)$ as the minimum score to remove cars from $i$ to $n-1$.  Now the problem is $min(i + f(i))$ for $0 \leq i < n$.  Time complexity is $O(n)$ with $O(1)$ space.

#+begin_src python
  class Solution:
      def minimumTime(self, s: str) -> int:
          N = len(s)
          best = 0
          ans = float("inf")
          j = N - 1
          for i in range(N - 1, -1, -1):
              if i == j:
                  j -= 1
                  while j >= 0 and s[j] == "0":
                      j -= 1
              best = min(N - i, 2 + best if s[i] == "1" else best)
              ans = min(ans, j + 1 + best)
          return ans


  assert Solution().minimumTime("1100101") == 5
  assert Solution().minimumTime("0010") == 2
#+end_src

* Leetcode: 1473. Paint House III
:PROPERTIES:
:ID:       6622D32E-1995-4D5E-B2F4-491BB7FB5FF5
:END:
[[https://leetcode.com/problems/paint-house-iii/][Problem Statement]]

- [[id:BA632D61-93B6-47AB-B11A-7E9EBE3FC71D][Can we derive an invariant based on the smallest possible examples?]]  If there is only one house, the answer is either 0 if it is painted or the cost of the cheapest color.  If there are two house, you can increase the number of neighborhoods by painting the second house in a different color than the first house, or keep the same number of neighborhoods by painting it with the same color.  Therefore, we can define the problem in terms of $h$ the current house that you are painting, $c$ the color that you want to use in this house and $t$ the number of neighborhoods that you are allowed to create.  Time and space complexity is $O(n^2 \times m)$ where $n$ is the number of houses and $m$ is the number of colors.

#+begin_src python
  from typing import List


  class Solution:
      def minCost(
          self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int
      ) -> int:
          N = len(houses)
          C = len(cost[0])

          dp = [[[float("inf")] * C for _ in range(target + 1)] for _ in range(N)]
          left = [[float("inf")] * C for _ in range(target + 1)]
          right = [[float("inf")] * C for _ in range(target + 1)]
          for i in range(N - 1, -1, -1):
              if i == N - 1:
                  if houses[i] == 0:
                      for c in range(C):
                          dp[i][1][c] = cost[i][c]
                  else:
                      dp[i][1][houses[i] - 1] = 0
              else:
                  for t in range(1, target + 1):
                      if houses[i] == 0:
                          for c in range(C):
                              dp[i][t][c] = cost[i][c] + min(
                                  dp[i + 1][t][c], left[t - 1][c], right[t - 1][c]
                              )

                      else:
                          for c in range(C):
                              if c == houses[i] - 1:
                                  dp[i][t][c] = min(
                                      dp[i + 1][t][c], left[t - 1][c], right[t - 1][c]
                                  )

              for t in range(1, target + 1):
                  for c in range(C):
                      left[t][c] = (
                          float("inf") if c == 0 else min(left[t][c - 1], dp[i][t][c - 1])
                      )
                  for c in range(C - 1, -1, -1):
                      right[t][c] = (
                          float("inf")
                          if c == C - 1
                          else min(right[t][c + 1], dp[i][t][c + 1])
                      )

          ans = min(dp[0][target][c] for c in range(C))
          return -1 if ans == float("inf") else ans


  assert (
      Solution().minCost(
          [0, 0, 0, 0, 0], [[1, 10], [10, 1], [10, 1], [1, 10], [5, 1]], 5, 2, 3
      )
      == 9
  )
  assert (
      Solution().minCost(
          [0, 2, 1, 2, 0], [[1, 10], [10, 1], [10, 1], [1, 10], [5, 1]], 5, 2, 3
      )
      == 11
  )
  assert (
      Solution().minCost(
          [3, 1, 2, 3], [[1, 1, 1], [1, 1, 1], [1, 1, 1], [1, 1, 1]], 4, 3, 3
      )
      == -1
  )
#+end_src

* Leetcode: 1723. Find Minimum Time to Finish All Jobs
:PROPERTIES:
:ID:       831DBDCC-2EE9-4678-9465-E0979A5C4AC1
:END:
:LOGBOOK:
CLOCK: [2022-08-02 Tue 22:11]--[2022-08-02 Tue 23:00] =>  0:49
:END:
[[https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/][Problem Statement]]

- [[id:477B8042-5F3E-4814-9F0B-C49485B85A64][Mistake: Did not consider different approaches]] and got stuck on the Dynamic Programming solution.

- [[id:FEEE596A-DFF4-4B02-8995-1BCF70A76410][Pattern: Find optimal subset of small set]].  Use [[id:EC1C87C8-A221-4823-9EF5-BEC706B2EEA5][Brute Force]] to assign each job to a worker and prune the search with the current maximum working time for the updated job.  To make the search faster, sort the input in decreasing order.

- [[id:29512D97-A54D-42F9-A8C7-C3422881933B][Can we use brute-force to solve the problem?]]  The most important prune is to make sure that a job is assigned as the first job of a work only once.  Time complexity is $O(n^k)$ but the prunes makes the solution faster than [[id:241ABA4C-A86F-405F-B6FC-85BF441EB24B][Dynamic Programming]].

#+begin_src python
  from typing import List


  class Solution:
      def minimumTimeRequired(self, jobs: List[int], K: int) -> int:
          N = len(jobs)
          jobs.sort(reverse=True)
          load = [0] * N
          ans = float("inf")

          def bt(i, cur):
              nonlocal ans
              if cur >= ans:
                  return
              if i == N:
                  ans = min(ans, cur)
                  return
              for j in range(K):
                  load[j] += jobs[i]
                  if load[j] < ans:
                      bt(i + 1, max(cur, load[j]))
                  load[j] -= jobs[i]
                  if load[j] == 0:
                      break

          bt(0, 0)
          return ans


  assert Solution().minimumTimeRequired([3, 2, 3], 3) == 3
  assert Solution().minimumTimeRequired([1, 2, 4, 7, 8], 2) == 11
#+end_src

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  The search-space is defined by $(k, S)$ where $k$ is the number of workers used so far and $S$ represents the completed jobs.  Time and space complexity is $O(k \times 2^n)$.

#+begin_src python
  from typing import List


  class Solution:
      def minimumTimeRequired(self, jobs: List[int], K: int) -> int:
          S = sum(jobs)
          N = len(jobs)
          M = 2**N

          cost = [0] * M
          for i in range(M):
              for j in range(N):
                  if i & (1 << j):
                      cost[i] += jobs[j]

          def submasks(mask):
              submask = mask
              while submask:
                  yield submask
                  submask = (submask - 1) & mask

          dp = [[float("inf")] * M for _ in range(K + 1)]
          for k in range(K, -1, -1):
              if k == K:
                  dp[k][M - 1] = 0
              else:
                  for used in range(M):
                      allowed = (M - 1) ^ used
                      cur = float("inf")
                      for new in submasks(allowed):
                          if cost[new] < cur:
                              cur = min(cur, max(cost[new], dp[k + 1][used | new]))
                      dp[k][used] = cur
          return dp[0][0]


  assert Solution().minimumTimeRequired([3, 2, 3], 3) == 3
  assert Solution().minimumTimeRequired([1, 2, 4, 7, 8], 2) == 11
#+end_src

* Leetcode: 1240. Tiling a Rectangle with the Fewest Squares
:PROPERTIES:
:ID:       DE17B373-DBD7-4ADD-9CEE-7AC427FEAE6B
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-03 Wed 16:20]--[2022-08-03 Wed 19:32] =>  3:12
:END:

- [[id:40E38FD2-DDF0-4C25-BB8C-43D07F3D5136][Mistake: Overcomplicated solution]].  My [[id:605B3009-7C7C-410A-9361-218A24ED8D8C][Backtracking]] had the current square size to paint what made the solution too complicated.

- [[id:29512D97-A54D-42F9-A8C7-C3422881933B][Can we use brute-force to solve the problem?]]  For each cell of the rectangle, for each possible square that can have its top-left corner on that cell, fill the area and move to the next empty cell *on the same line*.   If there is no empty line in the line, continue the [[id:605B3009-7C7C-410A-9361-218A24ED8D8C][Backtracking]] on the next row.  Time complexity is $O(n \times m \times k^3)$ and space is $O(n \times m)$.

#+begin_src python
  class Solution:
      def tilingRectangle(self, n: int, m: int) -> int:
          grid = [[0] * m for _ in range(n)]

          ans = n * m

          def bt(i, j, cur):
              nonlocal ans
              if cur >= ans:
                  return
              if i == n:
                  ans = min(ans, cur)
                  return
              while j < m and grid[i][j] > 0:
                  j += 1
              if j == m:
                  bt(i + 1, 0, cur)
                  return
              for k in range(min(n - i, m - j), 0, -1):
                  valid = True
                  for ii in range(i, i + k):
                      for jj in range(j, j + k):
                          if grid[ii][jj] > 0:
                              valid = False
                          grid[ii][jj] += 1
                  if valid:
                      bt(i, j + k, cur + 1)
                  for ii in range(i, i + k):
                      for jj in range(j, j + k):
                          grid[ii][jj] -= 1

          bt(0, 0, 0)
          return ans


  assert Solution().tilingRectangle(2, 3) == 3
  assert Solution().tilingRectangle(5, 8) == 5
  assert Solution().tilingRectangle(11, 13) == 6
#+end_src

* Leetcode: 2172. Maximum AND Sum of Array
:PROPERTIES:
:ID:       D9866DA4-E256-431C-9568-4F34C7EB634B
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-03 Wed 19:59]--[2022-08-03 Wed 21:08] =>  1:09
:END:
[[https://leetcode.com/problems/maximum-and-sum-of-array/][Problem Statement]]

- [[id:477B8042-5F3E-4814-9F0B-C49485B85A64][Mistake: Did not consider different approaches]].  I got stuck on representing only the used numbers in the bitmask.

- [[id:13025164-D62A-450B-AA2F-332E097F7A16][What are the different ways to represent the search-space?]]  The first way that came to mind was $(k, s)$ where $k$ is the next slot to fill up and $s$ is the set of used numbers.  Space is $O(k \times 2^n)$ and time complexity is $O(k \times 2^n \times n^2)$.   As $k$ is *small*, the best way to represent the search-space is $(i, p, q)$ where $i$ is the number that I want to place, $p$ is a set of slots that has one position (left position) used and $q$ is a set of slots that have one position (right position) used.  Space is $O(n \times 2^k \times 2^k)$ and times complexity is $O(n^2 \times 2^k \times 2^k)$.

#+begin_src python
  from typing import List
  from functools import cache


  class Solution:
      def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
          N = len(nums)
          ans = float("-inf")

          @cache
          def dfs(i, f, s):
              if i == N:
                  return 0
              ans = float("-inf")
              for j in range(numSlots):
                  c = nums[i] & (j + 1)
                  if f & (1 << j) == 0:
                      ans = max(ans, c + dfs(i + 1, f | (1 << j), s))
                  elif s & (1 << j) == 0:
                      ans = max(ans, c + dfs(i + 1, f, s | (1 << j)))
              return ans

          return dfs(0, 0, 0)


  assert Solution().maximumANDSum([1, 2, 3, 4, 5, 6], 3) == 9
  assert Solution().maximumANDSum([1, 3, 10, 4, 7, 1], 9) == 24
#+end_src

#+begin_src python
  class Solution:
      def maximumANDSum(self, nums: List[int], numSlots: int) -> int:
          N = len(nums)

          @cache
          def dfs(i, used):
              if i == N:
                  return 0

              ans = 0
              cur = used
              b = 1
              for k in range(1, numSlots + 1):
                  slot = cur % 3
                  cur = cur // 3
                  if slot < 2:
                      ans = max(ans, (nums[i] & k) + dfs(i + 1, used + b))
                  b = b * 3
              return ans

          return dfs(0, 0)
#+end_src

* Leetcode: 317. Shortest Distance from All Buildings
:PROPERTIES:
:ID:       EADAA76E-ACE0-46E4-9B58-4570CFEF0A27
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-08-03 Wed 21:09]--[2022-08-03 Wed 23:01] =>  1:52
:END:
[[https://leetcode.com/problems/shortest-distance-from-all-buildings/][Problem Statement]]

- [[id:40E38FD2-DDF0-4C25-BB8C-43D07F3D5136][Mistake: Overcomplicated solution]].  It would be easier to extract the [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] function.

- [[id:56B18554-8EDB-44AF-B72A-8FD307B2980C][Mistake: High constant factor in the implementation]].  Anything close to $10^8$ needs heavy optimization in python.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Compute the distance from each house to an empty space and take the space that can be reached by all houses with the lower total distance.  Time complexity is $O(n^2 \times m^2)$ and space is $O(n \times m)$.

#+begin_src python
  from typing import List


  class Solution:
      def shortestDistance(self, grid: List[List[int]]) -> int:
          N = len(grid)
          M = len(grid[0])
          dst = [[0] * M for _ in range(N)]
          cnt = [[0] * M for _ in range(N)]

          delta = [[+1, +0], [-1, +0], [+0, +1], [+0, -1]]

          def bfs(si, sj):
              vis = [[False] * M for _ in range(N)]
              queue = [(si, sj, 0)]
              for i, j, d in queue:
                  dst[i][j] += d
                  cnt[i][j] += 1
                  for di, dj in delta:
                      ni = di + i
                      nj = dj + j
                      if 0 <= ni < N and 0 <= nj < M and not vis[ni][nj]:
                          vis[ni][nj] = True
                          if grid[ni][nj] == 0:
                              queue.append((ni, nj, d + 1))
                          elif grid[ni][nj] == 1:
                              cnt[ni][nj] += 1

          houses = 0
          for si in range(N):
              for sj in range(M):
                  if grid[si][sj] == 1:
                      if cnt[si][sj] != houses:
                          return -1
                      houses += 1
                      bfs(si, sj)

          ans = float("inf")
          for i in range(N):
              for j in range(M):
                  if grid[i][j] == 0 and cnt[i][j] == houses and ans > dst[i][j]:
                      ans = dst[i][j]

          return -1 if ans == float("inf") else ans


  assert (
      Solution().shortestDistance([[1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]])
      == 7
  )
  assert Solution().shortestDistance([[1, 0]]) == 1
  assert Solution().shortestDistance([[1]]) == -1
#+end_src

* Leetcode: 920. Number of Music Playlists
:PROPERTIES:
:ID:       D40521FF-7104-4205-BF6D-2D62D7784AFE
:ORDERED:  t
:END:
:LOGBOOK:
CLOCK: [2022-08-04 Thu 10:16]--[2022-08-04 Thu 11:14] =>  0:58
:END:
[[https://leetcode.com/problems/number-of-music-playlists/][Problem Statement]]

- [[id:477B8042-5F3E-4814-9F0B-C49485B85A64][Mistake: Did not consider different approaches]].  Got stuck on a recursion using $(i, r)$ the  $i$ song to play having to play $r$ required songs.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Suppose that you played $i$ songs which $j$ are unique songs.  There are two ways to select the next song: (1) you play one of $n - j$ new songs, or (2) you play one $\max(j - k, 0)$ already played songs.  Time and space complexity is $O(g \times n)$.

#+begin_src python
  class Solution:
      def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:
          MOD = 10**9 + 7

          @cache
          def dfs(i, u):
              if i == goal:
                  return 1 if u == n else 0
              return ((n - u) * dfs(i + 1, u + 1) + max(u - k, 0) * dfs(i + 1, u)) % MOD

          return dfs(0, 0)
#+end_src

* Leetcode: 302. Smallest Rectangle Enclosing Black Pixels
:PROPERTIES:
:ID:       5E66EF96-0941-4961-8370-C640ABE434C0
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-08-04 Thu 16:47]
:END:
[[https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]]. Missed the restriction of the time complexity.

- [[id:3ECFA6C4-B482-49CA-B8C6-C67DA07B6EAE][Can we state the problem as result of multiple searches?]]  Do a [[id:1217FC3D-A9F9-49EC-BA5D-A68E50338DBD][Binary-search]] to find the first and last row and column.  Time complexity is $O(n \log n + m \log m)$ and space is $O(1)$.

#+begin_src python
  from typing import List


  class Solution:
      def minArea(self, image: List[List[str]], x: int, y: int) -> int:
          N = len(image)
          M = len(image[0])

          def first(lo, hi, chk):
              while lo < hi:
                  m = lo + (hi - lo) // 2
                  if chk(m):
                      hi = m
                  else:
                      lo = m + 1
              return lo if chk(lo) else lo + 1

          l = first(0, y, lambda j: any(image[i][j] == "1" for i in range(N)))
          r = first(y, M - 1, lambda j: all(image[i][j] == "0" for i in range(N)))
          u = first(0, x, lambda i: "1" in image[i])
          d = first(x, N - 1, lambda i: "1" not in image[i])

          return (l - r) * (u - d)


  assert (
      Solution().minArea(
          [["0", "0", "1", "0"], ["0", "1", "1", "0"], ["0", "1", "0", "0"]], 0, 2
      )
      == 6
  )
  assert Solution().minArea([["1"]], 0, 0) == 1
#+end_src

* Leetcode: 1697. Checking Existence of Edge Length Limited Paths
:PROPERTIES:
:ID:       598AF36B-1883-4A5F-9F07-36DC10B3B504
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-05 Fri 15:52]--[2022-08-05 Fri 16:02] =>  0:10
:END:
[[https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/][Problem Statement]]

- [[id:117736F8-6CF6-435F-9043-18B8D22EDDE9][Pattern: Answer queries on online graph]].

- [[id:1CFF662A-6F16-43CE-BB07-EA12BA382690][Can we formulate the problem as a classical problem?]]  Find if two vertices are on the same component.  The problem asks to find a path that doesn't exceed the limit, so we build the components without exceeding the limit (i.e. add the edges) and then ask if they are part of the same component.  Time complexity is $O(n \times \log n)$ and space is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def distanceLimitedPathsExist(
          self, N: int, edges: List[List[int]], queries: List[List[int]]
      ) -> List[bool]:
          E = len(edges)
          edges.sort(key=lambda e: e[2])

          p = [i for i in range(N)]

          def find(u):
              if p[u] != u:
                  p[u] = find(p[u])
              return p[u]

          def union(u, v):
              p[find(u)] = p[find(v)]

          ans = [False] * len(queries)
          j = 0
          for i, (u, v, l) in sorted(enumerate(queries), key=lambda e: e[1][2]):
              while j < E and edges[j][2] < l:
                  union(edges[j][0], edges[j][1])
                  j += 1
              ans[i] = find(u) == find(v)

          return ans


  assert Solution().distanceLimitedPathsExist(
      3, [[0, 1, 2], [1, 2, 4], [2, 0, 8], [1, 0, 16]], [[0, 1, 2], [0, 2, 5]]
  ) == [False, True]
  assert Solution().distanceLimitedPathsExist(
      5, [[0, 1, 10], [1, 2, 5], [2, 3, 9], [3, 4, 13]], [[0, 4, 14], [1, 4, 13]]
  ) == [True, False]
#+end_src

* Leetcode: 843. Guess the Word
:PROPERTIES:
:ID:       559F0C7E-8D58-4212-B2C0-BB3DEDCD9D94
:END:
:LOGBOOK:
CLOCK: [2022-07-19 Tue 17:36]--[2022-07-19 Tue 18:31] =>  0:55
CLOCK: [2022-07-19 Tue 16:09]--[2022-07-19 Tue 16:19] =>  0:10
:END:
[[https://leetcode.com/problems/guess-the-word/][Problem Statement]]

- [[id:716E3863-6B6F-4F6F-86ED-72820E061E11][Pattern: Remove max number of candidates every turn]].

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  There are two important parts of the problem: (1) filter words after a guess and (2) pick the best guess.  For the first, we have to filter all words which the number of matches is different than the number of matches from the last guess (the secret will have to match these letters any way).  The more problematic guess is the one that returns 0.  In this situation, we want to remove the maximum number of words as possible.  To do that, we take the word that contains the most frequent letter per position.  If it returns 0, then you are guaranteed to remove as much words as possible.  Time and space complexity are $O(n)$.

#+begin_src python
  from typing import List

  # """
  # This is Master's API interface.
  # You should not implement it, or speculate about its implementation
  # """
  # class Master:
  #     def guess(self, word: str) -> int:


  class Solution:
      def findSecretWord(self, wordlist: List[str], master: "Master") -> None:
          N = len(wordlist[0])

          f = [Counter(w[i] for w in wordlist) for i in range(6)]
          wordlist.sort(reverse=True, key=lambda w: sum(f[i][c] for i, c in enumerate(w)))

          @cache
          def guess(s1, s2):
              ans = 0
              for a, b in zip(s1, s2):
                  ans += 1 if a == b else 0
              return ans

          value = 0
          for _ in range(30):
              if not wordlist or value == N:
                  break
              candidate = wordlist[0]
              value = master.guess(candidate)
              wordlist = [
                  w for w in wordlist if w != candidate and guess(candidate, w) == value
              ]
#+end_src

* TODO Leetcode: 164. Maximum Gap
:PROPERTIES:
:ID:       4373FA38-A210-47A9-A473-18540B1F1C96
:END:
:LOGBOOK:
CLOCK: [2022-07-28 Thu 18:44]--[2022-07-28 Thu 19:44] =>  1:00
CLOCK: [2022-08-17 Wed 16:20]--[2022-08-17 Wed 16:56] =>  0:36
:END:
[[https://leetcode.com/problems/maximum-gap/][Problem Statement]]

* TODO Leetcode: 1000. Minimum Cost to Merge Stones
:PROPERTIES:
:ID:       AFA49C8B-27B6-48CD-887F-F299006900BC
:END:
:LOGBOOK:
CLOCK: [2022-07-29 Fri 15:56]--[2022-07-29 Fri 17:00] =>  1:04
CLOCK: [2022-07-28 Thu 21:50]--[2022-07-28 Thu 22:28] =>  0:38
:END:
[[https://leetcode.com/problems/minimum-cost-to-merge-stones/][Problem Statement]]

* Leetcode: 2060. Check if an Original String Exists Given Two Encoded Strings
:PROPERTIES:
:ID:       FA18EDEA-910C-413D-86D3-241942EBFF92
:END:
:LOGBOOK:
CLOCK: [2022-08-01 Mon 10:41]--[2022-08-01 Mon 11:24] =>  0:43
CLOCK: [2022-07-31 Sun 22:14]--[2022-07-31 Sun 22:52] =>  0:38
:END:
[[https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  Did not check for ~ab~ and ~aN~ where ~N~ is any number.

- [[id:AF523FD7-71A3-44F0-B9F2-E288B8A6EB6D][Mistake: Wrong time complexity]].  Thought that the problem was [[id:605B3009-7C7C-410A-9361-218A24ED8D8C][Backtracking]] and missed that I could  memoize the params to speed up the solution.

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  The search space is defined by $(i, w1, j, w2)$ where $i$ and $j$ are the next position to be processed on $s1$ and $s2$ respectively after $w1$ and $w2$ wild chars are processed.  Space complexity is then $O(n^2)$ with big constant of since $w1 \times w2 \leq 999^2$.  With the search space defined, the rest is make sure that all transitions are covered.  Time complexity is $O(n^2)$.

#+begin_src python
  class Solution:
      def possiblyEquals(self, s1: str, s2: str) -> bool:
          N = len(s1)
          M = len(s2)

          @cache
          def dfs(i, w1, j, w2):
              if w1 > 0 and w2 > 0:
                  return dfs(i, w1 - min(w1, w2), j, w2 - min(w1, w2))
              if w1 > 0 and j < M and s2[j].isalpha():
                  return dfs(i, w1 - 1, j + 1, 0)
              if w2 > 0 and i < N and s1[i].isalpha():
                  return dfs(i + 1, 0, j, w2 - 1)
              if w1 == 0:
                  for k in range(i, min(i + 3, N)):
                      if s1[i:k+1].isdigit():
                          if dfs(k+1, int(s1[i:k+1]), j, w2):
                              return True
              if w2 == 0:
                  for k in range(j, min(j + 3, M)):
                      if s2[j:k+1].isdigit():
                          if dfs(i, w1, k+1, int(s2[j:k+1])):
                              return True
              if i == N or j == M:
                  return i == N and j == M and w1 == 0 and w2 == 0
              if s1[i].isalpha() and s2[j].isalpha():
                  return dfs(i + 1, 0, j + 1, 0) if s1[i] == s2[j] else False
              return False

          return dfs(0, 0, 0, 0)
#+end_src

* TODO Leetcode: 420. Strong Password Checker
:PROPERTIES:
:ID:       315D6ADD-7DCE-4446-8A52-FBC5A0DDDABD
:END:
:LOGBOOK:
CLOCK: [2022-08-05 Fri 16:15]--[2022-08-05 Fri 19:59] =>  3:44
:END:
[[https://leetcode.com/problems/strong-password-checker/][Problem Statement]]
* Leetcode: 1263. Minimum Moves to Move a Box to Their Target Location
:PROPERTIES:
:ID:       C39E37E2-B683-4651-AC6A-D9342F8A832E
:END:
:LOGBOOK:
CLOCK: [2022-08-11 Thu 17:04]--[2022-08-11 Thu 17:10] =>  0:06
:END:
[[https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/][Problem Statement]]

- [[id:189F5E87-F560-4397-A3E3-AAD465EEBCFB][Pattern: Find shortest path between two vertices in a graph]].

- [[id:1CFF662A-6F16-43CE-BB07-EA12BA382690][Can we formulate the problem as a classical problem?]] [[id:8BACB101-3C8B-47CA-9AB1-89D52F85F6DA][Shortest Path in a Graph Problem]].  Time complexity is $O(n \times m \times \log(n \times m))$ and space $O(n \times m)$.

#+begin_src python
  from typing import List


  class Solution:
      def minPushBox(self, grid: List[List[str]]) -> int:
          N = len(grid)
          M = len(grid[0])
          D = [[+1, +0], [-1, +0], [+0, +1], [+0, -1]]

          S = B = T = None
          for i in range(N):
              for j in range(M):
                  if grid[i][j] == "S":
                      S = (i, j)
                  elif grid[i][j] == "B":
                      B = (i, j)
                  elif grid[i][j] == "T":
                      T = (i, j)

          seen = set()
          pq = [(0, S, B)]
          while pq:
              pushes, s, b = heappop(pq)
              if b == T:
                  return pushes
              for di, dj in D:
                  nsi, nsj = s[0] + di, s[1] + dj
                  ns = (nsi, nsj)
                  if 0 <= nsi < N and 0 <= nsj < M and grid[nsi][nsj] != "#":
                      if ns == b:
                          nbi, nbj = b[0] + di, b[1] + dj
                          nb = (nbi, nbj)
                          if (
                              0 <= nbi < N
                              and 0 <= nbj < M
                              and grid[nbi][nbj] != "#"
                              and (ns, nb) not in seen
                          ):
                              seen.add((ns, nb))
                              heappush(pq, (pushes + 1, ns, nb))
                      elif (ns, b) not in seen:
                          seen.add((ns, b))
                          heappush(pq, (pushes, ns, b))

          return -1


  assert (
      Solution().minPushBox(
          [
              ["#", "#", "#", "#", "#", "#"],
              ["#", "T", "#", "#", "#", "#"],
              ["#", ".", ".", "B", ".", "#"],
              ["#", ".", "#", "#", ".", "#"],
              ["#", ".", ".", ".", "S", "#"],
              ["#", "#", "#", "#", "#", "#"],
          ]
      )
      == 3
  )
  assert (
      Solution().minPushBox(
          [
              ["#", "#", "#", "#", "#", "#"],
              ["#", "T", "#", "#", "#", "#"],
              ["#", ".", ".", "B", ".", "#"],
              ["#", "#", "#", "#", ".", "#"],
              ["#", ".", ".", ".", "S", "#"],
              ["#", "#", "#", "#", "#", "#"],
          ]
      )
      == -1
  )
  assert (
      Solution().minPushBox(
          [
              ["#", "#", "#", "#", "#", "#"],
              ["#", "T", ".", ".", "#", "#"],
              ["#", ".", "#", "B", ".", "#"],
              ["#", ".", ".", ".", ".", "#"],
              ["#", ".", ".", ".", "S", "#"],
              ["#", "#", "#", "#", "#", "#"],
          ]
      )
      == 5
  )
#+end_src

* Leetcode: 2277. Closest Node to Path in Tree
:PROPERTIES:
:ID:       F0C49759-DF3D-4CFF-BB16-553FE6A89D76
:END:
:LOGBOOK:
CLOCK: [2022-08-05 Fri 19:59]--[2022-08-05 Fri 20:35] =>  0:36
:END:
[[https://leetcode.com/problems/closest-node-to-path-in-tree/][Problem Statement]]

- [[id:1CFF662A-6F16-43CE-BB07-EA12BA382690][Can we formulate the problem as a classical problem?]]  For each query $(u, v, p)$, search for $v$ and $p$ starting from $u$ while keeping track of the last both that could reach both of them.  Time and space complexity for each query is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def closestNode(
          self, n: int, edges: List[List[int]], query: List[List[int]]
      ) -> List[int]:
          A = defaultdict(list)
          for u, v in edges:
              A[u].append(v)
              A[v].append(u)

          def dfs(root, parent, e1, e2):
              if root == e1 or root == e2:
                  return root
              found = []
              for u in A[root]:
                  if u != parent:
                      v = dfs(u, root, e1, e2)
                      if v is not None:
                          found.append(v)
              if found:
                  return found[0] if len(found) == 1 else root
              return None

          return [dfs(q, None, u, v) for u, v, q in query]


  assert Solution().closestNode(
      7, [[0, 1], [0, 2], [0, 3], [1, 4], [2, 5], [2, 6]], [[5, 3, 4], [5, 3, 6]]
  ) == [0, 2]
  assert Solution().closestNode(3, [[0, 1], [1, 2]], [[0, 1, 2]]) == [1]
  assert Solution().closestNode(3, [[0, 1], [1, 2]], [[0, 0, 0]]) == [0]
#+end_src

* Leetcode: 679. 24 Game
:PROPERTIES:
:ID:       1C4943CB-4776-48C0-9A79-4FACBE4A91BC
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-08-06 Sat 10:17]--[2022-08-06 Sat 12:28] =>  2:11
CLOCK: [2022-08-05 Fri 20:36]--[2022-08-05 Fri 20:50] =>  0:14
:END:
[[https://leetcode.com/problems/24-game/][Problem Statement]]

- [[id:AFD7D485-25CB-450F-B116-365FE7239669][Mistake: Bug introduced when copy-pasting code]].

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  One and two numbers are easy to solve.  For more numbers, break them down on all possible groups and recursively compute the expressions.  Time complexity is $T=O(n! \times 2^n \times 4)$ and space complexity is $O(n \times T)$.

#+begin_src python
  from typing import List
  from itertools import permutations
  from math import gcd

  class Fraction:
      def __init__(self, a, b):
          if b == 0:
              self.a = None
              self.b = None
          else:
              d = gcd(a, b)
              self.a = a // d
              self.b = b // d

      def __str__(self):
          return f"{self.a}/{self.b}"

      def __eq__(self, other):
          return self.a == other.a and self.b == other.b

      def __add__(self, other):
          if self.a is None or other.a is None:
              return self
          return Fraction(self.a * other.b + other.a * self.b, self.b * other.b)

      def __sub__(self, other):
          if self.a is None or other.a is None:
              return self
          return Fraction(self.a * other.b - other.a * self.b, self.b * other.b)

      def __mul__(self, other):
          if self.a is None or other.a is None:
              return self
          return Fraction(self.a * other.a, self.b * other.b)

      def __truediv__(self, other):
          if self.a is None or other.a is None:
              return self
          return self * Fraction(other.b, other.a)


  class Solution:
      def judgePoint24(self, cards: List[int]) -> bool:
          cards = [Fraction(c, 1) for c in cards]

          def calc(c):
              if len(c) == 1:
                  return [c[0]]
              if len(c) == 2:
                  return [c[0] + c[1], c[0] - c[1], c[0] * c[1], c[0] / c[1]]
              ans = []
              for i in range(1, len(c)):
                  left = calc(c[:i])
                  right = calc(c[i:])
                  for l in left:
                      for r in right:
                          ans.extend(calc([l, r]))
              return ans

          return any(Fraction(24, 1) in calc(p) for p in permutations(cards))


  assert Solution().judgePoint24([4, 1, 8, 7]) == True
  assert Solution().judgePoint24([1, 2, 1, 2]) == False
#+end_src

* Leetcode: 1345. Jump Game IV
:PROPERTIES:
:ID:       D1BAEFBE-3B69-46A2-86B3-9C8CC1695BE7
:END:
:LOGBOOK:
CLOCK: [2022-08-06 Sat 15:40]--[2022-08-06 Sat 16:20] =>  0:40
:END:
[[https://leetcode.com/problems/jump-game-iv/][Problem Statement]]

- [[id:00CC89B4-340B-4219-9CF4-837F558947B4][Mistake: Bug caused by debug code]].

- [[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Each element of the array is a vertex and edges are created following the rules.  The problem becomes finding the [[id:8BACB101-3C8B-47CA-9AB1-89D52F85F6DA][Shortest Path in a Graph Problem]] which can be done by a [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]] since edges have no weight.  Time and space complexity is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def minJumps(self, arr: List[int]) -> int:
          adj = defaultdict(list)
          for i, a in enumerate(arr):
              adj[a].append(i)

          N = len(arr)
          vis = [False] * N

          queue = [(0, 0)]
          vis[0] = True

          for (steps, i) in queue:
              if i == N - 1:
                  return steps
              while adj[arr[i]]:
                  j = adj[arr[i]].pop()
                  if not vis[j]:
                      vis[j] = True
                      queue.append((steps + 1, j))
              for j in i + 1, i - 1:
                  if 0 <= j < N and not vis[j]:
                      vis[j] = True
                      queue.append((steps + 1, j))


  assert Solution().minJumps([100, -23, -23, 404, 100, 23, 23, 23, 3, 404]) == 3
  assert Solution().minJumps([7]) == 0
  assert Solution().minJumps([7, 6, 9, 6, 9, 6, 9, 7]) == 1
#+end_src

* Leetcode: 1499. Max Value of Equation
:PROPERTIES:
:ID:       F8B0A786-E771-4433-B1FB-B4D2E0857E30
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-06 Sat 17:36]--[2022-08-06 Sat 18:15] =>  0:39
:END:
[[https://leetcode.com/problems/max-value-of-equation/][Problem Statement]]

- [[id:BA632D61-93B6-47AB-B11A-7E9EBE3FC71D][Can we derive an invariant based on the smallest possible examples?]]  Be $i$ and $j$ two points where $x_j \leq x_i$, $j < i$, $x_i - x_j \leq k$.  The formula becomes $y_j + y_i + x_i - x_j = (y_j - x_j) + (y_i + x_i)$.  To maximize the formula, we have to pick the point $j$ that maximizes $y_j - x_j$ and this can be done by keeping a list of candidates sorted by this value.  Time complexity is $O(n \log n)$ and space is $O(n)$.
b
#+begin_src python
  from typing import List
  from heapq import heappush, heappop


  class Solution:
      def findMaxValueOfEquation(self, points: List[List[int]], k: int) -> int:
          pq = []
          ans = float("-inf")
          for p in points:
              while pq and p[0] - pq[0][1][0] > k:
                  heappop(pq)

              if pq:
                  cur = p[1] + pq[0][1][1] + (p[0] - pq[0][1][0])
                  if cur > ans:
                      ans = cur
              heappush(pq, (p[0] - p[1], p))
          return ans


  assert Solution().findMaxValueOfEquation([[1, 3], [2, 0], [5, 10], [6, -10]], 1) == 4
  assert Solution().findMaxValueOfEquation([[0, 0], [3, 0], [9, 2]], 3) == 3
#+end_src

* Leetcode: 1793. Maximum Score of a Good Subarray
:PROPERTIES:
:ID:       EEA7EA90-6CD6-48DE-A12B-024DE884B9F4
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-06 Sat 18:55]--[2022-08-06 Sat 20:14] =>  1:19
:END:
[[https://leetcode.com/problems/maximum-score-of-a-good-subarray/][Problem Statement]]

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  The problem asks to find indexes $i$ and $j$ such that $i \leq k \leq j$, but the optimal choice can have the minimum value in $i$ or $j$.  Therefore, we can try to find the best $j$ by supposing that $i$ the is minimum one and the do the same fixing $j$.  To do so, we need a data structure (two sorted lists) that we could query $j$ in logarithm time.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  from typing import List
  from sortedcontainers import SortedList


  class Solution:
      def maximumScore(self, nums: List[int], k: int) -> int:
          return max(solve(nums, k), solve(list(reversed(nums)), len(nums) - k - 1))


  def solve(nums, k):
      right = []
      cur = float("+inf")
      for i in range(k, len(nums)):
          cur = min(cur, nums[i])
          right.append((i, cur))

      a = SortedList(right, key=lambda e: -e[1])
      c0 = SortedList([], key=lambda e: e[1])
      c1 = SortedList([], key=lambda e: -e[0])

      ans = float("-inf")
      cur = float("+inf")
      for i in range(k, -1, -1):
          cur = min(cur, nums[i])
          while a and a[0][1] >= cur:
              e = a.pop(0)
              c0.add(e)
              c1.add(e)
          while c0 and c0[0][1] < cur:
              e = c0.pop(0)
              c1.discard(e)
          if c1 and cur * (c1[0][0] - i + 1) > ans:
              ans = cur * (c1[0][0] - i + 1)
      return ans


  assert Solution().maximumScore([1, 4, 3, 7, 4, 5], 3) == 15
  assert Solution().maximumScore([5, 5, 4, 5, 4, 1, 1, 1], 0) == 20
#+end_src

#+begin_src python
  from typing import List


  class Solution:
      def maximumScore(self, nums: List[int], k: int) -> int:
          return max(solve(nums, k), solve(list(reversed(nums)), len(nums) - k - 1))


  def solve(nums, k):
      right = []
      cur = float("+inf")
      for i in range(k, len(nums)):
          cur = min(cur, nums[i])
          if right and right[-1][1] == cur:
              right[-1][0] = i
          else:
              right.append([i, cur])
      right.sort(key=lambda e: e[1], reverse=True)

      j = 0
      ans = float("-inf")
      cur = float("+inf")
      for i in range(k, -1, -1):
          cur = min(cur, nums[i])
          while j < len(right) and right[j][1] > cur:
              j += 1
          if j == len(right):
              ans = max(ans, cur * (len(nums) - i))
          else:
              ans = max(ans, cur * (right[j if right[j][1] == cur else j - 1][0] - i + 1))
      return ans


  assert Solution().maximumScore([1, 4, 3, 7, 4, 5], 3) == 15
  assert Solution().maximumScore([5, 5, 4, 5, 4, 1, 1, 1], 0) == 20
#+end_src

- [[id:BA632D61-93B6-47AB-B11A-7E9EBE3FC71D][Can we derive an invariant based on the smallest possible examples?]]  Suppose the input is $3,4,5$.  If we start from $4$, we would expand the interval first to $5$ and then to $3$ to make sure that we would consider the minimum $4$ times its max range.  If the input is $5, 4, 3$, we would like to expand first to the left and then to the right.  Starting from $k$, we have only two choices to make to expand the interval: expand to the direction that maximizes the minimum value.  Time complexity is $O(n)$ and space is $O(1)$.

#+begin_src python
  from typing import List


  class Solution:
      def maximumScore(self, nums: List[int], k: int) -> int:
          i = j = k
          ans = m = nums[k]

          while i > 0 or j < len(nums) - 1:
              if i == 0:
                  j += 1
              elif j == len(nums) - 1:
                  i -= 1
              elif nums[i - 1] < nums[j + 1]:
                  j += 1
              else:
                  i -= 1
              m = min(m, nums[i], nums[j])
              ans = max(ans, m * (j - i + 1))

          return ans


  assert Solution().maximumScore([1, 4, 3, 7, 4, 5], 3) == 15
  assert Solution().maximumScore([5, 5, 4, 5, 4, 1, 1, 1], 0) == 20
#+end_src

* Leetcode: 499. The Maze III
:PROPERTIES:
:ID:       6529D0E0-894E-41D4-A1B3-10349326DBC3
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-06 Sat 22:32]--[2022-08-06 Sat 22:57] =>  0:25
:END:
[[https://leetcode.com/problems/the-maze-iii/][Problem Statement]]

- [[id:1CFF662A-6F16-43CE-BB07-EA12BA382690][Can we formulate the problem as a classical problem?]]  Find [[id:8BACB101-3C8B-47CA-9AB1-89D52F85F6DA][Shortest Path in a Graph Problem]] where the path is measure by the distance and then its description.  Time complexity is $O((n \times m) \times \log (n \times m))$ and space is $O(n \times m)$.

#+begin_src python
  from typing import List
  from heapq import heappush, heappop


  class Solution:
      def findShortestWay(
          self, maze: List[List[int]], ball: List[int], hole: List[int]
      ) -> str:
          N = len(maze)
          M = len(maze[0])
          D = {"u": [-1, +0], "d": [+1, +0], "l": [+0, -1], "r": [+0, +1]}

          def move(d, i, j):
              ni = i + D[d][0]
              nj = j + D[d][1]
              if 0 <= ni < N and 0 <= nj < M and maze[ni][nj] == 0:
                  return (ni, nj)
              return None

          pq = [(0, d, ball[0], ball[1]) for d in D]
          seen = set(tuple(e[1:]) for e in pq)
          while pq:
              dist, path, i, j = heappop(pq)
              if hole[0] == i and hole[1] == j:
                  return path

              nxt = move(path[-1], i, j)
              if nxt and nxt not in seen:
                  heappush(pq, (dist + 1, path, *nxt))
                  continue

              for d in "u", "d", "l", "r":
                  if (d, i, j) not in seen:
                      seen.add((d, i, j))
                      heappush(pq, (dist, path + d, i, j))

          return "impossible"


  assert (
      Solution().findShortestWay(
          [
              [0, 0, 0, 0, 0],
              [1, 1, 0, 0, 1],
              [0, 0, 0, 0, 0],
              [0, 1, 0, 0, 1],
              [0, 1, 0, 0, 0],
          ],
          [4, 3],
          [0, 1],
      )
      == "lul"
  )
  assert (
      Solution().findShortestWay(
          [
              [0, 0, 0, 0, 0],
              [1, 1, 0, 0, 1],
              [0, 0, 0, 0, 0],
              [0, 1, 0, 0, 1],
              [0, 1, 0, 0, 0],
          ],
          [4, 3],
          [3, 0],
      )
      == "impossible"
  )
  assert (
      Solution().findShortestWay(
          [
              [0, 0, 0, 0, 0, 0, 0],
              [0, 0, 1, 0, 0, 1, 0],
              [0, 0, 0, 0, 1, 0, 0],
              [0, 0, 0, 0, 0, 0, 1],
          ],
          [0, 4],
          [3, 5],
      )
      == "dldr"
  )
#+end_src

* Leetcode: 312. Burst Balloons
:PROPERTIES:
:ID:       12BA5684-2AD8-4891-A53B-7E4C08A73882
:WA:       0
:END:
[[https://leetcode.com/problems/burst-balloons/][Problem Statement]]

- [[id:9F096D07-EED2-44C8-9538-6EB5F5DEC2BC][Can we solve the problem from end to start?]]  Instead of bursting from the first to the last balloon, we can burst from the last to the first since it is easier to know the last balloon's neighbors.  Time and space complexity is $O(n^2)$.

#+begin_src python
  from typing import List
  from functools import cache


  class Solution:
      def maxCoins(self, nums: List[int]) -> int:
          N = len(nums)

          @cache
          def dfs(i, j):
              if i > j:
                  return 0
              ans = float("-inf")
              for k in range(i, j + 1):
                  ans = max(
                      ans,
                      dfs(i, k - 1)
                      + dfs(k + 1, j)
                      + (nums[i - 1] if i - 1 >= 0 else 1)
                      ,* nums[k]
                      ,* (nums[j + 1] if j + 1 < N else 1),
                  )
              return ans

          return dfs(0, N - 1)


  assert Solution().maxCoins([3, 1, 5, 8]) == 167
  assert Solution().maxCoins([1, 5]) == 10
#+end_src

#+begin_src python
  from typing import List


  class Solution:
      def maxCoins(self, nums: List[int]) -> int:
          N = len(nums)
          dp = [[0] * N for _ in range(N)]
          for i in range(N - 1, -1, -1):
              for j in range(i, N):
                  for k in range(i, j + 1):
                      dp[i][j] = max(
                          dp[i][j],
                          (dp[i][k - 1] if i <= k - 1 else 0)
                          + (dp[k + 1][j] if k + 1 <= j else 0)
                          + nums[k]
                          ,* (nums[i - 1] if i - 1 >= 0 else 1)
                          ,* (nums[j + 1] if j + 1 < N else 1),
                      )
          return dp[0][N - 1]


  assert Solution().maxCoins([3, 1, 5, 8]) == 167
  assert Solution().maxCoins([1, 5]) == 10
#+end_src

* Leetcode: 1187. Make Array Strictly Increasing
:PROPERTIES:
:ID:       4A04DBA9-A534-4E85-9672-F861988B6CEF
:END:
[[https://leetcode.com/problems/make-array-strictly-increasing/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]].

- [[id:EC7DFA39-8E96-4EF7-9297-FAEE2ABF0849][Blackbox: The dependent problem needs to be optimized]].  I have to make the choice for the $i$ item in $O(1)$ or $O(\log n)$ otherwise the solution will exceed the time limit.

- [[id:74F32EE1-D1C9-4EC8-A447-9F87FB5E1D28][Pattern: Find optimal subsequence]].

- [[id:1CFF662A-6F16-43CE-BB07-EA12BA382690][Can we formulate the problem as a classical problem?]]  It reminds [[id:665B7733-6D7E-4A34-8F77-7E64747CE2C9][Longest Increasing Subsequence]], since we have to change the given array to become one be LIS.  For each item $i$, we should take the best of either keeping it as the original value or changing it with one of the backup numbers.  Time complexity is $O(n^2 \log n)$ and space complexity is $O(n^2)$.

#+begin_src python
  from typing import List
  from bisect import bisect_right


  class Solution:
      def makeArrayIncreasing(self, a1: List[int], a2: List[int]) -> int:
          N = len(a1)
          M = len(a2)
          a1.append(float("+inf"))
          a2.sort()

          dp = [[0] * (M + 1) for _ in range(N + 1)]
          for i in range(N - 1, -1, -1):
              for j in range(M, -1, -1):
                  e = 1 if j > 0 else 0
                  a = a1[i] if j == 0 else a2[j - 1]
                  b = (e + dp[i + 1][0]) if a < a1[i + 1] else float("+inf")
                  k = bisect_right(a2, a)
                  if k < len(a2):
                      b = min(b, e + dp[i + 1][k + 1])
                  dp[i][j] = b

          ans = min(dp[0][0], dp[0][1])
          return -1 if ans == float("inf") else ans


  assert Solution().makeArrayIncreasing([1, 5, 3, 6, 7], [1, 3, 2, 4]) == 1
  assert Solution().makeArrayIncreasing([1, 5, 3, 6, 7], [4, 3, 1]) == 2
  assert Solution().makeArrayIncreasing([1, 5, 3, 6, 7], [1, 6, 3, 3]) == -1
#+end_src

* Leetcode: 471. Encode String with Shortest Length
:PROPERTIES:
:ID:       8E327900-16BA-48A8-AB49-29C9C0860CF8
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-08-07 Sun 20:52]--[2022-08-07 Sun 21:57] =>  1:05
:END:
[[https://leetcode.com/problems/encode-string-with-shortest-length/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]].  The problem doesn't mention that we would have to encode nested strings, but I should have supposed so.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Be $s$ a string.  The final solution is either finding a substring of $s$ that can be repeated enough to reconstruct $s$ or the concatenation of $p$ and $q$ where $p+q=s$.  Time complexity is $O(n^3)$ and space complexity is $O(n^2)$.

#+begin_src python
  class Solution:
      def encode(self, s: str) -> str:
          N = len(s)

          @cache
          def dfs(i, j):
              subs = s[i : j + 1]
              best = subs
              for k in range(i, j):
                  npart = k - i + 1
                  ncopy = len(subs) // npart
                  if len(subs) % npart == 0 and s[i : k + 1] * ncopy == subs:
                      cur = f"{ncopy}[{dfs(i, k)}]"
                      if len(cur) < len(best):
                          best = cur
              for k in range(i, j):
                  cur = dfs(i, k) + dfs(k + 1, j)
                  if len(cur) < len(best):
                      best = cur
              return best

          return dfs(0, N - 1)


  assert Solution().encode("aaa") == "aaa"
  assert Solution().encode("aaaaa") == "5[a]"
  assert Solution().encode("aaaaaaaaaa") == "10[a]"
#+end_src

#+begin_src python
  class Solution:
      def encode(self, s: str) -> str:
          N = len(s)

          @cache
          def dfs(i, j):
              if i == j:
                  return s[i]
              if i > j:
                  return ""
              ans = s[i : j + 1]
              p = (ans + ans).find(ans, 1)
              k = len(ans) // p
              if k > 1:
                  x = f"{k}[{dfs(i, i + p-1)}]"
                  if len(x) < len(ans):
                      ans = x
              for k in range(i, j):
                  x = dfs(i, k) + dfs(k + 1, j)
                  if len(x) < len(ans):
                      ans = x
              return ans

          return dfs(0, N - 1)
#+end_src

* Leetcode: 1776. Car Fleet II
:PROPERTIES:
:ID:       8075F351-F99A-4EBD-A7A8-E928DA2F7931
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-07 Sun 22:13]--[2022-08-07 Sun 23:04] =>  0:51
:END:
[[https://leetcode.com/problems/car-fleet-ii/][Problem Statement]]

- [[id:E79DA5C2-ACB6-4611-AD11-090310B72BC1][Mistake: Did not play with small examples draw invariants]].

- [[id:BA632D61-93B6-47AB-B11A-7E9EBE3FC71D][Can we derive an invariant based on the smallest possible examples?]]  If there is only one car, the answer is -1.  Be $a$ and $b$ two cars where $b$ comes after $a$ in the input.  If $b$ is faster than $a$, both will have answer -1.  Otherwise, $a$ will collide with $b$.  Be $c$ other car that come after $b$.  If $a$ is faster than $b$ and $c$, then $a$ will collide with $c$ iff it doesn't collide first with $b$.  Therefore, we can discard all cars that go faster than $a$ or collide with a slower car before it would collide with $a$.  These property can be implemented using a [[id:E4CFDB04-DCFD-47E3-9ED2-0DC6446420B5][Monotonic Stack]].  Time and space complexity is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def getCollisionTimes(self, c: List[List[int]]) -> List[float]:
          def t(a, b):
              return (b[0] - a[0]) / (a[1] - b[1])

          N = len(c)
          ans = [-1] * N
          st = []
          for i in range(N - 1, -1, -1):
              while st and (
                  st[-1][1] >= c[i][1] or 0 < ans[st[-1][2]] <= t(c[i], st[-1])
              ):
                  st.pop()
              if st:
                  ans[i] = t(c[i], st[-1])
              st.append((*c[i], i))
          return ans


  assert Solution().getCollisionTimes([[1, 2], [2, 1], [4, 3], [7, 2]]) == [
      1.00000,
      -1.00000,
      3.00000,
      -1.00000,
  ]
  assert Solution().getCollisionTimes([[3, 4], [5, 4], [6, 3], [9, 1]]) == [
      2.00000,
      1.00000,
      1.50000,
      -1.00000,
  ]
#+end_src

* Leetcode: 425. Word Squares
:PROPERTIES:
:ID:       51F46555-F71F-4968-ACB7-B2A25634423A
:END:
:LOGBOOK:
CLOCK: [2022-08-09 Tue 14:00]--[2022-08-09 Tue 16:33] =>  2:33
CLOCK: [2022-08-09 Tue 12:02]--[2022-08-09 Tue 12:16] =>  0:14
:END:
[[https://leetcode.com/problems/word-squares/][Problem Statement]]

- [[id:DA951820-DBB5-4A7F-9401-DF5860EFAB8A][Mistake: Incorrect evaluation of solution's viability]].  Spent most of the time trying to reduce the complexity, when the problem required a [[id:605B3009-7C7C-410A-9361-218A24ED8D8C][Backtracking]].

- [[id:56B18554-8EDB-44AF-B72A-8FD307B2980C][Mistake: High constant factor in the implementation]].  First [[id:605B3009-7C7C-410A-9361-218A24ED8D8C][Backtracking]] wasn't optimized enough.

- [[id:29512D97-A54D-42F9-A8C7-C3422881933B][Can we use brute-force to solve the problem?]]  Generate all possible squares while selecting the next word that match the current prefix so far.

#+begin_src python
  from typing import List


  class Solution:
      def wordSquares(self, words: List[str]) -> List[List[str]]:
          N = len(words)
          M = len(words[0])

          if M == 1:
              return list(set(words))

          pref = {}
          for w in words:
              for i in range(M):
                  p = w[0 : i + 1]
                  pref.setdefault(p, set())
                  pref[p].add(w)

          ans = []

          def bt(i, cur):
              if i == M:
                  ans.append(cur[:])
                  return

              for w in pref.get("".join(v[i] for v in cur), []):
                  cur.append(w)
                  bt(i + 1, cur)
                  cur.pop()

          for w in words:
              bt(1, [w])

          return ans


  assert Solution().wordSquares(["area", "lead", "wall", "lady", "ball"]) == [
      ["ball", "area", "lead", "lady"],
      ["wall", "area", "lead", "lady"],
  ]
  assert Solution().wordSquares(["abat", "baba", "atan", "atal"]) == [
      ["baba", "abat", "baba", "atal"],
      ["baba", "abat", "baba", "atan"],
  ]
#+end_src

* Leetcode: 315. Count of Smaller Numbers After Self
:PROPERTIES:
:ID:       70A5C00E-0D5E-47DA-AB0C-68766DFED02F
:END:
:LOGBOOK:
CLOCK: [2022-08-09 Tue 16:48]--[2022-08-09 Tue 17:01] =>  0:13
:END:
[[https://leetcode.com/problems/count-of-smaller-numbers-after-self/][Problem Statement]]

- [[id:A18543C4-83BC-40F1-A243-B85FD935FAC0][Pattern: Answer query on sorted data]].

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Suppose we are processing the element $i$ from right to left, if we keep element $nums[i+1,...,n-1]$ sorted, the problem becomes finding the right-most index where we could add $nums[i]$ to the sorted list while keeping it sorted.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  from typing import List
  from sortedcontainers import SortedList


  class Solution:
      def countSmaller(self, nums: List[int]) -> List[int]:
          right = SortedList([])
          N = len(nums)
          ans = [0] * N
          for i in range(N - 1, -1, -1):
              j = right.bisect_left(nums[i])
              ans[i] = j
              right.add(nums[i])
          return ans


  assert Solution().countSmaller([5, 2, 6, 1]) == [2, 1, 1, 0]
  assert Solution().countSmaller([-1]) == [0]
  assert Solution().countSmaller([-1, -1]) == [0, 0]
#+end_src

* Leetcode: 407. Trapping Rain Water II
:PROPERTIES:
:ID:       8F9C5F1E-C36B-4EC1-97B5-7E1172BF89B6
:END:
[[https://leetcode.com/problems/trapping-rain-water-ii/][Problem Statement]]

- [[id:CCCF9587-5365-4BB0-B0D3-8FC82D55E781][Mistake: Failed to recognize known problem]]: [[id:8BACB101-3C8B-47CA-9AB1-89D52F85F6DA][Shortest Path in a Graph Problem]].

- [[id:E79DA5C2-ACB6-4611-AD11-090310B72BC1][Mistake: Did not play with small examples draw invariants]].

- [[id:48E699CB-3125-47FF-AA1A-5FCCF0EF235E][Can we simulate the problem?]]  We can simulate the water raising from the border to the center of the grid.  Every time that water gets to a cell (from the lowest height to the highest height), it will trap water in neighbors that weren't visited and have smaller heights.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def trapRainWater(self, h: List[List[int]]) -> int:
          N = len(h)
          M = len(h[0])
          D = [[+1, +0], [-1, +0], [+0, +1], [+0, -1]]

          vis = [[False] * M for _ in range(N)]
          pq = []
          for i in range(N):
              heappush(pq, (h[i][0], i, 0))
              heappush(pq, (h[i][M - 1], i, M - 1))
              vis[i][0] = vis[i][M - 1] = True
          for j in range(M):
              heappush(pq, (h[0][j], 0, j))
              heappush(pq, (h[N - 1][j], N - 1, j))
              vis[0][j] = vis[N - 1][j] = True

          ans = 0
          while pq:
              cur, i, j = heappop(pq)
              for di, dj in D:
                  ni = i + di
                  nj = j + dj
                  if 0 <= ni < N and 0 <= nj < M and not vis[ni][nj]:
                      vis[ni][nj] = True
                      diff = max(cur - h[ni][nj], 0)
                      ans += diff
                      heappush(pq, (max(h[ni][nj], cur), ni, nj))
          return ans


  assert (
      Solution().trapRainWater(
          [[1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1]]
      )
      == 4
  )
  assert (
      Solution().trapRainWater(
          [
              [3, 3, 3, 3, 3],
              [3, 2, 2, 2, 3],
              [3, 2, 1, 2, 3],
              [3, 2, 2, 2, 3],
              [3, 3, 3, 3, 3],
          ]
      )
      == 10
  )
#+end_src

* Leetcode: 1579. Remove Max Number of Edges to Keep Graph Fully Traversable
:PROPERTIES:
:ID:       F300E2E8-34BD-4DBD-B2BC-57BC132CA2F0
:END::LOGBOOK:
CLOCK: [2022-08-10 Wed 07:46]--[2022-08-10 Wed 07:50] =>  0:04
:END:
[[https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/][Problem Statement]]

- [[id:EEDBE877-7C4A-4D0B-BA6B-EFDF9288B78C][Blackbox: This is a variation of a classic problem]] to find [[id:367C887D-3517-4AC8-8219-293AC0E77E07][Connected Components in a Graph]].

- [[id:BA632D61-93B6-47AB-B11A-7E9EBE3FC71D][Can we derive an invariant based on the smallest possible examples?]]  Be $G$ a graph and $T$ a tree of $G$.  Be $u$ and $v$ in $T$ where they need two edges of type 1 and 2.  If it is possible to swap these edges with one of type 3, then $|E(G)|-|E(T)|$ is not the solution since we can do better.  Therefore, we can first add all edges of type 3 and then handle the ones with type 1 and type 2.  Time and space complexity are $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:
          p = {}

          def find(u):
              if u not in p:
                  p[u] = u
              if p[u] != u:
                  p[u] = find(p[u])
              return p[u]

          def union(u, v):
              p[find(u)] = find(v)

          added = 0
          for t, u, v in sorted(edges, key=lambda e: e[0], reverse=True):
              if t == 3:
                  if find(u) != find(v):
                      union(u, v)
                      union(~u, ~v)
                      added += 1
              elif t == 2:
                  if find(~u) != find(~v):
                      union(~u, ~v)
                      added += 1
              else:
                  if find(u) != find(v):
                      union(u, v)
                      added += 1

          valid = (
              len({find(u) for u in range(1, n + 1)})
              == len({find(~u) for u in range(1, n + 1)})
              == 1
          )
          return -1 if not valid else len(edges) - added


  assert (
      Solution().maxNumEdgesToRemove(
          4, [[3, 1, 2], [3, 2, 3], [1, 1, 3], [1, 2, 4], [1, 1, 2], [2, 3, 4]]
      )
      == 2
  )
  assert (
      Solution().maxNumEdgesToRemove(4, [[3, 1, 2], [3, 2, 3], [1, 1, 4], [2, 1, 4]]) == 0
  )
  assert Solution().maxNumEdgesToRemove(4, [[3, 2, 3], [1, 1, 2], [2, 3, 4]]) == -1
#+end_src

* Leetcode: 753. Cracking the Safe
:PROPERTIES:
:ID:       3C17BB0E-EE14-4666-9A49-EB536ECCAE79
:END:
:LOGBOOK:
CLOCK: [2022-08-10 Wed 10:57]--[2022-08-10 Wed 11:07] =>  0:10
:END:
[[https://leetcode.com/problems/cracking-the-safe/][Problem Statement]]

- [[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  Find the smallest string which contains all possible string with $n$ digits where each digit is between $0$ and $k-1$.  I don't know how to prove (even though I saw a relationship with [[id:BE52E57C-4A9B-4F62-9F8F-EBD0447ABBB9][Eulerian path in Directed Graph]]), it is always possible to create such string where each new digit covers a new possible string.  Therefore, we can try all possibilities with a basic prune (i.e. stop if the current answer is greater than the best one so far).  Time complexity is $O(X \times k)$ where $X$ is the size of the final string.  Space complexity is $O(X)$.

#+begin_src python
  class Solution:
      def crackSafe(self, n: int, k: int) -> str:
          M = k**n
          ans = None

          def bt(cur, words):
              nonlocal ans
              if len(words) == M:
                  ans = cur
                  return
              if ans is not None:
                  return
              for d in range(k):
                  new = cur + str(d)
                  word = new[-n:]
                  if word not in words:
                      if len(word) == n:
                          words.add(word)
                      bt(new, words)
                      if len(word) == n:
                          words.discard(word)

          bt("", set())
          return ans


  assert Solution().crackSafe(1, 2) == "10"
  assert Solution().crackSafe(2, 2) == "01100"
#+end_src

- A solution with [[id:BE52E57C-4A9B-4F62-9F8F-EBD0447ABBB9][Eulerian path in Directed Graph]] is possible using [[https://en.wikipedia.org/wiki/De_Bruijn_sequence#Example_using_de_Bruijn_graph][Bruijin graph]], where vertices are prefix of size $n-1$ and edges are label with $k$ digits to form the next word.  Time and space complexity are $O(k^n)$.

#+begin_src python
  class Solution:
      def crackSafe(self, n: int, k: int) -> str:
          st = ["0" * n]
          seen = set(st)

          def adj(u):
              for i in range(k):
                  v = (u + str(i))[-n:]
                  if v not in seen:
                      return v
              return None

          words = []
          while st:
              u = adj(st[-1])
              if u is None:
                  words.append(st.pop())
                  continue
              seen.add(u)
              st.append(u)
          words.reverse()

          res = words[0]
          for w in words[1:]:
              res += w[-1]
          return res


  assert Solution().crackSafe(1, 2) == "10"
  assert Solution().crackSafe(2, 2) == "01100"
#+end_src

* Leetcode: 1074. Number of Submatrices That Sum to Target
:PROPERTIES:
:ID:       9AFB1A71-6DE7-40CB-94DB-701ED409AAA1
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-10 Wed 19:29]--[2022-08-10 Wed 22:39] =>  3:10
:END:
[[https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/][Problem Statement]]

- [[id:AC9291C6-4C72-4143-80F2-0D414EF7B681][Mistake: Did not try hard to solve alternative problem]].  I saw the transformation but couldn't see the linear solution for it.

- [[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  Given an array of numbers and a target $t$, find the number of subarrays which sum is equal to $t$.  Be $p[i]=\sum_{0 \leq j \leq i}a[j]$.  The number of valid subarrays ending on $i$ is the number of times that $p[i]-target$ appeared in $p[0..(i-1)]$ plus 1 if $p[i]=t$.  We can transform the 2D problem in the 1D by keeping an accumulated sum for each column and creating the array of numbers after fixing two rows $i0$ and $i0$.  Time complexity is $O(n^2 \times m)$ and space complexity is $O(n \times m)$.

#+begin_src python
  from typing import List
  from collections import defaultdict


  class Solution:
      def numSubmatrixSumTarget(self, m: List[List[int]], target: int) -> int:
          N = len(m)
          M = len(m[0])

          csum = [[0] * M for _ in range(N)]
          for i in range(N):
              for j in range(M):
                  csum[i][j] = m[i][j]
                  if i > 0:
                      csum[i][j] += csum[i - 1][j]
          ans = 0
          for i0 in range(N):
              for i1 in range(i0, N):
                  freq = defaultdict(int)
                  cur = 0
                  for j in range(M):
                      cur += csum[i1][j]
                      if i0 > 0:
                          cur -= csum[i0 - 1][j]
                      ans += freq[cur - target]
                      if cur == target:
                          ans += 1
                      freq[cur] += 1
          return ans


  assert Solution().numSubmatrixSumTarget([[0, 1, 0], [1, 1, 1], [0, 1, 0]], 0) == 4
  assert Solution().numSubmatrixSumTarget([[1, -1], [-1, 1]], 0) == 5
  assert Solution().numSubmatrixSumTarget([[904]], 0) == 0
#+end_src

* Leetcode: 428. Serialize and Deserialize N-ary Tree
:PROPERTIES:
:ID:       E2065B7A-514B-4882-91E0-D3A9CB58A042
:END:
:LOGBOOK:
CLOCK: [2022-08-10 Wed 22:57]--[2022-08-10 Wed 23:11] =>  0:14
:END:
[[https://leetcode.com/problems/serialize-and-deserialize-n-ary-tree/][Problem Statement]]

#+begin_src python
  """
  # Definition for a Node.
  class Node(object):
      def __init__(self, val=None, children=None):
          self.val = val
          self.children = children
  """

  class Codec:
      def serialize(self, root: 'Node') -> str:
          """Encodes a tree to a single string.

          :type root: Node
          :rtype: str
          """
          if not root:
              return ""
          ans = []
          def dfs(u):
              ans.append(str(u.val))
              for v in u.children:
                  dfs(v)
              ans.append("null")

          dfs(root)
          return ",".join(ans)


      def deserialize(self, data: str) -> 'Node':
          """Decodes your encoded data to tree.

          :type data: str
          :rtype: Node
          """
          if not data:
              return None
          values = data.split(",")
          root = Node(int(values[0]), [])
          st = [root]
          for val in values[1:]:
              if val == "null":
                  st.pop()
              else:
                  node = Node(val=int(val), children=[])
                  st[-1].children.append(node)
                  st.append(node)
          return root

  # Your Codec object will be instantiated and called as such:
  # codec = Codec()
  # codec.deserialize(codec.serialize(root))
#+end_src

* Leetcode: 296. Best Meeting Point
:PROPERTIES:
:ID:       0FD2439E-D7C2-4BF6-B8FA-E15E4B3F182D
:END:
:LOGBOOK:
CLOCK: [2022-08-10 Wed 23:13]--[2022-08-10 Wed 23:40] =>  0:27
:END:
[[https://leetcode.com/problems/best-meeting-point/][Problem Statement]]

- [[id:AF523FD7-71A3-44F0-B9F2-E288B8A6EB6D][Mistake: Wrong time complexity]].  First solution was $O(n^4)$.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  The total sum can be split on the total distance by axis.  Therefore, the problem is returning the sum of these independent sums.  Time complexity is $O(\max(n \times m, n^2, m^2))$ and space complexity is $O(n + m)$.

#+begin_src python
  from typing import List


  class Solution:
      def minTotalDistance(self, g: List[List[int]]) -> int:
          N = len(g)
          M = len(g[0])
          cfreq = [0] * M
          rfreq = [0] * N
          for i in range(N):
              for j in range(M):
                  cfreq[j] += g[i][j]
                  rfreq[i] += g[i][j]

          x = float("inf")
          for j in range(M):
              cur = 0
              for k in range(M):
                  if j != k:
                      cur += cfreq[k] * abs(k - j)
              x = min(x, cur)

          y = float("inf")
          for i in range(N):
              cur = 0
              for k in range(N):
                  if i != k:
                      cur += rfreq[k] * abs(k - i)
              y = min(y, cur)

          return x + y


  assert (
      Solution().minTotalDistance([[1, 0, 0, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]])
      == 6
  )
  assert Solution().minTotalDistance([[1, 1]]) == 1
#+end_src

* Leetcode: 727. Minimum Window Subsequence
:PROPERTIES:
:ID:       06326BD7-1C77-4A32-A715-D1D17E60FE81
:WA:       6
:END:
:LOGBOOK:
CLOCK: [2022-08-11 Thu 11:06]--[2022-08-11 Thu 12:34] =>  1:28
:END:
[[https://leetcode.com/problems/minimum-window-subsequence/][Problem Statement]]

- [[id:56B18554-8EDB-44AF-B72A-8FD307B2980C][Mistake: High constant factor in the implementation]].

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  Find the smallest index $f(i,j)=k$ where $s[i:k]$ has $t[j:]$ as subsequence.  The problem becomes getting the minimum between $f(i,0)$.  Time complexity is $O(n \times m)$ and space is $O(m)$.

#+begin_src python
  class Solution:
      def minWindow(self, s1: str, s2: str) -> str:
          N = len(s1)
          M = len(s2)

          cur = [float("inf")] * (M + 1)
          cur[M] = N
          ans = None
          for i in range(N - 1, -1, -1):
              new = [float("inf")] * (M + 1)
              new[M] = i
              for j in range(M):
                  if s1[i] == s2[j]:
                      new[j] = cur[j + 1]
                  else:
                      new[j] = cur[j]

              j = new[0]
              if j <= N and (ans is None or (j - i) <= len(ans)):
                  ans = s1[i:j]
              cur = new

          return "" if ans is None else ans


  assert Solution().minWindow("abcdebdde", "bde") == "bcde"
  assert Solution().minWindow("jmeqksfrsdcmsiwvaovztaqenprpvnbstl", "u") == ""
#+end_src

* Leetcode: 465. Optimal Account Balancing
:PROPERTIES:
:ID:       80D28898-4768-4227-96C0-6E6092D8ED65
:END:
:LOGBOOK:
CLOCK: [2022-08-12 Fri 19:25]--[2022-08-12 Fri 20:14] =>  0:49
:END:
[[https://leetcode.com/problems/optimal-account-balancing/][Problem Statement]]

- [[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  Create an array $b$ that represents the balance after all transactions.  We have that $sum(b)$ is 0 and represents how much each one needs to receive or send.  The problem becomes find the minimum number of transactions to make all balances equal to zero.  Time complexity is $O(n \times 2^n)$ since each there are $2^n$ possible open balances and you need to process $n$ possible ways to send/receive money.

#+begin_src python
  from typing import List


  class Solution:
      def minTransfers(self, transactions: List[List[int]]) -> int:
          ans = len(transactions)

          def dfs(i):
              if i == 12:
                  return 0
              if net[i] == 0:
                  return dfs(i + 1)
              ans = 8
              for j in range(i + 1, 12):
                  if (
                      net[j] == 0
                      or (net[i] < 0 and net[j] < 0)
                      or (net[i] > 0 and net[j] > 0)
                  ):
                      continue
                  tmp = net[j]
                  net[i] += tmp
                  net[j] = 0
                  ans = min(ans, 1 + dfs(i))
                  net[i] -= tmp
                  net[j] = tmp
              return ans

          net = [0] * 12
          for f, t, a in transactions:
              net[f] -= a
              net[t] += a

          return dfs(0)


  assert Solution().minTransfers([[0, 1, 10], [2, 0, 5]]) == 2
  assert Solution().minTransfers([[0, 1, 10], [1, 0, 1], [1, 2, 5], [2, 0, 5]]) == 1
#+end_src

* Leetcode: 458. Poor Pigs
:PROPERTIES:
:ID:       7FA3FBD2-F93A-4651-B361-47755C5563EA
:END:
:LOGBOOK:
CLOCK: [2022-08-13 Sat 18:36]--[2022-08-13 Sat 18:59] =>  0:23
CLOCK: [2022-08-13 Sat 14:55]--[2022-08-13 Sat 18:33] =>  3:38
CLOCK: [2022-08-13 Sat 13:32]--[2022-08-13 Sat 13:54] =>  0:22
CLOCK: [2022-08-13 Sat 11:06]--[2022-08-13 Sat 11:25] =>  0:19
:END:
[[https://leetcode.com/problems/poor-pigs/][Problem Statement]]

- [[id:3C649CC4-0609-4686-96C3-5F774F9C0292][Mistake: Failed to consider different strategies to solve the problem]].  I was stuck on trying to compute the minimum number of tries given a number of pigs and buckets.

- [[id:3C649CC4-0609-4686-96C3-5F774F9C0292][Mistake: Failed to consider different strategies to solve the problem]].  I saw that two pigs with one could cover at most $2^x$ buckets, but failed to see how to extend this the second, third and so on tries.

- [[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  Given that $x$ pigs and one try, we know that they can find the solution for at most $2^x$ buckets.  This is so because each bucket has an unique id in the base 2.  To represent the next try, we have to increase the base.  So, all buckets will have an unique id which means that an unique combination of pigs die maps to only one bucket.  Time complexity is $O(\log_b n)$ where $n$ is the number of buckets and $b$ is the number of tries.  Space complexity is $O(1)$.

#+begin_src python
  from math import comb


  class Solution:
      def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:
          digits = ceil(minutesToTest / minutesToDie + 1)
          cur = 1
          ans = 0
          while cur < buckets:
              cur *= digits
              ans += 1
          return ans


  assert Solution().poorPigs(1000, 15, 60) == 5
  assert Solution().poorPigs(4, 15, 15) == 2
  assert Solution().poorPigs(4, 15, 30) == 2
#+end_src

* Leetcode: 847. Shortest Path Visiting All Nodes
:PROPERTIES:
:ID:       FF845917-853D-465D-B8F8-5E78CB70AD88
:END:
:LOGBOOK:
CLOCK: [2022-08-14 Sun 13:02]--[2022-08-14 Sun 13:21] =>  0:19
CLOCK: [2022-08-14 Sun 11:48]--[2022-08-14 Sun 12:00] =>  0:12
:END:
[[https://leetcode.com/problems/shortest-path-visiting-all-nodes/][Problem Statement]]

#+begin_src python
  from typing import List


  class Solution:
      def shortestPathLength(self, graph: List[List[int]]) -> int:
          N = len(graph)
          ALL_VISITED = (1 << N) - 1

          seen = set()
          queue = [(i, (1 << i), 0) for i in range(N)]
          for u, vis, steps in queue:
              if vis == ALL_VISITED:
                  return steps
              for v in graph[u]:
                  nvis = vis | (1 << v)
                  if (v, nvis) not in seen:
                      seen.add((v, nvis))
                      queue.append((v, nvis, steps + 1))


  assert Solution().shortestPathLength([[1, 2, 3], [0], [0], [0]]) == 4
  assert Solution().shortestPathLength([[1], [0, 2, 4], [1, 3, 4], [2], [1, 2]]) == 4
#+end_src

* Leetcode: 772. Basic Calculator III
:PROPERTIES:
:ID:       A4D972B6-FC4A-4486-8EE3-3E422605F596
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-08-14 Sun 14:02]--[2022-08-14 Sun 14:38] =>  0:36
CLOCK: [2022-08-14 Sun 13:21]--[2022-08-14 Sun 13:29] =>  0:08
:END:
[[https://leetcode.com/problems/basic-calculator-iii/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  ~a // b~ is different than ~int(a/b)~ in Python.

- [[id:1CFF662A-6F16-43CE-BB07-EA12BA382690][Can we formulate the problem as a classical problem?]]  Eval expression with binary operators.

#+begin_src python
  class Solution:
      def calculate(self, s: str) -> int:
          s = s + "+0"
          N = len(s)

          po = {")": 0, "+": 1, "-": 1, "*": 2, "/": 2}
          st = []
          op = []
          i = 0
          while i < N:
              if "0" <= s[i] <= "9":
                  start = i
                  while i < N and "0" <= s[i] <= "9":
                      i += 1
                  st.append(int(s[start:i]))
              elif s[i] == "(":
                  op.append(s[i])
                  i += 1
              else:
                  while op and len(st) > 1 and op[-1] != "(" and po[op[-1]] >= po[s[i]]:
                      b = st.pop()
                      a = st.pop()
                      o = op.pop()
                      if o == "+":
                          st.append(a + b)
                      elif o == "-":
                          st.append(a - b)
                      elif o == "*":
                          st.append(a * b)
                      elif o == "/":
                          st.append(int(a / b))
                  if s[i] == ")":
                      op.pop()
                  else:
                      op.append(s[i])
                  i += 1

          return st[0]


  assert Solution().calculate("1+1") == 2
  assert Solution().calculate("6-4/2") == 4
  assert Solution().calculate("2*(5+5*2)/3+(6/2+8)") == 21
#+end_src

* Leetcode: 629. K Inverse Pairs Array
:PROPERTIES:
:ID:       1CAD0404-0C2A-435E-BE39-87902638CEA0
:ORDERED:  t
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-15 Mon 10:10]--[2022-08-15 Mon 10:59] =>  0:49
CLOCK: [2022-08-14 Sun 19:10]--[2022-08-14 Sun 20:34] =>  1:24
CLOCK: [2022-08-14 Sun 16:53]--[2022-08-14 Sun 17:14] =>  0:21
:END:
[[https://leetcode.com/problems/k-inverse-pairs-array/][Problem Statement]]

- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]] where the solution was to construct the solution from the last move to the first one ([[id:12BA5684-2AD8-4891-A53B-7E4C08A73882][Leetcode: 312. Burst Balloons]]).

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  Be $a$ an empty array where we will fill with permutation of $0..(n-1)$.  Pick a position $i$ to put the number 1.  How many inversions will it create?  The answer is $i$, since all $i$ numbers on $0..(i-1)$ are greater than $a[i]$.  After doing the same with 2, we can notice that the position of 1 doesn't affect if we consider that it was excluded from the array.  In other words, we try to put 2 in an empty array with $n-1$ positions.  The following solution implements this strategy that we can compute part of it using a suffix sum.  Time complexity is $O(n \times k)$ and space complexity is $O(k)$.

#+begin_src python
  class Solution:
      def kInversePairs(self, N: int, K: int) -> int:
          MOD = 10**9 + 7

          right = [0] * (K + 1)
          right[0] = 1
          for n in range(2, N + 1):
              cur = [0] * (K + 1)
              for k in range(K, -1, -1):
                  cur[k] = right[k - min(n, k + 1) + 1] - (
                      right[k + 1] if k + 1 <= K else 0
                  )
                  if k < K:
                      cur[k] = cur[k] + cur[k + 1]
                  cur[k] = cur[k] % MOD
              right = cur

          return right[K]


  assert Solution().kInversePairs(3, 0) == 1
  assert Solution().kInversePairs(3, 1) == 2
#+end_src

* Leetcode: 410. Split Array Largest Sum
:PROPERTIES:
:ID:       DCE97282-1089-4514-9A97-A8E6E049446D
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-15 Mon 16:47]--[2022-08-15 Mon 17:44] =>  0:57
:END:
[[https://leetcode.com/problems/split-array-largest-sum/][Problem Statement]]

- [[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  Given a candidate answer, check if it is possible to partition the array in at most $m$ parts.  If so, the candidate is valid, otherwise you have to increase it.  The optimal answer can be found using a [[id:1217FC3D-A9F9-49EC-BA5D-A68E50338DBD][Binary-search]].  Time complexity is $O(n \log \sum a[i])$ and space is $O(1)$.

#+begin_src python
  class Solution:
      def splitArray(self, nums: List[int], M: int) -> int:
          N = len(nums)
          s = max(nums)
          e = sum(nums)

          def valid(m):
              cnt = i = cur = 0
              while i < N:
                  if cur + nums[i] <= m:
                      cur += nums[i]
                  else:
                      cur = nums[i]
                      cnt += 1
                  i += 1
              return cnt < M

          while s < e:
              m = s + (e - s) // 2
              if valid(m):
                  e = m
              else:
                  s = m + 1
          return s
#+end_src

* Leetcode: 2127. Maximum Employees to Be Invited to a Meeting
:PROPERTIES:
:ID:       A8FC07FD-26E9-4FAA-830B-E64720170D17
:WA:       7
:END:
:LOGBOOK:
CLOCK: [2022-08-15 Mon 21:51]--[2022-08-15 Mon 23:03] =>  1:12
CLOCK: [2022-08-15 Mon 18:01]--[2022-08-15 Mon 18:28] =>  0:27
:END:
[[https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  Failed to recognize that the solution is either a cycle of a sum of paths.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Clearly, one possible solution is to find the [[id:0E6E671A-F49C-4962-ABE0-7F5AAD6ACC05][Longest Cycle in a Directed Graph]].  Otherwise, we can seat groups of people that where their favorite chain ends on two people that would like to seat besides each other.  Time complexity is $O(n)$ and space is $O(n)$.

#+begin_src python
  from typing import List
  from collections import defaultdict


  class Solution:
      def maximumInvitations(self, e: List[int]) -> int:
          N = len(e)

          re = defaultdict(list)
          for u, v in enumerate(e):
              if e[v] != u:
                  re[v].append(u)

          def find_longest_path(u, seen):
              if longest_path[u] is not None:
                  return longest_path[u]
              seen.add(u)
              ans = 1
              for v in re[u]:
                  ans = max(ans, 1 + find_longest_path(v, seen))
              longest_path[u] = ans
              return ans

          longest_path = [None] * N
          ans = 0
          seen = set()
          for u, v in enumerate(e):
              if e[v] == u and u < v:
                  ans += find_longest_path(u, seen) + find_longest_path(v, seen)

          found_at = [None] * N

          def find_longest_cycle(u, k, seen):
              seen.add(u)
              found_at[u] = k
              v = e[u]
              if v in seen:
                  ans = ((k + 1) - found_at[v]) if found_at[v] is not None else 0
              else:
                  ans = find_longest_cycle(v, k + 1, seen)
              found_at[u] = None
              return ans

          seen = set()
          for u in range(N):
              if u not in seen:
                  ans = max(ans, find_longest_cycle(u, 0, seen))
          return ans


  assert Solution().maximumInvitations([2, 2, 1, 2]) == 3
  assert Solution().maximumInvitations([1, 2, 0]) == 3
  assert Solution().maximumInvitations([3, 0, 1, 4, 1]) == 4
#+end_src

* Leetcode: 2276. Count Integers in Intervals
:PROPERTIES:
:ID:       D45A803A-CFE4-4F03-9597-C8D879A2808F
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-16 Tue 09:38]--[2022-08-16 Tue 10:39] =>  1:01
:END:
[[https://leetcode.com/problems/count-integers-in-intervals/][Problem Statement]]

- [[id:1CFF662A-6F16-43CE-BB07-EA12BA382690][Can we formulate the problem as a classical problem?]]  We can model as adding and counting intervals of 1 in a [[id:8564CEB1-3E95-4A34-B888-0BCE6D6504B8][Lazy Segment Tree]].  The trick to pass the time constraint is to also implement lazy propagation (i.e. only create the children when necessary).

#+begin_src python
  class SegTree:
      def __init__(self, start, end):
          self.start = start
          self.end = end
          self.left = None
          self.right = None
          self.value = 0
          self.pending = None

      def update(self, start, end, force=False):
          if self.start > end or self.end < start:
              return
          if self.value == self.end - self.start + 1:
              return
          if start <= self.start and self.end <= end:
              self.left = None
              self.right = None
              self.value = self.end - self.start + 1
              return
          if not force and self.pending is None and self.value == 0:
              self.pending = (start, end)
              self.value = min(self.end, end) - max(self.start, start) + 1
              return
          self._extend()
          self.left.update(start, end)
          self.right.update(start, end)
          self.value = self.left.value + self.right.value

      def _extend(self):
          if self.pending:
              start, end = self.pending
              self.pending = None
              self.value = 0
              self.update(start, end, True)
          if self.left is None:
              m = self.start + (self.end - self.start) // 2
              self.left = SegTree(self.start, m)
              self.right = SegTree(m + 1, self.end)

      def print(self, level=0):
          print(" " * level, (self.start, self.end), self.value, self.pending)
          if self.left:
              self.left.print(level + 1)
              self.right.print(level + 1)

  class CountIntervals:

      def __init__(self):
          self.st = SegTree(0, 10**9)

      def add(self, left: int, right: int) -> None:
          self.st.update(left, right)

      def count(self) -> int:
          return self.st.value
#+end_src

- We can use a sorted interval list to solve the problem in $O(n \log n)$ where $n$ is the number of queries.

#+begin_src python
  class CountIntervals:
      def __init__(self):
          self.segs = []
          self.value = 0

      def add(self, left: int, right: int) -> None:
          i = bisect_left(self.segs, left, key=lambda e: e[0])
          j = i = i - (1 if i > 0 and self.segs[i - 1][1] >= left else 0)
          while j < len(self.segs) and self.segs[j][0] <= right:
              self.value -= self.segs[j][1] - self.segs[j][0] + 1
              left = min(left, self.segs[j][0])
              right = max(right, self.segs[j][1])
              j += 1
          self.value += right - left + 1
          self.segs[i:j] = [(left, right)]

      def count(self) -> int:
          return self.value
#+end_src

* Leetcode: 403. Frog Jump
:PROPERTIES:
:ID:       D30D5EAC-2501-47F1-BDF2-A3BA98951FA2
:ORDERED:  t
:WA:       1
:END:
:LOGBOOK:
CLOCK: [2022-08-16 Tue 21:20]--[2022-08-16 Tue 21:59] =>  0:39
CLOCK: [2022-08-16 Tue 17:31]--[2022-08-16 Tue 17:41] =>  0:10
:END:
[[https://leetcode.com/problems/frog-jump/][Problem Statement]]

- [[id:192401C2-DA6F-4496-B530-89A3546712FD][Mistake: Misread the problem]] and tried to solve using a wrong DP approach.

- [[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Stones are vertices and two stones are connected if the frog can jump between them.  The problem becomes search a path from the start position to the end using a [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]].  Time and space complexity are $O(n^2)$.

#+begin_src python
  from typing import List


  class Solution:
      def canCross(self, stones: List[int]) -> bool:
          N = len(stones)
          S = {stones[i]: i for i in range(N)}
          seen = set()
          queue = [(0, 1)]
          for i, k in queue:
              if i == N - 1:
                  return True
              for d in [-1, 0, +1] if i > 0 else [0]:
                  v = stones[i] + k + d
                  if v not in S:
                      continue
                  j = S[v]
                  if (j, k + d) not in seen:
                      seen.add((j, k + d))
                      queue.append((j, k + d))
          return False
#+end_src

* Leetcode: 2366. Minimum Replacements to Sort the Array
:PROPERTIES:
:ID:       40231B7B-1556-4748-BAE5-7717D708A22B
:END:
:LOGBOOK:
CLOCK: [2022-08-17 Wed 13:45]--[2022-08-17 Wed 14:30] =>  0:45
CLOCK: [2022-08-17 Wed 11:19]--[2022-08-17 Wed 11:44] =>  0:25
CLOCK: [2022-08-17 Wed 10:12]--[2022-08-17 Wed 10:39] =>  0:27
CLOCK: [2022-08-17 Wed 10:01]--[2022-08-17 Wed 10:03] =>  0:02
:END:
[[https://leetcode.com/problems/minimum-replacements-to-sort-the-array/][Problem Statement]]

- [[id:AC9291C6-4C72-4143-80F2-0D414EF7B681][Mistake: Did not try hard to solve alternative problem]].  I should have spent more times thinking on ways to find a close formula.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  We will never split the last number of the array.  For the other numbers, we want to split them close as possible to the current bound.  Time complexity is $O(n)$ and space is $O(1)$.

#+begin_src python
  from typing import List


  class Solution:
      def minimumReplacement(self, nums: List[int]) -> int:
          N = len(nums)
          ans = 0
          cur = nums[-1]

          for i in range(N - 2, -1, -1):
              if nums[i] <= cur:
                  cur = nums[i]
              elif cur == 1:
                  ans += nums[i] - 1
              else:
                  j = (nums[i] + cur - 1) // cur
                  ans += j - 1
                  cur = nums[i] // j
          return ans


  assert Solution().minimumReplacement([3, 9, 3]) == 2
  assert Solution().minimumReplacement([1, 2, 3, 4, 5]) == 0
#+end_src

* Leetcode: 980. Unique Paths III
:PROPERTIES:
:ID:       156CC856-397B-45C2-B267-9BA94B7FBE11
:WA:       0
:END:
:LOGBOOK:
CLOCK: [2022-08-17 Wed 16:04]--[2022-08-17 Wed 16:16] =>  0:12
:END:
[[https://leetcode.com/problems/unique-paths-iii/][Problem Statement]]

- [[id:29512D97-A54D-42F9-A8C7-C3422881933B][Can we use brute-force to solve the problem?]]  We can't but it is possible memorize all possible states of current position and all visited ones.  Time complexity is $O(2^k \times k)$ where $k$ is $n \times m \leq 20$.

#+begin_src python
  from typing import List


  class Solution:
      def uniquePathsIII(self, g: List[List[int]]) -> int:
          N = len(g)
          M = len(g[0])
          D = [[+1, +0], [-1, +0], [+0, +1], [+0, -1]]
          ALL = 0

          def b(i, j):
              return 1 << (i * M + j)

          for i in range(N):
              for j in range(M):
                  if g[i][j] == 1:
                      si = i
                      sj = j
                  if g[i][j] == 2:
                      ei = i
                      ej = j
                  if g[i][j] != -1:
                      ALL = ALL | b(i, j)

          def dfs(i, j, vis):
              if i == ei and j == ej:
                  return 1 if vis == ALL else 0
              ans = 0
              for di, dj in D:
                  ni = di + i
                  nj = dj + j
                  if (
                      0 <= ni < N
                      and 0 <= nj < M
                      and g[ni][nj] != -1
                      and vis & b(ni, nj) == 0
                  ):
                      ans += dfs(ni, nj, vis | b(ni, nj))
              return ans

          return dfs(si, sj, b(si, sj))


  assert Solution().uniquePathsIII([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 2, -1]]) == 2
  assert Solution().uniquePathsIII([[1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 2]]) == 4
  assert Solution().uniquePathsIII([[0, 1], [2, 0]]) == 0
#+end_src

* Leetcode: 1255. Maximum Score Words Formed by Letters
:PROPERTIES:
:ID:       F23B931A-C19B-41AD-B281-1D57457ABE4C
:END:
:LOGBOOK:
CLOCK: [2022-08-21 Sun 21:30]--[2022-08-21 Sun 21:40] =>  0:10
:END:
[[https://leetcode.com/problems/maximum-score-words-formed-by-letters/][Problem Statement]]

- [[id:29512D97-A54D-42F9-A8C7-C3422881933B][Can we use brute-force to solve the problem?]]  Generate all sets and take the one with maximum score.  Time complexity is $O(2^n \times n)$ and space complexity is $O(n)$.

#+begin_src python
  from typing import List
  from collections import Counter


  class Solution:
      def maxScoreWords(
          self, words: List[str], letters: List[str], score: List[int]
      ) -> int:
          N = len(words)

          allowed = Counter(letters)

          def value(selection):
              required = Counter([])
              for i in range(N):
                  if selection & (1 << i):
                      required.update(words[i])
              ans = 0
              for k, v in required.items():
                  if allowed[k] < required[k]:
                      return float("-inf")
                  ans += required[k] * score[ord(k) - ord("a")]
              return ans

          return max(value(selection) for selection in range(2**N))


  assert (
      Solution().maxScoreWords(
          ["dog", "cat", "dad", "good"],
          ["a", "a", "c", "d", "d", "d", "g", "o", "o"],
          [1, 0, 9, 5, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      )
      == 23
  )
  assert (
      Solution().maxScoreWords(
          ["xxxz", "ax", "bx", "cx"],
          ["z", "a", "b", "c", "x", "x", "x"],
          [4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 10],
      )
      == 27
  )
  assert (
      Solution().maxScoreWords(
          ["leetcode"],
          ["l", "e", "t", "c", "o", "d"],
          [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
      )
      == 0
  )
#+end_src

* Leetcode: 1220. Count Vowels Permutation
:PROPERTIES:
:ID:       F572456D-0405-4799-85B5-C56D78EAC3F7
:END:
:LOGBOOK:
CLOCK: [2022-08-21 Sun 21:43]--[2022-08-21 Sun 21:52] =>  0:09
:END:
[[https://leetcode.com/problems/count-vowels-permutation/][Problem Statement]]

#+begin_src python
  from collections import defaultdict


  class Solution:
      def countVowelPermutation(self, n: int) -> int:
          adj = {"a": "e", "e": "ai", "i": "aeou", "o": "iu", "u": "a"}
          cur = nxt = defaultdict(lambda: 1)
          for i in range(n - 2, -1, -1):
              cur = defaultdict(int)
              for u in "aeiou":
                  cnt = 0
                  for v in adj[u]:
                      cnt = (cnt + nxt[v]) % 1_000_000_007
                  cur[u] = cnt
              nxt = cur
          return sum(cur[u] for u in "aeiou") % 1_000_000_007


  assert Solution().countVowelPermutation(1) == 5
  assert Solution().countVowelPermutation(2) == 10
  assert Solution().countVowelPermutation(5) == 68
#+end_src

* Leetcode: 992. Subarrays with K Different Integers
:PROPERTIES:
:ID:       0D0909E1-3EBE-4278-9BD4-E88BA2F4ACD7
:ORDERED:  t
:END:
:LOGBOOK:
CLOCK: [2022-08-26 Fri 20:39]--[2022-08-26 Fri 20:51] =>  0:12
CLOCK: [2022-08-26 Fri 18:21]--[2022-08-26 Fri 19:07] =>  0:46
CLOCK: [2022-08-21 Sun 21:55]--[2022-08-21 Sun 22:04] =>  0:09
:END:
[[https://leetcode.com/problems/subarrays-with-k-different-integers/][Problem Statement]]

- [[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  Compute $c(x)$ which is the number of arrays with at most $x$ distinct elements.  The answer for the original problem is $c(k) - c(k-1)$.  Time and space complexity is $O(N)$.

#+begin_src python
  from typing import List


  class Solution:
      def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:
          N = len(nums)

          def calc(k):
              c = [0] * (N + 1)
              j = d = ans = 0
              for i in range(N):
                  c[nums[i]] += 1
                  d += 1 if c[nums[i]] == 1 else 0
                  while d > k:
                      c[nums[j]] -= 1
                      d -= 1 if c[nums[j]] == 0 else 0
                      j += 1
                  ans += i - j + 1
              return ans

          return calc(k) - calc(k - 1)


  assert Solution().subarraysWithKDistinct([1, 2, 1, 2, 3], 2) == 7
  assert Solution().subarraysWithKDistinct([1, 2, 1, 3, 4], 3) == 3
#+end_src

* Leetcode: 827. Making A Large Island
:PROPERTIES:
:ID:       5F39F428-D713-4C70-942A-37F0C4C18635
:END:
:LOGBOOK:
CLOCK: [2022-08-28 Sun 20:32]--[2022-08-28 Sun 20:43] =>  0:11
:END:
[[https://leetcode.com/problems/making-a-large-island/][Problem Statement]]

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  Did not test for world without any island.

- [[id:DA1E3A63-73BB-475E-B087-128602B13450][Can we formulate the problem using graphs?]]  Island cells are vertices and they are connected if they are 4-directional neighbor.  The problem becomes finding all connected component and then testing which 0-cell would create the largest component.  Time and space complexity are $O(n^2)$.

#+begin_src python
  from typing import List
  from collections import defaultdict


  class Solution:
      def largestIsland(self, grid: List[List[int]]) -> int:
          N = len(grid)
          D = [[+1, +0], [-1, +0], [+0, +1], [+0, -1]]
          counter = defaultdict(int)

          def dfs(i, j, key):
              counter[key] += 1
              grid[i][j] = key
              for di, dj in D:
                  ni = i + di
                  nj = j + dj
                  if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] == 1:
                      dfs(ni, nj, key)

          cur = 2
          for i in range(N):
              for j in range(N):
                  if grid[i][j] == 1:
                      dfs(i, j, cur)
                      cur += 1

          ans = max(counter.values()) if counter else 0
          for i in range(N):
              for j in range(N):
                  if grid[i][j] == 0:
                      candidates = set()
                      for di, dj in D:
                          ni = i + di
                          nj = j + dj
                          if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] != 0:
                              candidates.add(grid[ni][nj])
                      cur = 1
                      for c in candidates:
                          cur += counter[c]
                      if cur > ans:
                          ans = cur
          return ans


  assert Solution().largestIsland([[1, 0], [0, 1]]) == 3
  assert Solution().largestIsland([[1, 1], [1, 0]]) == 4
  assert Solution().largestIsland([[1, 1], [1, 1]]) == 4
#+end_src

* Leetcode: 1363. Largest Multiple of Three
:PROPERTIES:
:ID:       DF825BC2-F0B1-4706-B80A-3C2809816307
:WA:       2
:END:
:LOGBOOK:
CLOCK: [2022-08-28 Sun 21:13]--[2022-08-28 Sun 21:44] =>  0:31
CLOCK: [2022-08-28 Sun 20:48]--[2022-08-28 Sun 21:06] =>  0:18
:END:
[[https://leetcode.com/problems/largest-multiple-of-three/][Problem Statement]]

- [[id:F19C9539-EE46-41EE-8DEF-24C3076C6DC2][Can we simplify the problem while keeping it the same?]]  As $10^k \mod 3 = 1$, we are concerned on picking digits where their sum in divisible by $3$.  All digits divisible by $3$ will be part of the answer, so the problem is to maximize $2 \times x + y$ where $x$ and $y$ are the number of digits with rest $2$ and $1$ respectively.  Time complexity is $O(x \times y + n)$ and space is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def largestMultipleOfThree(self, digits: List[int]) -> str:
          digits.sort(reverse=True)
          cmod = Counter([d % 3 for d in digits])
          r2 = r1 = 0
          for i in range(cmod[2] + 1):
              for j in range(cmod[1], -1, -1):
                  if i + j < r2 + r1:
                      break
                  if (2 * i + j) % 3 == 0:
                      r2 = i
                      r1 = j
          ans = deque()
          for d in digits:
              if d % 3 == 0:
                  ans.append(d)
              if d % 3 == 1 and r1 > 0:
                  r1 -= 1
                  ans.append(d)
              if d % 3 == 2 and r2 > 0:
                  r2 -= 1
                  ans.append(d)
          while len(ans) > 1 and ans[0] == 0:
              ans.popleft()

          return "".join(map(str, ans))


  assert Solution().largestMultipleOfThree([8, 1, 9]) == "981"
  assert Solution().largestMultipleOfThree([8, 6, 7, 1, 0]) == "8760"
  assert Solution().largestMultipleOfThree([1]) == ""
#+end_src

* Leetcode: 1235. Maximum Profit in Job Scheduling
:PROPERTIES:
:ID:       13BDDA9F-695C-4F9A-BA21-284366128987
:END:
:LOGBOOK:
CLOCK: [2022-08-30 Tue 11:17]--[2022-08-30 Tue 11:23] =>  0:06
CLOCK: [2022-08-29 Mon 22:18]--[2022-08-29 Mon 22:52] =>  0:34
:END:
[[https://leetcode.com/problems/maximum-profit-in-job-scheduling/][Problem Statement]]

- [[id:40E38FD2-DDF0-4C25-BB8C-43D07F3D5136][Mistake: Overcomplicated solution]].  Tried to save memory by keeping

- [[id:42B21DBC-4951-4AF2-8C41-A646F5675365][Can we pre-process the input in a way to make easy to solve the problem?]]  Sort the jobs by start time.  [[id:29DB5011-3209-4B10-BAA5-823D1ADB9F47][How could we find the optimal interval knowing a tiny part of it?]]  If the job is part of the solution, it means that you can only extend it after the job's end.  To find the next job, we can search for the job that starts on that time with a [[id:1217FC3D-A9F9-49EC-BA5D-A68E50338DBD][Binary-search]].  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  from typing import List
  from bisect import bisect_left


  class Solution:
      def jobScheduling(
          self, startTime: List[int], endTime: List[int], profit: List[int]
      ) -> int:
          N = len(startTime)
          s = []
          e = []
          p = []
          for a, b, c in sorted(zip(startTime, endTime, profit)):
              s.append(a)
              e.append(b)
              p.append(c)

          dp = [0] * (N + 1)
          for i in range(N - 1, -1, -1):
              dp[i] = max(dp[i + 1], p[i] + dp[bisect_left(s, e[i], lo=i + 1)])

          return dp[0]


  assert Solution().jobScheduling([1, 2, 3, 3], [3, 4, 5, 6], [50, 10, 40, 70]) == 120
  assert (
      Solution().jobScheduling([1, 2, 3, 4, 6], [3, 5, 10, 6, 9], [20, 20, 100, 70, 60])
      == 150
  )
  assert Solution().jobScheduling([1, 1, 1], [2, 3, 4], [5, 6, 4]) == 6
#+end_src

* TODO Leetcode: 2281. Sum of Total Strength of Wizards
:PROPERTIES:
:ID:       AB50C209-FD17-43D6-B381-D0BBB65D794A
:END:
:LOGBOOK:
CLOCK: [2022-09-02 Fri 21:34]--[2022-09-02 Fri 22:10] =>  0:36
:END:
[[https://leetcode.com/problems/sum-of-total-strength-of-wizards/][Problem Statement]]

* Leetcode: 472. Concatenated Words
:PROPERTIES:
:ID:       F2FBF2DB-B25A-415F-A69A-0DA0F5D8CCA4
:END:
:LOGBOOK:
CLOCK: [2022-09-07 Wed 12:35]--[2022-09-07 Wed 12:50] =>  0:15
:END:
[[https://leetcode.com/problems/concatenated-words/][Problem Statement]]

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  For a given word, find if it is possible to decompose it as words in the dictionary.  The search-space for this problem is $(i, j, k)$ which means if it possible to break down the word $i$, starting on position $j$ after breaking it already in $k$ parts.  The problem left is to quickly find a part starting on the current position which can be solved using a [[id:5BC30FCA-3402-4DA7-89D9-7661FEBDA3A7][Trie]].  Time complexity is $O(n \times s)$ where $s$ is $\max |w[i]|$.  Space complexity is $\sum |w[i]|$.

#+begin_src python
  from typing import List


  class Solution:
      def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
          root = {}
          for w in words:
              node = root
              for c in w:
                  node.setdefault(c, {})
                  node = node[c]
              node["$"] = True

          @cache
          def dfs(i, j, k):
              if j == len(words[i]):
                  return k > 1
              node = root
              while j < len(words[i]) and words[i][j] in node:
                  node = node[words[i][j]]
                  j += 1
                  if "$" in node and dfs(i, j, k + 1):
                      return True
              return False

          return [w for i, w in enumerate(words) if dfs(i, 0, 0)]
#+end_src

* Leetcode: 2262. Total Appeal of A String
:PROPERTIES:
:ID:       4A0AE191-1DFF-4AA4-91F8-B1E9148600A7
:END:
:LOGBOOK:
CLOCK: [2022-09-07 Wed 14:05]--[2022-09-07 Wed 14:35] =>  0:30
:END:
[[https://leetcode.com/problems/total-appeal-of-a-string/][Problem Statement]]

- [[id:64E7E55B-09A9-4022-AB5E-1D25FC64EAC9][Is there an alternative problem easier to solve?]]  Count the number of substring that $s[i]$ is the first appearance of $s[i]$ on it.  For strings starting on $i$, it will appear on $N - i$ of those.  It will appear in the mid of $(i - prev[s[i]]) \times (N - i - 1)$ where $prev[s[i]]$ is the last occurrence of $s[i]$ on $0..(i-1)$.  Time complexity is $O(n)$ and space is $O(1)$.

#+begin_src python
  class Solution:
      def appealSum(self, s: str) -> int:
          N = len(s)
          last = defaultdict(lambda: -1)
          prev = [-1] * N
          for i in range(N):
              prev[i] = last[s[i]]
              last[s[i]] = i
          ans = 0
          for i in range(N):
              ans += (N - i) * (i - prev[i])
          return ans
#+end_src

* Leetcode: 2193. Minimum Number of Moves to Make Palindrome
:PROPERTIES:
:ID:       A99E2331-016F-4B16-BF2F-4B275E957030
:END:
:LOGBOOK:
CLOCK: [2022-09-07 Wed 14:35]--[2022-09-07 Wed 16:13] =>  1:38
:END:
[[https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/][Problem Statement]]

- [[id:40E38FD2-DDF0-4C25-BB8C-43D07F3D5136][Mistake: Overcomplicated solution]].  Tried to search through all possible sub-problems and didn't consider (couldn't prove) that the greedy approach work.

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  If the first and last char match, we can discard them.  Otherwise, we should fix the end that requires the less amount of swaps.  Time complexity is $O(n^2)$ and space is $O(n)$.

#+begin_src python
  class Solution:
      def minMovesToMakePalindrome(self, s: str) -> int:
          def normalize(s):
              i = 0
              j = len(s) - 1
              while i < j:
                  if s[i] != s[j]:
                      return s[i : j + 1]
                  i += 1
                  j -= 1
              return ""

          ans = 0
          s = normalize(s)
          while s:
              i = s.find(s[-1])
              j = s.rfind(s[0])
              if i < len(s) - j - 1:
                  ans += i
                  s = normalize(s[-1] + s[:i] + s[i + 1 :])
              else:
                  ans += len(s) - j - 1
                  s = normalize(s[:j] + s[j + 1 :] + s[0])
          return ans
#+end_src

* Leetcode: 2102. Sequentially Ordinal Rank Tracker
:PROPERTIES:
:ID:       CBD5B33F-E1BF-4DD2-9125-FD95FB0FF870
:END:
:LOGBOOK:
CLOCK: [2022-09-07 Wed 16:18]--[2022-09-07 Wed 16:24] =>  0:06
:END:


[[https://leetcode.com/problems/sequentially-ordinal-rank-tracker/][Problem Statement]]

- [[id:42B21DBC-4951-4AF2-8C41-A646F5675365][Can we pre-process the input in a way to make easy to solve the problem?]]  Keep the input sorted by score and name.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  from sortedcontainers import SortedList


  class SORTracker:
      def __init__(self):
          self.loc = SortedList()
          self.q = 0

      def add(self, name: str, score: int) -> None:
          self.loc.add((-score, name))

      def get(self) -> str:
          ans = self.loc[self.q][1]
          self.q += 1
          return ans


  # Your SORTracker object will be instantiated and called as such:
  # obj = SORTracker()
  # obj.add(name,score)
  # param_2 = obj.get()
#+end_src

* Leetcode: 1597. Build Binary Expression Tree From Infix Expression
:PROPERTIES:
:ID:       8FD02C5E-F7EB-4ED1-94CF-4BD1CEAE5D0A
:END:
[[https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression/][Problem Statement]]

- [[id:69D68202-BF1A-4D72-A0EC-DDCBAF112500][Can we break-down the problem in small and easily to solve parts?]]  Convert the expression from infix to posfix and then generate the binary expression tree using the posfix form.  Time and space complexity are $O(n)$.

#+begin_src python
  # Definition for a binary tree node.
  # class Node(object):
  #     def __init__(self, val=" ", left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution:
      def expTree(self, s: str) -> "Node":
          s = "(" + s + ")"
          precedence = {"+": 1, "-": 1, "*": 2, "/": 2}
          posfix = []
          st = []
          for c in s:
              if c.isdigit():
                  posfix.append(c)
              elif c == "(":
                  st.append(c)
              elif c == ")":
                  while st and st[-1] != "(":
                      posfix.append(st.pop())
                  st.pop()
              else:
                  while st and st[-1] != "(" and precedence[c] <= precedence[st[-1]]:
                      posfix.append(st.pop())
                  st.append(c)
          ans = []
          for c in posfix:
              if c.isdigit():
                  ans.append(Node(c))
              else:
                  right = ans.pop()
                  left = ans.pop()
                  ans.append(Node(c, left, right))
          return ans[0]
#+end_src

* Leetcode: 140. Word Break II
:PROPERTIES:
:ID:       0A372973-D6BE-4795-8AB5-19CEB73163C6
:END:
:LOGBOOK:
CLOCK: [2022-09-07 Wed 21:08]--[2022-09-07 Wed 21:13] =>  0:05
:END:
[[https://leetcode.com/problems/word-break-ii/][Problem Statement]]

- [[id:29512D97-A54D-42F9-A8C7-C3422881933B][Can we use brute-force to solve the problem?]]  Generate all possible answers using a [[id:5BC30FCA-3402-4DA7-89D9-7661FEBDA3A7][Trie]] to optimize the search for the current word.  Time and space complexity are $2^n$.

#+begin_src python
  class Solution:
      def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
          ans = []

          root = {}
          for w in wordDict:
              node = root
              for c in w:
                  node.setdefault(c, {})
                  node = node[c]
              node["$"] = w

          def bt(i, cur):
              nonlocal ans
              if i == len(s):
                  ans.append(cur)
              node = root
              while i < len(s) and s[i] in node:
                  node = node[s[i]]
                  i += 1
                  if "$" in node:
                      bt(i, cur + (" " if cur else "") + node["$"])

          bt(0, "")
          return ans
#+end_src

* Leetcode: 719. Find K-th Smallest Pair Distance
:PROPERTIES:
:ID:       A3246CDA-D036-425C-B42D-D6B4E7105BE2
:END:
[[https://leetcode.com/problems/find-k-th-smallest-pair-distance/][Problem Statement]]

- [[id:3ECFA6C4-B482-49CA-B8C6-C67DA07B6EAE][Can we state the problem as result of multiple searches?]]  Use a [[id:1217FC3D-A9F9-49EC-BA5D-A68E50338DBD][Binary-search]] to find the value of the k-th smallest pair distance.  To verify if the value $a$ is a valid answer, count the number of pairs starting on $i$: $j - i - 1$ where $nums[j] < nums[i] + a$.  The value for $j$ can be found using a second [[id:1217FC3D-A9F9-49EC-BA5D-A68E50338DBD][Binary-search]].  Time complexity is $O(n \log n \log m)$ where $m=max(nums) - min(nums)$.  Space complexity is $O(1)$.

#+begin_src python
  from typing import List


  class Solution:
      def smallestDistancePair(self, nums: List[int], k: int) -> int:
          N = len(nums)
          nums.sort()

          def check(delta):
              cur = 0
              for i in range(N):
                  j = bisect_right(nums, nums[i] + delta, lo=i)
                  cur += j - i - 1
              return cur >= k

          lo = 0
          hi = nums[-1] - nums[0]
          while lo < hi:
              mid = lo + (hi - lo) // 2
              if check(mid):
                  hi = mid
              else:
                  lo = mid + 1
          return lo
#+end_src

* Leetcode: 1044. Longest Duplicate Substring
:PROPERTIES:
:ID:       6FC3B96C-A739-4A99-BAC4-B33039471D43
:END:
:LOGBOOK:
CLOCK: [2022-09-08 Thu 16:52]--[2022-09-08 Thu 19:00] =>  2:08
:END:
[[https://leetcode.com/problems/longest-duplicate-substring/][Problem Statement]]

- [[id:BA8FA096-1785-4100-BF9F-E1D101994F21][Can we formulate the problem as searching the last element that satisfy a condition?]]  We want to find the max (or last) $k$ such that there are two equal substrings of $s$ of length $k$.  To find $k$, we can use a [[id:1217FC3D-A9F9-49EC-BA5D-A68E50338DBD][Binary-search]] and to check if there are such substrings we can use [[id:85E6E394-A1B3-4DE0-835C-CCE7D2830150][Rabin-Karp Algorithm for string matching]].  Time complexity is $O(n \log n)$ and space $O(n)$.

#+begin_src python
  class Solution:
      def longestDupSubstring(self, s: str) -> str:
          n = [ord(c) - ord("a") for c in s]

          def check(k):
              P = 31
              MOD = 2**64 - 1
              Pk = (P**k) % MOD
              h = 0
              for i in range(k):
                  h = (h * P + n[i]) % MOD
              seen = {h: [0]}
              for i in range(k, len(s)):
                  h = (h * P + n[i] - n[i - k] * Pk) % MOD
                  for j in seen.setdefault(h, []):
                      if s[j : j + k] == s[i - k + 1 : i + 1]:
                          return s[i - k + 1 : i + 1]
                  seen[h].append(i - k + 1)
              return None

          lo = 0
          hi = len(s)
          while lo < hi:
              mid = lo + (hi - lo) // 2
              if check(mid) is None:
                  hi = mid
              else:
                  lo = mid + 1
          return check(lo - 1)
#+end_src

* Leetcode: 2355. Maximum Number of Books You Can Take
:PROPERTIES:
:ID:       CBBD1815-6ACA-4763-A3C8-C3D1E0CD6EDC
:END:
:LOGBOOK:
CLOCK: [2022-09-08 Thu 19:07]--[2022-09-08 Thu 19:49] =>  0:42
:END:
[[https://leetcode.com/problems/maximum-number-of-books-you-can-take/][Problem Statement]]

- [[id:C715BAE2-002C-4F72-B5FC-5E727F0BA19E][Pattern: Find optimal subarray]].  Use a [[id:E4CFDB04-DCFD-47E3-9ED2-0DC6446420B5][Monotonic Stack]] to support the construction of the optimal subarrays ending on each index of the array.  Time and space complexity are $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def maximumBooks(self, books: List[int]) -> int:
          st = []
          best = [0] * len(books)
          pa = lambda n: (n * (n + 1)) // 2
          ans = 0
          for i, b in enumerate(books):
              while st and books[st[-1]] >= b - (i - st[-1]):
                  st.pop()
              if not st:
                  best[i] = pa(b) if b <= i else pa(b) - pa(b - i - 1)
              else:
                  best[i] = pa(b) if b <= i - st[-1] else pa(b) - pa(b - (i - st[-1]))
                  best[i] += best[st[-1]]
              if best[i] > ans:
                  ans = best[i]
                  tmp = i
              st.append(i)
          return ans
#+end_src

* Leetcode 295. Find Median from Data Stream
:PROPERTIES:
:ID:       7BC815C9-C3E6-4AD2-8FE1-C6B8226BDA43
:END:
[[https://leetcode.com/problems/find-median-from-data-stream/][Problem Statement]]

- [[id:A18543C4-83BC-40F1-A243-B85FD935FAC0][Pattern: Answer query on sorted data]].  Keep a sorted list of the numbers and compute the median using it.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  from sortedcontainers import SortedList


  class MedianFinder:
      def __init__(self):
          self.s = SortedList()

      def addNum(self, num: int) -> None:
          self.s.add(num)

      def findMedian(self) -> float:
          N = len(self.s)
          if N % 2 == 0:
              return (self.s[N // 2] + self.s[N // 2 - 1]) / 2
          return self.s[N // 2]


  # Your MedianFinder object will be instantiated and called as such:
  # obj = MedianFinder()
  # obj.addNum(num)
  # param_2 = obj.findMedian()
#+end_src

* Leetcode: 126. Word Ladder II
:PROPERTIES:
:ID:       6E5AC9EE-CFB9-4DBE-8753-E1E9F798D935
:END:
[[https://leetcode.com/problems/word-ladder-ii/][Problem Statement]]

- [[id:189F5E87-F560-4397-A3E3-AAD465EEBCFB][Pattern: Find all shortest path between two vertices in a graph]].  Find the min distance between destination and all other vertices using a [[id:AF8E855B-7F09-4A2C-BA75-DBA1FFEEF56F][Breadth-first search]], then generate all shortest path using the acyclic path created by the first search using [[id:212DBFC3-FE3C-493E-86A6-42FF3F82CD53][Depth-first search]].  Time and space complexity are $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def findLadders(
          self, beginWord: str, endWord: str, wordList: List[str]
      ) -> List[List[str]]:
          def is_adj(u, v):
              return sum(1 for a, b in zip(u, v) if a != b) == 1

          A = {w: [] for w in wordList + [beginWord, endWord]}
          for u in wordList + [endWord]:
              for v in wordList + [beginWord]:
                  if u != v and is_adj(u, v):
                      A[u].append(v)

          dist = {w: None for w in A}
          dist[endWord] = 0
          queue = [endWord]
          for u in queue:
              for v in A[u]:
                  if dist[v] is None:
                      dist[v] = dist[u] + 1
                      queue.append(v)

          ans = []
          for u in wordList:
              if u != beginWord and u not in A[beginWord] and is_adj(u, beginWord):
                  A[beginWord].append(u)

          @cache
          def dfs(u):
              if dist[u] == 0:
                  return [[u]]
              ans = []
              for v in A[u]:
                  if dist[v] == dist[u] - 1:
                      ans.extend([u] + p for p in dfs(v))
              return ans

          return dfs(beginWord)
#+end_src

* Leetcode: 297. Serialize and Deserialize Binary Tree
:PROPERTIES:
:ID:       44A53F90-1DA0-49FF-AE5B-FAB32D273DA0
:END:
[[https://leetcode.com/problems/serialize-and-deserialize-binary-tree/][Problem Statement]]

- [[id:768F4C3F-EEAA-429B-886F-0435CEC7DACD][Pattern: Traverse paths on tree]].

#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode(object):
  #     def __init__(self, x):
  #         self.val = x
  #         self.left = None
  #         self.right = None


  class Codec:
      def serialize(self, root):
          def dfs(node):
              if node is None:
                  return "None"
              return f"{node.val},{dfs(node.left)},{dfs(node.right)}"

          return dfs(root)

      def deserialize(self, data):
          vals = [None if v == "None" else int(v) for v in data.split(",")]

          def dfs(i):
              if vals[i] is None:
                  return i + 1, None
              u = vals[i]
              j, left = dfs(i + 1)
              j, right = dfs(j)
              return j, TreeNode(u, left, right)

          return dfs(0)[1]


  # Your Codec object will be instantiated and called as such:
  # ser = Codec()
  # deser = Codec()
  # ans = deser.deserialize(ser.serialize(root))
#+end_src

* Leetcode: 1335. Minimum Difficulty of a Job Schedule
:PROPERTIES:
:ID:       32FD4A66-C156-49EB-A3A3-A411D13B27EF
:END:
[[https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/][Problem Statement]]

- [[id:4060A2EA-09E8-4E05-922D-8340AAF60F44][Pattern: Find optimal partition of array]].  Split the jobs in all possible partitions respecting the number of days.  The base case is when there is only one day which should be the max of all remaining jobs.  Time complexity is $O(n^2 \times d)$ and space is $O(n \times d)$.

#+begin_src python
  from typing import List


  class Solution:
      def minDifficulty(self, job: List[int], d: int) -> int:
          N = len(job)

          @cache
          def dfs(i, d):
              if d == 1:
                  return max(job[i:])
              best = float("inf")
              maxv = float("-inf")
              for j in range(i, N - d + 1):
                  maxv = max(maxv, job[j])
                  if maxv < best:
                      best = min(best, maxv + dfs(j + 1, d - 1))
              return best

          return -1 if dfs(0, d) == float("inf") else dfs(0, d)
#+end_src

  - Alternative solution.  As the priority of each job is small, we can use it as parameter of the search and delay the computation of the cost of day to when we make a transition to the next one.  Time complexity is $O(n \times m \times d)$ and space is $O(n \times m \times d)$.

#+begin_src python
  from typing import List


  class Solution:
      def minDifficulty(self, job: List[int], d: int) -> int:
          N = len(job)

          @cache
          def dfs(i, cur, d):
              if i == N:
                  return cur if d == 0 else float("inf")
              return min(
                  dfs(i + 1, max(cur, job[i]), d), max(cur, job[i]) + dfs(i + 1, 0, d - 1)
              )

          return -1 if dfs(0, 0, d) == float("inf") else dfs(0, 0, d)
#+end_src

* Leetcode: 2163. Minimum Difference in Sums After Removal of Elements
:PROPERTIES:
:ID:       81BAA14E-FAEA-4535-80A5-5B1DDC784D0C
:END:
[[https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/][Problem Statement]]

- [[id:4060A2EA-09E8-4E05-922D-8340AAF60F44][Pattern: Find optimal partition of array]].  Partition the given array in two subarrays $ln=a[0..i]$ and $rn=a[(i+1)..(n-1)]$ such that $\sum l[i] - \sum r[j]$ is the smallest possible after removing elements from $l$ and $r$ to make them have exactly $n$ elements.  Due the optimization function, we want to remove the greatest elements from $l$ and the smaller elements from $r$ to make both have exactly $n$ elements.  To solve the problem, we can first compute $l(i)$ and $r(i)$ which is the best left and right sum ending on $i$.  This can be done by keeping two sorted list while processing the indexes from the left to right and right to left respectively.  Time complexity is $O(n \log n)$ with space is $O(n)$.

#+begin_src python
  from heapq import heappush, heappop
  from typing import List


  class Solution:
      def minimumDifference(self, nums: List[int]) -> int:
          N = len(nums)
          M = N // 3

          left = []
          left_sum = 0
          dpl = [float("inf")] * N
          for i in range(2 * M):
              left_sum += nums[i]
              heappush(left, -nums[i])
              if len(left) > M:
                  left_sum -= -heappop(left)
              if i >= M - 1:
                  dpl[i] = left_sum

          right = []
          right_sum = 0
          ans = float("inf")
          for i in range(N - 1, M - 1, -1):
              right_sum += nums[i]
              heappush(right, nums[i])
              if len(right) > M:
                  right_sum -= heappop(right)
              if N - i >= M - 1:
                  ans = min(ans, dpl[i - 1] - right_sum)

          return ans
#+end_src

* Leetcode: 891. Sum of Subsequence Widths
:PROPERTIES:
:ID:       76692296-A2EF-495E-B1B0-1FBD9A36A503
:END:
[[https://leetcode.com/problems/sum-of-subsequence-widths/][Problem Statement]]

- [[id:21114DEC-E1B0-4B45-8A7C-E4DA93BB9474][Pattern: Compute value for all subsequences of an array]].  Sort the array and compute how many time each element appear as the minimum and maximum in all subsequences.  Time complexity is $O(n)$ with space $O(1)$.

#+begin_src python
  from typing import List


  class Solution:
      def sumSubseqWidths(self, nums: List[int]) -> int:
          N = len(nums)
          MOD = 10**9 + 7
          nums.sort()

          mins = 0
          maxs = 0
          p = 1
          for i in range(N):
              mins = (mins + nums[N - i - 1] * p) % MOD
              maxs = (maxs + nums[i] * p) % MOD
              p = (p * 2) % MOD

          return (maxs - mins + MOD) % MOD
#+end_src

* Leetcode: 1649. Create Sorted Array through Instructions
:PROPERTIES:
:ID:       0CFF764C-9853-45BC-AD44-F258116A94AB
:END:
[[https://leetcode.com/problems/create-sorted-array-through-instructions/][Problem Statement]]

- [[id:A18543C4-83BC-40F1-A243-B85FD935FAC0][Pattern: Answer query on sorted data]].  For each instructions, keep the previous instructions sorted and use [[id:1217FC3D-A9F9-49EC-BA5D-A68E50338DBD][Binary-search]] to compute the number of strictly less and greater.  Time complexity is $O(n \log n)$ and space is $O(n)$.

#+begin_src python
  from sortedcontainers import SortedList
  from typing import List


  class Solution:
      def createSortedArray(self, instructions: List[int]) -> int:
          MOD = 10**9 + 7
          N = len(instructions)
          s = SortedList()
          ans = 0
          for i in instructions:
              l = s.bisect_left(i)
              r = len(s) - s.bisect_left(i + 1)
              ans = (ans + min(l, r)) % MOD
              s.add(i)
          return ans
#+end_src

* TODO Leetcode: 2040. Kth Smallest Product of Two Sorted Arrays
:PROPERTIES:
:ID:       BFAE0AE5-BB2C-4AE8-BCF3-FF4D9FB28315
:END:
[[https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/][Problem Statement]]

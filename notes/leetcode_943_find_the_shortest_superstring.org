:PROPERTIES:
:ID:       111BF0DE-ED4B-445B-ABBE-D5022DA96CC5
:ROAM_REFS: https://leetcode.com/problems/find-the-shortest-superstring/
:END:
#+TITLE: Leetcode: 943. Find the Shortest Superstring
#+ROAM_REFS: https://leetcode.com/problems/find-the-shortest-superstring/
#+LEETCODE_LEVEL: Hard
#+ANKI_DECK: Problem Solving
#+ANKI_CARD_ID: 1661446214876

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  Did not test for single elements (e.g. ~["a"]~).

- [[id:FEEE596A-DFF4-4B02-8995-1BCF70A76410][Pattern: Find optimal subset of small set]].

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]  After we put the word $i$, we should put a word $j$ using the maximum of overlap possible which is the biggest suffix of $i$ that is a prefix of $j$.  With that, we have to keep increasing the answer until all words are covered.

#+begin_src python
  from typing import List
  from functools import cache


  class Solution:
      def shortestSuperstring(self, words: List[str]) -> str:
          N = len(words)
          ALL = (1 << N) - 1

          @cache
          def k(a, b):
              for i in range(len(words[a]) + 1):
                  if words[b].startswith(words[a][i:]):
                      return i

          @cache
          def dfs(last, used):
              if used == ALL:
                  return words[last]
              ans = None
              for i in range(N):
                  if (1 << i) & used == 0:
                      cur = words[last][: k(last, i)] + dfs(i, used | (1 << i))
                      if ans is None or len(ans) > len(cur):
                          ans = cur
              return ans

          return min([dfs(i, (1 << i)) for i in range(N)], key=len)


  assert (
      Solution().shortestSuperstring(["alex", "loves", "leetcode"]) == "alexlovesleetcode"
  )
  assert (
      Solution().shortestSuperstring(["catg", "ctaagt", "gcta", "ttca", "atgcatc"])
      == "gctaagttcatgcatc"
  )
#+end_src

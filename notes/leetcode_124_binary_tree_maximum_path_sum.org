:PROPERTIES:
:ID:       D188B6DB-A827-4A63-B794-8708CEFB58B7
:END:
#+TITLE: Leetcode: 124. Binary Tree Maximum Path Sum
#+ANKI_DECK: Problem Solving
#+ANKI_CARD_ID: 1661446115465
#+ROAM_REFS: [[https://leetcode.com/problems/binary-tree-maximum-path-sum/]]

* Understand the Problem

[[id:6DFC6B45-0302-44F2-AC2B-842531C4639B][Pattern: Find optimal path in a tree]].  The optimal path is the path with the maximum sum.

** Useful prompts

- [[id:31D0B1E0-6881-478A-8F48-160BCFD94F31][Can we divide the search-space in two parts and combine solutions from both sides to solve the original problem?]]

- [[id:45B9F3C8-D007-4980-95EF-4361906245A8][How can we extend the solution for $i$ to $i+1$?]]

- [[id:37AF9679-42D1-4A85-9927-2A590268AD87][Blackbox: You solved a similar problem]].  Find the longest path in a tree which can be solved with two [[id:212DBFC3-FE3C-493E-86A6-42FF3F82CD53][Depth-first search]].

* Devise a plan

Be $u$ a node in the tree.  Find the maximum path starting from the left $l$ and from the right $r$ of $u$.  The maximum path starting from $u$ is either $val(u)$, $val(u)+l$ or $val(u)+r$.  To compute the final answer, we still have to consider $u$ as the root of the maximum path: $val(u)+l+r$.  Time complexity is $O(n)$ and space complexity is $O(depth)$.

** Carry out the plan

#+begin_src python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution:
      def maxPathSum(self, root: Optional[TreeNode]) -> int:
          ans = float("-inf")

          def dfs(node):
              nonlocal ans

              if node is None:
                  return 0

              lans = dfs(node.left) if node.left else float("-inf")
              rans = dfs(node.right) if node.right else float("-inf")
              cur = max(
                  node.val,
                  node.val + lans,
                  node.val + rans,
              )
              ans = max(ans, cur, node.val + lans + rans)

              return cur

          dfs(root)

          return ans
#+end_src

* Common mistakes

- [[id:29B5FD8A-98FD-48CE-8C30-04671E44AD27][Mistake: Missing edge case]].  The problem felt simple and I skipped the phase to create edge cases.

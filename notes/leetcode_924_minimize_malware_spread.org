:PROPERTIES:
:ID:       1D39550B-3FFE-400E-AABB-4BB8F8160E7D
:ROAM_REFS: https://leetcode.com/problems/minimize-malware-spread/
:END:
#+TITLE: Leetcode: 924. Minimize Malware Spread
#+ROAM_REFS: https://leetcode.com/problems/minimize-malware-spread/
#+LEETCODE_LEVEL: Hard
#+ANKI_DECK: Problem Solving
#+ANKI_CARD_ID: 1661446206435

- [[id:EEDBE877-7C4A-4D0B-BA6B-EFDF9288B78C][Blackbox: This is a variation of a classic problem]]: find bridges on graphs.  But it turned out that my intuition was wrong.  After reading the problem again, I noticed that we have to find the connected components instead.

- [[id:693ED7C4-4F2D-4AD1-8326-AB6C2D6D9BE6][Pattern: Find optimal component in graph]].  The answer is the component using [[id:212DBFC3-FE3C-493E-86A6-42FF3F82CD53][Depth-first search]] or [[id:23A4E36E-24D3-40F8-AA20-32C0DB1E36F6][Union-Find]] with maximum number of vertices that doesn't not contain other initial vertex, otherwise it is the initial vertex with smallest index.  Time complexity is $O(n^2)$ with space $O(n)$.

- [[id:1CFF662A-6F16-43CE-BB07-EA12BA382690][Can we formulate the problem as a classical problem?]]  Find [[id:367C887D-3517-4AC8-8219-293AC0E77E07][Connected Components in a Graph]] and pick the one that contains only one initial vertices and has maximum size or the smaller initial vertices id.  Time complexity is $O(n^2)$ and space is $O(n)$.

#+begin_src python
  from typing import List


  class Solution:
      def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
          N = len(graph)
          vis = [None] * N
          comp_size = [0] * N
          initial = set(initial)

          def dfs(u, p):
              for v in range(N):
                  if graph[u][v] == 1 and vis[v] is None:
                      vis[v] = p
                      comp_size[p] += 1
                      dfs(v, p)

          for u in initial:
              if vis[u] is None:
                  vis[u] = u
                  comp_size[u] += 1
                  dfs(u, u)

          comp_initial = [0] * N
          for u in initial:
              comp_initial[vis[u]] += 1

          ans = None
          for u in initial:
              improve = 0 if comp_initial[vis[u]] > 1 else comp_size[vis[u]]
              if ans is None or ans[1] < improve or (ans[1] == improve and ans[0] > u):
                  ans = (u, improve)

          return ans[0] if ans else 0


  assert Solution().minMalwareSpread([[1, 1, 0], [1, 1, 0], [0, 0, 1]], [0, 1]) == 0
  assert Solution().minMalwareSpread([[1, 0, 0], [0, 1, 0], [0, 0, 1]], [0, 2]) == 0
  assert Solution().minMalwareSpread([[1, 1, 1], [1, 1, 1], [1, 1, 1]], [1, 2]) == 1
#+end_src

#+begin_src python
  from typing import List


  class Solution:
      def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
          N = len(graph)
          initial.sort()

          p = [i for i in range(N)]

          def find(u):
              if p[u] != u:
                  p[u] = find(p[u])
              return p[u]

          def union(u, v):
              p[find(u)] = p[find(v)]

          ans = None
          for u in range(N):
              for v in range(u + 1, N):
                  if graph[u][v]:
                      union(u, v)

          s = [0] * N
          for u in range(N):
              s[find(u)] += 1

          ans = None
          for u in initial:
              if all(p[find(u)] != p[find(v)] for v in initial if u != v):
                  if ans is None or s[find(ans)] < s[find(u)]:
                      ans = u
          return ans if ans is not None else initial[0]
#+end_src
